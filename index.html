<!DOCTYPE html>
<html lang="ko">
  <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DIT 자세 분석 AI (최종 통합버전)</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;800&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0b0f14;
  --panel: rgba(30, 34, 42, 0.7);
  --accent: #7c9cff;
  --accent2: #ffb86c;
  --ink: #e7eef7;
  --muted: #9bb0c7;
  --radius: 18px;
}
* { box-sizing: border-box; }
html, body {
  margin: 0; 
  padding: 0;
  height: 100%;
  -webkit-overflow-scrolling: touch;
}
body {
  background: var(--bg); 
  color: var(--ink);
  font-family: "Noto Sans KR", sans-serif;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  overflow-x: hidden;
}
.panel {
  background: var(--panel);
  backdrop-filter: blur(20px);
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 10px 25px rgba(0,0,0,0.4);
}
.sidebar { 
  padding: 12px; 
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 50vh;
  -webkit-overflow-scrolling: touch;
}
.title { 
  font-size: 16px; 
  font-weight:800; 
  margin-bottom: 6px; 
  line-height: 1.3;
}
.muted { 
  color: var(--muted); 
  font-size: 11px; 
  line-height: 1.4;
}
.btn {
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  padding: 10px 14px;
  background: rgba(255,255,255,0.05);
  color: var(--ink);
  cursor: pointer;
  font-size: 13px;
  width: 100%;
  text-align: center;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.btn:hover, .btn:active { 
  background: rgba(255,255,255,0.12); 
}
.seg { 
  display: flex; 
  border-radius: 10px; 
  overflow: hidden; 
  margin-top: 8px; 
  gap: 4px;
}
.seg button { 
  flex:1; 
  border:0; 
  background: rgba(255,255,255,0.04); 
  color:var(--muted); 
  padding:10px 8px; 
  cursor:pointer; 
  font-size: 13px;
  touch-action: manipulation;
}
.seg button.active { 
  background: rgba(124,156,255,0.25); 
  color:var(--ink); 
}
label.btn { 
  display: block;
  width: 100%;
  margin-bottom: 8px;
}
label.btn input { display:none; }
.tbl { 
  width:100%; 
  border-collapse:collapse; 
  font-size:11px; 
  overflow-x: auto;
  display: table;
  -webkit-overflow-scrolling: touch;
}
.tbl th,.tbl td { 
  border-bottom:1px solid rgba(255,255,255,0.1); 
  padding:6px 4px; 
  text-align: center;
  font-size: 10px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.canvasWrap { 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  flex: 1;
  min-height: 50vh;
  padding: 8px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
}
.canvasWrap.zoomed {
  align-items: flex-start;
  justify-content: flex-start;
}
canvas { 
  border-radius:var(--radius); 
  background:#0a0e13; 
  cursor: crosshair; 
  touch-action: none; /* 드래그와 스크롤을 JavaScript로 제어 */
  display: block;
  flex-shrink: 0;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
  user-select: none;
  -webkit-user-select: none;
}
</style>
  </head>
  <body>
<aside class="panel sidebar" style="order: 1;">
  <div class="title">📸 DIT 자세 분석 AI</div>
  <div class="muted">파일 업로드 → 점을 드래그로 조정 → 각도 자동 계산</div>

  <div class="seg">
    <button id="btnBefore" class="active">Before</button>
    <button id="btnAfter">After</button>
  </div>
  <div style="margin-top:8px; display:flex; flex-direction:column; gap:8px;">
    <div class="seg" style="margin-bottom:4px;">
      <button id="btnOrientationSide" class="active">📐 옆모습</button>
      <button id="btnOrientationFront">📷 정면</button>
    </div>
    <label class="btn">📷 파일 선택
      <input id="filePicker" type="file" accept="image/*">
    </label>
    <label class="btn">📸 직접 촬영
      <input id="cameraPicker" type="file" accept="image/*" capture="environment">
    </label>
    <button class="btn" id="btnReset">↺ 초기화</button>
    <button class="btn" id="btnCalibrate" style="background: rgba(255,184,108,0.2);">📏 캘리브레이션</button>
  </div>

  <div id="calibrationPanel" style="margin-top:12px; padding:10px; background:rgba(255,184,108,0.1); border-radius:10px; display:none;">
    <div class="muted" style="margin-bottom:8px; font-weight:600;">📏 캘리브레이션</div>
    <div class="muted" style="font-size:11px; margin-bottom:8px;">기준 마커 두 점을 찍고 실제 길이(cm)를 입력하세요</div>
    <div style="margin-bottom:8px;">
      <input type="number" id="calibrationLength" placeholder="실제 길이 (cm)" step="0.1" min="0.1" style="width:100%; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); background:rgba(0,0,0,0.3); color:var(--ink);">
    </div>
    <div class="muted" style="font-size:11px; margin-bottom:4px;">점 1: <span id="calPoint1">클릭하여 선택</span></div>
    <div class="muted" style="font-size:11px; margin-bottom:8px;">점 2: <span id="calPoint2">클릭하여 선택</span></div>
    <button class="btn" id="btnCalibrateConfirm" style="width:100%; margin-bottom:8px;">✅ 계산</button>
    <button class="btn" id="btnCalibrateCancel" style="width:100%;">❌ 취소</button>
    <div id="calibrationResult" class="muted" style="font-size:11px; margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);"></div>
  </div>

  <div style="margin-top:10px; display:flex; flex-direction:column; gap:8px;">
    <button class="btn" id="btnEditCoords" style="background: rgba(124,156,255,0.2);">✏️ 좌표 수정 모드</button>
    <button class="btn" id="btnSaveJSON">💾 좌표 저장</button>
    <button class="btn" id="btnLoadJSON">📂 좌표 불러오기</button>
    <button class="btn" id="btnPDF">📄 PDF 저장</button>
    <button class="btn" id="btnImage">🖼️ 그림으로 저장</button>
    <button class="btn" id="btnShare">📤 공유하기</button>
  </div>

  <div id="coordEditPanel" style="margin-top:12px; padding:10px; background:rgba(124,156,255,0.1); border-radius:10px; display:none;">
    <div class="muted" style="margin-bottom:8px; font-weight:600;">좌표 수정</div>
    <div style="margin-bottom:8px;">
      <div class="muted" style="font-size:11px; margin-bottom:4px;">확대 배율</div>
      <select id="zoomLevel" class="btn" style="width:100%; padding:6px; margin-bottom:8px;">
        <option value="1">원본 크기 (1배)</option>
        <option value="2">2배 확대 (스크롤 가능)</option>
        <option value="3">3배 확대 (스크롤 가능)</option>
        <option value="4">4배 확대 (스크롤 가능)</option>
      </select>
      <div class="muted" style="font-size:10px; margin-top:4px; margin-bottom:8px; line-height:1.4;">확대 시 양손으로 드래그하여 이동 가능</div>
    </div>
    <div style="margin-bottom:8px;">
      <select id="coordSelectPoint" class="btn" style="width:100%; padding:6px; margin-bottom:6px;">
        <option value="">점 선택...</option>
        <!-- 옵션은 JavaScript에서 동적으로 업데이트됨 -->
      </select>
    </div>
    <div style="display:flex; flex-direction:column; gap:6px; margin-bottom:6px;">
      <div>
        <div class="muted" style="font-size:11px; margin-bottom:4px;">X 좌표</div>
        <div style="display:flex; gap:4px; align-items:center;">
          <input type="number" id="coordX" class="btn" style="flex:1; padding:8px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.1);" step="0.1" placeholder="X">
          <button class="btn" id="coordXDec" style="padding:8px 12px; background:rgba(255,107,107,0.2); border:1px solid rgba(255,107,107,0.3); min-width:40px;">−</button>
          <button class="btn" id="coordXInc" style="padding:8px 12px; background:rgba(46,196,182,0.2); border:1px solid rgba(46,196,182,0.3); min-width:40px;">+</button>
        </div>
      </div>
      <div>
        <div class="muted" style="font-size:11px; margin-bottom:4px;">Y 좌표</div>
        <div style="display:flex; gap:4px; align-items:center;">
          <input type="number" id="coordY" class="btn" style="flex:1; padding:8px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.1);" step="0.1" placeholder="Y">
          <button class="btn" id="coordYDec" style="padding:8px 12px; background:rgba(255,107,107,0.2); border:1px solid rgba(255,107,107,0.3); min-width:40px;">−</button>
          <button class="btn" id="coordYInc" style="padding:8px 12px; background:rgba(46,196,182,0.2); border:1px solid rgba(46,196,182,0.3); min-width:40px;">+</button>
        </div>
      </div>
    </div>
    <button class="btn" id="coordApply" style="width:100%; background:rgba(124,156,255,0.3);">적용</button>
    <button class="btn" id="coordCancel" style="width:100%; margin-top:6px; background:rgba(255,255,255,0.05);">취소</button>
  </div>

  <div style="margin-top:12px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px;">
    <div class="muted" style="margin-bottom:6px;">현재 세션: <span id="currentSession">Before</span></div>
    
    <!-- 주요 지표 (간략 표시) -->
    <div style="margin-bottom:8px; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">
      <div class="muted" style="margin-bottom:4px;">CVA: <span id="dispCva">—</span></div>
      <div class="muted" style="margin-bottom:4px;">TRUNK: <span id="dispPel">—</span></div>
      <div class="muted" style="margin-bottom:4px;">KNEE: <span id="dispKnee">—</span></div>
    </div>
    
    <!-- 전체 분석 항목 (16가지) -->
    <div id="allMetricsPanel" style="max-height:300px; overflow-y:auto; margin-bottom:8px;">
      <div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#7c9cff;">📊 전체 분석 항목</div>
      <div id="allMetricsList" style="font-size:11px; line-height:1.6;"></div>
    </div>
    
    <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.1);">
      <div style="font-size:14px; font-weight:600; margin-bottom:8px;">📊 체형 종합 점수</div>
      <div id="totalScore" style="font-size:32px; font-weight:800; margin-bottom:8px;">—</div>
      <div id="scoreReason" class="muted" style="font-size:11px; line-height:1.4; margin-bottom:8px;"></div>
      <div id="pdsScore" class="muted" style="font-size:12px; margin-top:6px;">PDS: <span id="pdsValue">—</span></div>
    </div>
  </div>

  <div id="aiCommentPanel" style="margin-top:12px; padding:12px; background:rgba(46,196,182,0.1); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#2ec4b6;">🤖 AI 체형 분석</div>
    <div id="aiComment" class="muted" style="font-size:12px; line-height:1.5;"></div>
    
    <!-- 개인별 체형 분석 설명 -->
    <div id="postureTypeDesc" style="margin-top:12px; padding:10px; background:rgba(255,255,255,0.1); border-radius:8px; border-left:3px solid #2ec4b6;">
      <div style="font-size:13px; font-weight:600; margin-bottom:6px; color:#2ec4b6;">📌 체형 유형 분석</div>
      <div id="postureTypeContent" style="font-size:11px; line-height:1.6; color:var(--muted);"></div>
    </div>
  </div>
  
  <!-- 16개 항목 상세 설명 -->
  <div id="metricsDescPanel" style="margin-top:12px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#7c9cff;">📋 분석 항목 설명</div>
    <div style="font-size:11px; color:#7c9cff; margin-bottom:8px; padding:4px 8px; background:rgba(124,156,255,0.2); border-radius:4px; display:inline-block;">측면 항목 (옆모습)</div>
    <div style="font-size:11px; color:#2ec4b6; margin-bottom:8px; padding:4px 8px; background:rgba(46,196,182,0.2); border-radius:4px; display:inline-block; margin-left:8px;">정면 항목 (앞모습)</div>
    <div id="metricsDescContent" style="max-height:400px; overflow-y:auto; font-size:11px; line-height:1.6;">
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">CVA (Craniovertebral Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 귀 뒤 유양돌기(Tragus)와 제7경추(C7) 사이의 각도<br>
          <strong>의미:</strong> 거북목 자세의 정도를 평가하는 가장 중요한 지표입니다. 각도가 작을수록 머리가 앞으로 나온 상태입니다.<br>
          <strong>정상 범위:</strong> ≥50° (각도가 클수록 좋음)<br>
          <strong>임상적 의미:</strong> CVA &lt; 50°는 전방두부자세(FHP)를 의미하며, 경추 근육 긴장, 두통, 목 통증의 원인이 됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">HPD (Head Protrusion Distance)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 귀(Tragus)와 어깨(Acromion) 사이의 수평 거리<br>
          <strong>의미:</strong> 머리가 몸통에서 얼마나 앞으로 돌출되어 있는지를 cm 단위로 측정합니다.<br>
          <strong>정상 범위:</strong> ≤2cm<br>
          <strong>임상적 의미:</strong> 2cm 초과 시 경추 부담 증가, 상부 승모근 과긴장, 목-어깨 통증 유발 가능성이 높습니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">NIA (Neck Inclination Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 어깨에서 귀로 향하는 선과 수평선 사이의 각도<br>
          <strong>의미:</strong> 목의 전방 기울기 정도를 나타냅니다. CVA와 함께 거북목을 평가합니다.<br>
          <strong>정상 범위:</strong> 0-20°<br>
          <strong>임상적 의미:</strong> 20° 초과 시 경추 신전근 약화 및 굴곡근 긴장이 의심됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">TIA (Trunk Inclination Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 어깨(Acromion)와 골반(Hip)을 연결한 선과 수직선 사이의 각도<br>
          <strong>의미:</strong> 몸통의 앞뒤 기울기를 평가하여 전체적인 체간 정렬을 확인합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 10° 초과 시 요추 과전만 또는 평평한 등(Flat Back) 위험이 있습니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">SAA (Scapular Alignment Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 어깨(Acromion)와 골반 후면(PSIS)을 연결한 선과 수평선 사이의 각도<br>
          <strong>의미:</strong> 어깨뼈의 정렬 상태와 상부 체간의 자세를 평가합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 이상 시 견갑골 날개뼈(Winging) 또는 어깨 전방 말림이 의심됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">PTA (Pelvic Tilt Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 후상장골극(PSIS)과 전상장골극(ASIS)을 연결한 선과 수평선 사이의 각도<br>
          <strong>의미:</strong> 골반의 전방 또는 후방 기울기를 평가하는 핵심 지표입니다.<br>
          <strong>정상 범위:</strong> 0-15° (약간의 전방 경사는 정상)<br>
          <strong>임상적 의미:</strong> &gt;15°는 골반 전방 경사(요추 과전만), &lt;0°는 골반 후방 경사(요추 평평)를 의미합니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">KA (Knee Alignment Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 고관절(Hip)-무릎(Knee)-발목(Ankle) 세 점이 이루는 각도<br>
          <strong>의미:</strong> 무릎 관절의 신전(펴짐) 정도를 평가합니다.<br>
          <strong>정상 범위:</strong> 175-185°<br>
          <strong>임상적 의미:</strong> &lt;175°는 무릎 과굴곡(슬개건 부담), &gt;185°는 무릎 과신전(관절 불안정성)을 나타냅니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">Tibial Angle (경골 경사각)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 무릎(Knee)과 발목(Ankle)을 연결한 선과 수직선 사이의 각도<br>
          <strong>의미:</strong> 정강이(경골)의 앞뒤 기울기를 측정합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 과도한 경사는 발목 불안정성 및 종아리 근육 불균형을 유발할 수 있습니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">Q-Angle (대퇴사두근 각도)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> ASIS-슬개골(Patella)-경골조면(Tibial Tuberosity) 세 점이 이루는 각도<br>
          <strong>의미:</strong> 대퇴사두근의 당김 방향을 평가하여 무릎 정렬을 확인합니다.<br>
          <strong>정상 범위:</strong> 남성 10-15°, 여성 15-20°<br>
          <strong>임상적 의미:</strong> &gt;20°는 슬개골 외측 전위 및 슬개대퇴 통증 증후군의 위험 요인입니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">Knee Deviation (무릎 높이 차)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 좌우 무릎의 높이 차이를 각도로 환산<br>
          <strong>의미:</strong> 양쪽 무릎의 수평 정렬을 평가하여 골반 기울기를 간접적으로 확인합니다.<br>
          <strong>정상 범위:</strong> 0-3°<br>
          <strong>임상적 의미:</strong> 3° 초과 시 골반 회전(Pelvic Rotation) 또는 척추 측만증이 의심됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">LLD (Leg Length Discrepancy)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 좌우 다리 길이(Hip-Ankle) 차이를 cm 단위로 측정<br>
          <strong>의미:</strong> 기능적 또는 구조적 다리 길이 차이를 평가합니다.<br>
          <strong>정상 범위:</strong> ≤1cm<br>
          <strong>임상적 의미:</strong> 1cm 초과 시 골반 비대칭, 척추 측만, 보행 이상이 발생할 수 있으며 보상 자세로 인한 만성 통증의 원인이 됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">GSB (Global Sagittal Balance)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 귀(Tragus)와 발목(Ankle)의 수평 거리<br>
          <strong>의미:</strong> 전신의 시상면(옆에서 본) 균형을 종합적으로 평가하는 지표입니다.<br>
          <strong>정상 범위:</strong> ≤2cm<br>
          <strong>임상적 의미:</strong> 2cm 초과 시 중력 중심선 이탈로 인한 전체 근골격계 부담 증가 및 에너지 소모가 증가합니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">BVA (Body Vertical Alignment)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 머리-어깨-골반-무릎-발목 등 주요 관절의 수직선 정렬 범위<br>
          <strong>의미:</strong> 모든 주요 관절이 하나의 수직선상에 정렬되어 있는지 평가합니다.<br>
          <strong>정상 범위:</strong> ≤2cm (최대 편차)<br>
          <strong>임상적 의미:</strong> 불량한 수직 정렬은 특정 관절 및 근육에 과부하를 일으켜 만성 통증과 퇴행성 변화를 가속화합니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">SCI (Spinal Curvature Index)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 척추의 경추 및 요추 전만(앞으로 굽음) 곡선의 비율<br>
          <strong>의미:</strong> 척추의 자연스러운 S자 곡선이 적절하게 유지되는지 평가합니다.<br>
          <strong>정상 범위:</strong> 0.15-0.35<br>
          <strong>임상적 의미:</strong> &lt;0.15는 평평한 척추(충격 흡수↓), &gt;0.35는 과도한 만곡(디스크 압력↑)을 의미합니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">HPA (Head–Pelvis Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 머리(Tragus)와 골반(PSIS)을 연결한 선과 수직선 사이의 각도<br>
          <strong>의미:</strong> 머리와 골반의 상대적 위치 관계를 통해 전신 자세를 종합 평가합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 이상 각도는 머리-골반 분절 간 협응 부족을 나타내며, 전신 자세 불균형의 지표입니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">PDS (Postural Deviation Score)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 위 15개 항목의 비정상 정도를 점수화하여 합산<br>
          <strong>의미:</strong> 전체적인 자세 불균형의 정도를 하나의 숫자로 요약한 종합 지표입니다.<br>
          <strong>정상 범위:</strong> 0-10점<br>
          <strong>분류:</strong> 0-10 (정상), 11-20 (경미), 21-30 (중등도), 31+ (심각)<br>
          <strong>임상적 의미:</strong> 점수가 높을수록 다양한 자세 문제가 복합적으로 나타나며, 전문적인 교정 치료가 필요합니다.
        </div>
      </details>
      
      <!-- 정면 항목 (앞모습) - 색상: #2ec4b6 -->
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">STA (Shoulder Tilt Angle) - 어깨 좌우 기울기</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(L_acromion, R_acromion), horizontal)<br>
          <strong>측정 방법:</strong> ① 카메라를 가슴 중앙 높이에 고정하고 피험자는 정면으로 선 자세 유지. ② 좌·우 Acromion의 좌표를 인식. ③ Δy를 각도로 변환(atan(Δy / Δx)).<br>
          <strong>정상 범위:</strong> ≤ 3°<br>
          <strong>해석:</strong> ↑ → 어깨 좌우 불균형, 승모근·능형근 긴장 차이 가능성.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">POA (Pelvic Obliquity Angle) - 골반 좌우 기울기</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(L_ASIS, R_ASIS), horizontal)<br>
          <strong>측정 방법:</strong> ① 카메라를 골반 높이에 맞추고 정면에서 촬영. ② 좌·우 ASIS를 인식하고 Δy 계산. ③ 각도 계산: POA = atan(Δy / Δx).<br>
          <strong>정상 범위:</strong> ≤ 3°<br>
          <strong>해석:</strong> ↑ → 골반 좌우 비대칭 / 하지 길이 차 / 요추 측만 가능성.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">LLD (Leg Length Discrepancy) - 하지 길이 차</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> |distance(L_ASIS, L_ankle) - distance(R_ASIS, R_ankle)|<br>
          <strong>측정 방법:</strong> ① 전신이 보이도록 정면 촬영. ② 좌·우 ASIS 및 발목(Ankle) 좌표 인식. ③ 거리(cm) 환산(pxPerCm 보정).<br>
          <strong>정상 범위:</strong> ≤ 1 cm<br>
          <strong>해석:</strong> ↑ → 구조적 또는 기능적 하지 길이 차 존재.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">TD (Trunk Deviation) - 체간 편위</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> horizontal deviation(C7, midline(L_ankle, R_ankle))<br>
          <strong>측정 방법:</strong> ① 카메라를 정면, 양 발목이 수평에 오도록 촬영. ② L/R Ankle 좌표로 중간선(midpoint) 계산. ③ C7의 수평 거리 편차 계산.<br>
          <strong>정상 범위:</strong> ± 2°<br>
          <strong>해석:</strong> ↑ → 체간이 좌우로 기울어짐 / 체중 중심 불균형.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">HTA (Head Tilt Angle) - 머리 좌우 기울기</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(L_tragus, R_tragus), horizontal)<br>
          <strong>측정 방법:</strong> ① 정면에서 Tragus 좌우가 명확히 보이도록 촬영. ② 두 점의 y좌표 차이 계산 → 각도로 변환.<br>
          <strong>정상 범위:</strong> ≤ 3°<br>
          <strong>해석:</strong> ↑ → 경부 측굴 또는 측만성 긴장 패턴.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">SPP (Shoulder–Pelvis Parallelism) - 어깨-골반 평행도</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle_diff(line(L_acromion, R_acromion), line(L_ASIS, R_ASIS))<br>
          <strong>측정 방법:</strong> ① 정면 촬영 시 L/R 어깨와 L/R ASIS가 모두 보여야 함. ② 두 선의 각도 차 계산.<br>
          <strong>정상 범위:</strong> 0–3°<br>
          <strong>해석:</strong> ↑ → 체간 회전 / 골반 비틀림 / 척추 회전성 불균형.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">KAS (Knee Alignment Symmetry) - 무릎 정렬 대칭성</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle_diff(line(L_knee, L_ankle), line(R_knee, R_ankle))<br>
          <strong>측정 방법:</strong> ① 정면에서 무릎과 발목 모두 인식. ② 각 무릎–발목 수직선의 각도 비교.<br>
          <strong>정상 범위:</strong> 대칭(±2° 이내)<br>
          <strong>해석:</strong> ↑ → 한쪽 내반/외반 또는 하지 회전 패턴.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">LLAS (Lower Limb Axis Symmetry) - 하지 축 대칭성</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle_diff(line(L_ASIS, L_ankle), line(R_ASIS, R_ankle))<br>
          <strong>측정 방법:</strong> ① 정면에서 하지 전체 촬영. ② 각 하지축 라인 각도 비교.<br>
          <strong>정상 범위:</strong> ±2°<br>
          <strong>해석:</strong> ↑ → 한쪽 회내·회외 또는 하지 회전성 불균형.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">FBA (Foot Base Angle) - 발 정렬 각도</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(ankle, toe), body midline)<br>
          <strong>측정 방법:</strong> ① 피험자는 발끝까지 보이게 정면으로 선다. ② 발 중심선(ankle–toe)과 몸 중심선 간 각도 계산.<br>
          <strong>정상 범위:</strong> 0–10°<br>
          <strong>해석:</strong> ↑ → 과도한 외회전(회외) / ↓ → 회내 경향.
        </div>
      </details>
    </div>
  </div>
  
  <!-- 실시간 분석 결과 패널 -->
  <div id="liveAnalysisPanel" style="margin-top:12px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#7c9cff;">📊 실시간 AI 분석 결과</div>
    <div id="livePDS" style="font-size:16px; font-weight:700; margin-bottom:8px; color:#7c9cff;">PDS: —</div>
    <div id="livePatterns" style="font-size:12px; line-height:1.6;"></div>
  </div>

  <div id="musclePanel" style="margin-top:12px; padding:12px; background:rgba(255,184,108,0.1); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#ffb86c;">💪 근육 상태 분석</div>
    <div id="muscleTight" style="margin-bottom:8px;">
      <div class="muted" style="font-size:11px; margin-bottom:4px;">🔴 긴장된 근육:</div>
      <div id="muscleTightList" style="font-size:12px; color:#ff6b6b; line-height:1.5;"></div>
    </div>
    <div id="muscleWeak" style="margin-bottom:8px;">
      <div class="muted" style="font-size:11px; margin-bottom:4px;">🔵 약화된 근육:</div>
      <div id="muscleWeakList" style="font-size:12px; color:#7c9cff; line-height:1.5;"></div>
    </div>
    <div id="muscleDetail" style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
      <div class="muted" style="font-size:11px; margin-bottom:4px;">📋 상세 분석:</div>
      <div id="muscleDetailList" style="font-size:11px; line-height:1.6; color:var(--ink);"></div>
    </div>
  </div>

  <div id="exercisePanel" style="margin-top:12px; padding:12px; background:rgba(46,196,182,0.15); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#2ec4b6;">🏋️ 추천 운동</div>
    <div id="exerciseList" style="font-size:12px; line-height:1.6;"></div>
  </div>

  <div id="pilatesPanel" style="margin-top:12px; padding:12px; background:rgba(156,136,255,0.15); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#9c88ff;">🧘 필라테스 세션 추천</div>
    <div id="pilatesList" style="font-size:12px; line-height:1.6;"></div>
  </div>


  <div style="margin-top:12px; max-height:400px; overflow-y:auto;">
    <table class="tbl">
      <thead><tr><th>항목</th><th>Before</th><th>After</th><th>변화</th><th>정상</th></tr></thead>
      <tbody>
        <tr><td>CVA</td><td id="cmpCvaB">—</td><td id="cmpCvaA">—</td><td id="cmpCvaD">—</td><td>≥50°</td></tr>
        <tr><td>HPD</td><td id="cmpHpdB">—</td><td id="cmpHpdA">—</td><td id="cmpHpdD">—</td><td>≤2cm</td></tr>
        <tr><td>NIA</td><td id="cmpNiaB">—</td><td id="cmpNiaA">—</td><td id="cmpNiaD">—</td><td>0-20°</td></tr>
        <tr><td>TIA</td><td id="cmpTiaB">—</td><td id="cmpTiaA">—</td><td id="cmpTiaD">—</td><td>0-10°</td></tr>
        <tr><td>SAA</td><td id="cmpSaaB">—</td><td id="cmpSaaA">—</td><td id="cmpSaaD">—</td><td>0-10°</td></tr>
        <tr><td>PTA</td><td id="cmpPtaB">—</td><td id="cmpPtaA">—</td><td id="cmpPtaD">—</td><td>0-15°</td></tr>
        <tr><td>KA</td><td id="cmpKaB">—</td><td id="cmpKaA">—</td><td id="cmpKaD">—</td><td>175-185°</td></tr>
        <tr><td>Tibial</td><td id="cmpTibialB">—</td><td id="cmpTibialA">—</td><td id="cmpTibialD">—</td><td>0-10°</td></tr>
        <tr><td>Q-Angle</td><td id="cmpQangleB">—</td><td id="cmpQangleA">—</td><td id="cmpQangleD">—</td><td>10-20°</td></tr>
        <tr><td>Knee Dev</td><td id="cmpKneedevB">—</td><td id="cmpKneedevA">—</td><td id="cmpKneedevD">—</td><td>0-3°</td></tr>
        <tr><td>LLD</td><td id="cmpLldB">—</td><td id="cmpLldA">—</td><td id="cmpLldD">—</td><td>≤1cm</td></tr>
        <tr><td>GSB</td><td id="cmpGsbB">—</td><td id="cmpGsbA">—</td><td id="cmpGsbD">—</td><td>≤2cm</td></tr>
        <tr><td>BVA</td><td id="cmpBvaB">—</td><td id="cmpBvaA">—</td><td id="cmpBvaD">—</td><td>≤2cm</td></tr>
        <tr><td>SCI</td><td id="cmpSciB">—</td><td id="cmpSciA">—</td><td id="cmpSciD">—</td><td>0.15-0.35</td></tr>
        <tr><td>HPA</td><td id="cmpHpaB">—</td><td id="cmpHpaA">—</td><td id="cmpHpaD">—</td><td>0-10°</td></tr>
        <tr><td>PDS</td><td id="cmpPdsB">—</td><td id="cmpPdsA">—</td><td id="cmpPdsD">—</td><td>0-10</td></tr>
        <tr style="background:#f0f0f0; font-weight:600;"><td>체형 점수</td><td id="cmpScoreB">—</td><td id="cmpScoreA">—</td><td id="cmpScoreD">—</td><td>0–100</td></tr>
      </tbody>
    </table>
  </div>
</aside>
<main class="panel canvasWrap" style="order: 2;">
  <canvas id="cv" width="1600" height="1000"></canvas>
</main>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js"></script>
<script>
const { jsPDF } = window.jspdf;
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");
let DPR = window.devicePixelRatio || 1;
let dragKey = null;
let editMode = false;
let selectedPoint = null;
let originalCanvasSize = { width: 0, height: 0, styleWidth: 0, styleHeight: 0 };
let currentZoom = 1;
let isScrolling = false;
let scrollStartX = 0;
let scrollStartY = 0;
let touchStartTime = 0;
let scrollDistance = 0; // 스크롤 시작 후 이동 거리
let longPressTimer = null;
let longPressDetected = false;
let longPressNearPoint = null; // long press가 감지된 점

// 옆모습 키포인트
// 측면 키포인트 (Flutter와 1:1 매칭: 소문자 통일)
const keypointsSide = [
  {key:'tragus', color:'#7c9cff'},
  {key:'c7', color:'#7c9cff'},
  {key:'acromion', color:'#7c9cff'},
  {key:'hip', color:'#7c9cff'},
  {key:'knee', color:'#7c9cff'},
  {key:'ankle', color:'#7c9cff'},
  {key:'asis', color:'#ffb86c'},
  {key:'psis', color:'#ffb86c'},
];

// 정면 키포인트 (Flutter와 1:1 매칭)
const keypointsFront = [
  {key:'c7', color:'#7c9cff'},
  {key:'L_acromion', color:'#7c9cff'},
  {key:'R_acromion', color:'#7c9cff'},
  {key:'L_asis', color:'#ffb86c'},
  {key:'R_asis', color:'#ffb86c'},
  {key:'L_ankle', color:'#7c9cff'},
  {key:'R_ankle', color:'#7c9cff'},
  {key:'L_knee', color:'#7c9cff'},
  {key:'R_knee', color:'#7c9cff'},
];

// 기존 호환성을 위해 keypoints 변수 유지 (getKeypoints 함수로 동적 반환)
let keypoints = keypointsSide; // 기본값

const sessions = {
  Before: { 
    imgSide:null, 
    imgFront:null, 
    sidePoints:new Map(),  // 측면 키포인트 (tragus, c7, acromion, asis, psis, hip, knee, ankle)
    frontPoints:new Map(), // 정면 키포인트 (L_acromion, R_acromion, L_asis, R_asis, L_knee, R_knee, L_ankle, R_ankle)
    metrics:{}, 
    score:null, 
    analysis:null 
  },
  After: { 
    imgSide:null, 
    imgFront:null, 
    sidePoints:new Map(),
    frontPoints:new Map(),
    metrics:{}, 
    score:null, 
    analysis:null 
  }
};
let cur = "Before";

const clamp = (v,min,max) => Math.min(max,Math.max(min,v));
const rad2deg = r => r * 180 / Math.PI;
const deg2rad = d => d * Math.PI / 180;
const angleBetween = (a,b) => Math.atan2(b.y - a.y, b.x - a.x);

// 두 점 사이 각도(수평 기준, p1->p2), 화면 y-down 좌표계 가정
function angleP1P2(p1, p2) {
  return rad2deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));
}

// 두 점 사이 거리(픽셀)
function dist(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx*dx + dy*dy);
}

// 외적/내적 기반 각도(pA-vertex-pB)
function angleAt(v, a, b) {
  const ax = a.x - v.x;
  const ay = a.y - v.y;
  const bx = b.x - v.x;
  const by = b.y - v.y;
  const dot = ax*bx + ay*by;
  const na = Math.sqrt(ax*ax + ay*ay);
  const nb = Math.sqrt(bx*bx + by*by);
  if (na === 0 || nb === 0) return NaN;
  return rad2deg(Math.acos(Math.max(-1, Math.min(1, dot / (na*nb)))));
}

// 수직선(90°)과 라인 각도 차이 절대값
function angleToVertical(p1, p2) {
  const a = angleP1P2(p1, p2);
  // 수직선(90도)에서의 편차 계산
  // 175.4도 → 180 - 175.4 = 4.6도 (수직선에서 4.6도 벗어남)
  // 85.4도 → 90 - 85.4 = 4.6도
  const absA = Math.abs(a);
  if (absA > 90) {
    // 90도 이상이면 180도에서 빼서 계산
    return Math.abs(180 - absA);
  } else {
    // 90도 미만이면 90도에서 빼서 계산
    return Math.abs(90 - absA);
  }
}

// 수평선과 라인 각도 절대값
function angleToHorizontal(p1, p2) {
  return Math.abs(angleP1P2(p1, p2));
}

// 범위 분류 함수 (normal, mild, moderate, severe)
function classifyRange({
  v,
  nMin = null, nMax = null,
  mildMin = null, mildMax = null,
  modMin = null, modMax = null,
  sevMin = null, sevMax = null,
  higherIsWorse = false
}) {
  function inRange(x, lo, hi) {
    return (lo == null || x >= lo) && (hi == null || x <= hi);
  }
  
  if (inRange(v, nMin, nMax)) return "normal";
  if (inRange(v, mildMin, mildMax)) return "mild";
  if (inRange(v, modMin, modMax)) return "moderate";
  if (inRange(v, sevMin, sevMax)) return "severe";
  
  // 방향성 힌트
  return higherIsWorse
    ? (v > (nMax ?? v) ? "worse_high" : "worse_low")
    : (v < (nMin ?? v) ? "worse_low" : "worse_high");
}

// px→cm 변환
function pxToCm(px, scalePxPerCm = 50) {
  return px / scalePxPerCm;
}

// ✅ 캘리브레이션 유틸: 두 점 간 거리로 pxPerCm 계산
function calibratePxPerCm(pointA, pointB, realLengthCm) {
  if (realLengthCm <= 0) {
    throw new Error("realLengthCm must be > 0");
  }
  const distPx = dist(pointA, pointB);
  return distPx / realLengthCm;
}

// ✅ 측면 자세 분석 (전체 지표 포함)
function analyzeFullPosture(points, pxPerCm = 50.0) {
  function p(k) {
    const v = points[k];
    if (!v || v.x == null || v.y == null) return null;
    return { x: Number(v.x), y: Number(v.y) };
  }
  
  const result = {};
  
  // Flutter 1:1 매칭 키 (소문자 우선, 기존 대문자는 fallback)
  const tragus = p("tragus") || p("Tragus");
  const C7 = p("c7") || p("C7");
  const acromion = p("acromion") || p("Shoulder") || p("Acromion");
  const ASIS = p("asis") || p("ASIS");
  const PSIS = p("psis") || p("PSIS");
  const hip = p("hip") || p("Hip");
  const knee = p("knee") || p("Knee");
  const ankle = p("ankle") || p("Ankle");
  
  // 1️⃣ CVA (Craniovertebral Angle): 수평선에서의 각도
  if (tragus && C7) {
    const rawAngle = angleToHorizontal(tragus, C7);
    // CVA는 angleToHorizontal의 결과를 그대로 사용 (90도 → 정상, 0도 → 거북목)
    const cva = rawAngle;
    
    result.CVA = {
      value: cva,
      status: classifyRange({
        v: cva,
        nMin: 50, nMax: 90,
        mildMin: 45, mildMax: 49,
        modMin: 40, modMax: 44,
        sevMin: null, sevMax: 40,
        higherIsWorse: false
      }),
      unit: "°",
      desc: "Craniovertebral Angle (거북목 평가)"
    };
    // 하위 호환성
    result.CVA.value_deg = cva;
    result.CVA.meaning = result.CVA.desc;
  }
  
  // 2️⃣ HPD (Head Protrusion Distance): tragus와 acromion 거리
  if (tragus && acromion) {
    const hpd = pxToCm(dist(tragus, acromion), pxPerCm);
    result.HPD = {
      value: hpd,
      status: classifyRange({
        v: hpd,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 4,
        modMin: 4, modMax: 6,
        sevMin: 6, sevMax: null,
        higherIsWorse: true
      }),
      unit: "cm",
      desc: "Head Protrusion Distance (머리 돌출)"
    };
    // 하위 호환성
    result.HPD.value_cm = hpd;
    result.HPD.meaning = result.HPD.desc;
  }
  
  // 3️⃣ NIA (Neck Inclination Angle): 목의 기울기 (90도 기준)
  if (tragus && acromion) {
    const rawAngle = angleToHorizontal(acromion, tragus);
    // NIA는 90도에서 빼서 계산 (수평 = 0도, 90도 각도 = 0도 NIA, 110도 각도 = 20도 NIA)
    const nia = Math.abs(90 - rawAngle);
    result.NIA = {
      value: nia,
      status: classifyRange({
        v: nia,
        nMin: 0, nMax: 20,
        mildMin: 21, mildMax: 25,
        modMin: 26, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Neck Inclination Angle"
    };
    // 하위 호환성
    result.NIA.value_deg = nia;
    result.NIA.meaning = result.NIA.desc;
  }
  
  // 4️⃣ TIA (Trunk Inclination Angle): acromion–hip와 수직선
  if (acromion && hip) {
    const tia = angleToVertical(acromion, hip);
    result.TIA = {
      value: tia,
      status: classifyRange({
        v: tia,
        nMin: 0, nMax: 5,
        mildMin: 5, mildMax: 10,
        modMin: 10, modMax: 15,
        sevMin: 15, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Trunk Inclination Angle"
    };
    // 하위 호환성
    result.TIA.value_deg = tia;
    result.TIA.meaning = result.TIA.desc;
  }
  
  // 5️⃣ SAA (Scapular Alignment Angle): acromion–PSIS와 수평선
  if (acromion && PSIS) {
    const saa = angleToHorizontal(acromion, PSIS);
    result.SAA = {
      value: saa,
      status: classifyRange({
        v: saa,
        nMin: 0, nMax: 10,
        mildMin: 10, mildMax: 15,
        modMin: 15, modMax: 20,
        sevMin: 20, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Scapular Alignment Angle"
    };
    // 하위 호환성
    result.SAA.value_deg = saa;
    result.SAA.meaning = result.SAA.desc;
  }
  
  // 6️⃣ PTA (Pelvic Tilt Angle): PSIS–ASIS와 수평선 (Dart: angleToHorizontal(psis, asis))
  if (ASIS && PSIS) {
    const pta = angleToHorizontal(PSIS, ASIS);
    result.PTA = {
      value: pta,
      status: classifyRange({
        v: pta,
        nMin: 5, nMax: 15,
        mildMin: 0, mildMax: 4,
        modMin: 16, modMax: 20,
        sevMin: null, sevMax: null,
        higherIsWorse: false
      }),
      unit: "°",
      desc: "Pelvic Tilt Angle"
    };
    // 하위 호환성
    result.PTA.value_deg = pta;
    result.PTA.meaning = result.PTA.desc;
  }
  
  // 7️⃣ KA (Knee Alignment Angle): hip–knee–ankle 세 점 각도
  if (hip && knee && ankle) {
    const ka = angleAt(knee, hip, ankle);
    result.KA = {
      value: ka,
      status: classifyRange({
        v: ka,
        nMin: 175, nMax: 180,
        mildMin: 172, mildMax: 174,
        modMin: 168, modMax: 171,
        sevMin: null, sevMax: null,
        higherIsWorse: false
      }),
      unit: "°",
      desc: "Knee Alignment Angle"
    };
    // 하위 호환성
    result.KA.value_deg = ka;
    result.KA.meaning = result.KA.desc;
  }
  
  // 8️⃣ Tibial_Angle (Tibial Inclination): knee–ankle와 수직선
  if (knee && ankle) {
    const tia2 = angleToVertical(knee, ankle);
    result.Tibial_Angle = {
      value: tia2,
      status: classifyRange({
        v: tia2,
        nMin: 0, nMax: 5,
        mildMin: 5, mildMax: 8,
        modMin: 8, modMax: 12,
        sevMin: 12, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Tibial Inclination"
    };
    // 하위 호환성
    result.Tibial_Angle.value_deg = tia2;
    result.Tibial_Angle.meaning = result.Tibial_Angle.desc;
    result.Tibial_Inclination = result.Tibial_Angle;
  }
  
  // 9️⃣ GSB (Global Sagittal Balance): tragus–ankle x좌표 차이
  if (tragus && ankle) {
    const gsbPx = Math.abs(tragus.x - ankle.x);
    const gsb = pxToCm(gsbPx, pxPerCm);
    result.GSB = {
      value: gsb,
      status: classifyRange({
        v: gsb,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 4,
        modMin: 4, modMax: 6,
        sevMin: 6, sevMax: null,
        higherIsWorse: true
      }),
      unit: "cm",
      desc: "Global Sagittal Balance"
    };
    // 하위 호환성
    result.GSB.value_cm = gsb;
    result.GSB.meaning = result.GSB.desc;
  }
  
  // 1️⃣0️⃣ BVA (Body Vertical Alignment): 범위 기반
  if (tragus && C7 && acromion && hip && knee && ankle) {
    const verticals = [tragus, C7, acromion, hip, knee, ankle];
    const dxs = verticals.map(p => p.x);
    const minX = Math.min(...dxs);
    const maxX = Math.max(...dxs);
    const range = pxToCm(Math.abs(maxX - minX), pxPerCm);
    
    result.BVA = {
      value: range,
      status: range <= 2 ? "normal" : range <= 4 ? "mild" : "moderate",
      unit: "cm",
      desc: "Body Vertical Alignment"
    };
    // 하위 호환성
    result.BVA.value_cm = range;
    result.BVA.meaning = result.BVA.desc;
  }
  
  // 1️⃣1️⃣ SCI (Spinal Curvature Index): C7–PSIS–ankle 곡률 비율
  if (C7 && PSIS && ankle) {
    const total = dist(C7, ankle);
    const mid = dist(C7, PSIS) + dist(PSIS, ankle);
    const sci = total > 0 ? mid / total : 1.0;
    result.SCI = {
      value: sci,
      status: sci >= 0.95 && sci <= 1.05 ? "neutral" : sci > 1.1 ? "kyphotic" : "flat",
      unit: "ratio",
      desc: "Spinal Curvature Index"
    };
    // 하위 호환성
    result.SCI.meaning = result.SCI.desc;
  }
  
  // 1️⃣2️⃣ HPA (Head–Pelvis Angle): tragus–PSIS와 수직선
  if (tragus && PSIS) {
    const hpa = angleToVertical(tragus, PSIS);
    result.HPA = {
      value: hpa,
      status: classifyRange({
        v: hpa,
        nMin: 0, nMax: 5,
        mildMin: 5, mildMax: 10,
        modMin: 10, modMax: 15,
        sevMin: 15, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Head–Pelvis Angle"
    };
    // 하위 호환성
    result.HPA.value_deg = hpa;
    result.HPA.meaning = result.HPA.desc;
  }
  
  // 1️⃣3️⃣ Q-Angle (슬개정렬): ASIS–patella–tibial_tub 각도
  const patella = p("patella") || p("Patella");
  const tibialTub = p("tibial_tub") || p("Tibial_Tub");
  if (ASIS && patella && tibialTub) {
    const qAngle = angleAt(patella, ASIS, tibialTub);
    result.Q_Angle = {
      value: qAngle,
      status: (qAngle >= 10 && qAngle <= 20) ? "normal" : "abnormal",
      unit: "°",
      desc: "Q-Angle (슬개정렬)"
    };
    // 하위 호환성
    result.Q_Angle.value_deg = qAngle;
    result.Q_Angle.meaning = result.Q_Angle.desc;
  }
  
  // 1️⃣4️⃣ Knee_Deviation (무릎 높이 차이): L_knee와 R_knee 수평선 각도
  const L_knee = p("L_knee") || p("L_Knee");
  const R_knee = p("R_knee") || p("R_Knee");
  if (L_knee && R_knee) {
    const kd = angleToHorizontal(L_knee, R_knee);
    result.Knee_Deviation = {
      value: kd,
      status: classifyRange({
        v: kd,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Knee Height Difference"
    };
    // 하위 호환성
    result.Knee_Deviation.value_deg = kd;
    result.Knee_Deviation.meaning = result.Knee_Deviation.desc;
  }
  
  // 1️⃣5️⃣ LLD (Leg Length Discrepancy): 좌우 다리 길이 차이
  const L_asis = p("L_asis") || p("L_ASIS");
  const R_asis = p("R_asis") || p("R_ASIS");
  const L_ankle = p("L_ankle") || p("L_Ankle");
  const R_ankle = p("R_ankle") || p("R_Ankle");
  if (L_asis && L_ankle && R_asis && R_ankle) {
    const lLen = dist(L_asis, L_ankle);
    const rLen = dist(R_asis, R_ankle);
    const lld = pxToCm(Math.abs(lLen - rLen), pxPerCm);
    result.LLD = {
      value: lld,
      status: lld <= 1 ? "normal" : lld <= 2 ? "mild" : "severe",
      unit: "cm",
      desc: "Leg Length Discrepancy"
    };
    // 하위 호환성
    result.LLD.value_cm = lld;
    result.LLD.meaning = result.LLD.desc;
  }
  
  // 1️⃣6️⃣ PDS (Postural Deviation Score): 모든 지표 합산지수
  let pdsScore = 0;
  const statusMap = { "normal": 0, "mild": 1, "moderate": 2, "severe": 3, "abnormal": 2, "neutral": 0, "kyphotic": 2, "flat": 2 };
  Object.keys(result).forEach(key => {
    if (key !== "PDS" && result[key] && result[key].status) {
      pdsScore += statusMap[result[key].status] || 0;
    }
  });
  
  result.PDS = {
    value: pdsScore,
    status: pdsScore <= 10 ? "normal" : pdsScore <= 15 ? "mild" : "moderate",
    unit: "score",
    desc: "Postural Deviation Score (0–10: normal, 10↑: 불균형)"
  };
  // 하위 호환성
  result.PDS.meaning = result.PDS.desc;
  
  return result;
}

// ✅ 정면 자세 분석
function analyzeFrontPosture(points, pxPerCm = 50.0) {
  // 안전 접근 헬퍼
  function p(k) {
    const v = points[k];
    if (!v || v.x == null || v.y == null) return null;
    return { x: Number(v.x), y: Number(v.y) };
  }
  
  const result = {};
  
  const L_acr = p("L_acromion") || p("L_Shoulder");
  const R_acr = p("R_acromion") || p("R_Shoulder");
  const L_asis = p("L_asis") || p("L_ASIS");
  const R_asis = p("R_asis") || p("R_ASIS");
  // Flutter 1:1 매칭 키 (소문자 우선)
  const C7 = p("c7") || p("C7");
  const L_ankle = p("L_ankle");
  const R_ankle = p("R_ankle");
  
  // 스펙 기반: 정면 지표 추가 (TypeScript spec v1.0)
  
  // 1️⃣ STA_F (Shoulder Tilt Angle): 어깨 좌우 기울기
  if (L_acr && R_acr) {
    const verticalDiff = Math.abs(L_acr.y - R_acr.y);
    const horizontalDist = Math.abs(L_acr.x - R_acr.x);
    const sta = horizontalDist > 0 ? rad2deg(Math.atan2(verticalDiff, horizontalDist)) : 0;
    
    result.STA_F = {
      value: sta,
      status: classifyRange({
        v: sta,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Shoulder Tilt Angle (어깨 좌우 기울기)"
    };
    result.STA_F.value_deg = sta;
    result.STA_F.meaning = result.STA_F.desc;
    
    // 하위 호환성
    result.Shoulder_Tilt = result.STA_F;
  }
  
  // 2️⃣ POA_F (Pelvic Obliquity Angle): 골반 좌우 기울기
  if (L_asis && R_asis) {
    const verticalDiff = Math.abs(L_asis.y - R_asis.y);
    const horizontalDist = Math.abs(L_asis.x - R_asis.x);
    const poa = horizontalDist > 0 ? rad2deg(Math.atan2(verticalDiff, horizontalDist)) : 0;
    
    result.POA_F = {
      value: poa,
      status: classifyRange({
        v: poa,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Pelvic Obliquity Angle (골반 좌우 기울기)"
    };
    result.POA_F.value_deg = poa;
    result.POA_F.meaning = result.POA_F.desc;
    
    // 하위 호환성
    result.POA = result.POA_F;
    result.Pelvic_Obliquity = result.POA_F;
    
    // PRA (Pelvic Rotation): 좌우 ASIS 간 x좌표 차이 (스펙에는 없지만 유지)
    const pra = pxToCm(Math.abs(R_asis.x - L_asis.x), pxPerCm);
    result.PRA = {
      value: pra,
      value_cm: pra,
      status: pra <= 1 ? "normal" : pra <= 2 ? "mild" : pra <= 3 ? "moderate" : "severe",
      unit: "cm",
      meaning: "Pelvic Rotation (골반 좌우 비틀림)"
    };
  }
  
  // 3️⃣ LLD_F (Leg Length Discrepancy): 다리 길이 차이
  if (L_asis && L_ankle && R_asis && R_ankle) {
    const lLen = dist(L_asis, L_ankle);
    const rLen = dist(R_asis, R_ankle);
    const lld = pxToCm(Math.abs(lLen - rLen), pxPerCm);
    
    result.LLD_F = {
      value: lld,
      status: classifyRange({
        v: lld,
        nMin: 0, nMax: 1,
        mildMin: 1, mildMax: 2,
        modMin: 2, modMax: 3,
        sevMin: 3, sevMax: null,
        higherIsWorse: true
      }),
      unit: "cm",
      desc: "Leg Length Discrepancy (하지 길이 차)"
    };
    result.LLD_F.value_cm = lld;
    result.LLD_F.meaning = result.LLD_F.desc;
    
    // 하위 호환성
    result.LLD = result.LLD_F;
    if (L_ankle && R_ankle) {
      const diffPx = Math.abs(L_ankle.y - R_ankle.y);
      const diffCm = pxToCm(diffPx, pxPerCm);
      result.Leg_Length_Diff = {
        value_cm: diffCm,
        status: diffCm <= 1 ? "normal" : diffCm <= 2 ? "mild" : diffCm <= 3 ? "moderate" : "severe",
        meaning: "다리 길이 차이 (1cm 이하 정상)",
      };
    }
  }
  
  // 4️⃣ TD (Trunk Deviation): 체간 좌우 편위
  if (C7 && L_ankle && R_ankle) {
    // 중간선: 좌우 발목 중점
    const midlineX = (L_ankle.x + R_ankle.x) / 2;
    const midlineY = (L_ankle.y + R_ankle.y) / 2;
    
    // C7에서 중간선까지의 수평 거리
    const horizontalDeviation = C7.x - midlineX;
    const verticalDist = Math.abs(C7.y - midlineY);
    const td = verticalDist > 0 ? rad2deg(Math.atan2(Math.abs(horizontalDeviation), verticalDist)) : 0;
    
    result.TD = {
      value: td,
      status: classifyRange({
        v: td,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 5,
        modMin: 5, mildMax: 8,
        sevMin: 8, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Trunk Deviation (체간 좌우 편위)"
    };
    result.TD.value_deg = td;
    result.TD.meaning = result.TD.desc;
    
    // 하위 호환성
    if (L_asis && R_asis) {
      const pelvisMid = {
        x: (L_asis.x + R_asis.x) / 2,
        y: (L_asis.y + R_asis.y) / 2
      };
      const dx = C7.x - pelvisMid.x;
      const dy = C7.y - pelvisMid.y;
      const angle = rad2deg(Math.atan2(Math.abs(dx), Math.abs(dy)));
      result.Trunk_Lateral_Tilt = {
        value_deg: angle,
        status: angle <= 2 ? "normal" : angle <= 5 ? "mild" : angle <= 8 ? "moderate" : "severe",
        meaning: "체간의 좌우 기울기",
      };
    }
  }
  
  // 5️⃣ HTA (Head Tilt Angle): 머리 좌우 기울기 (정면에서는 tragus 좌우가 필요하지만, 측면만 있는 경우 추정)
  const L_tragus = p("L_tragus");
  const R_tragus = p("R_tragus");
  if (L_tragus && R_tragus) {
    const verticalDiff = Math.abs(L_tragus.y - R_tragus.y);
    const horizontalDist = Math.abs(L_tragus.x - R_tragus.x);
    const hta = horizontalDist > 0 ? rad2deg(Math.atan2(verticalDiff, horizontalDist)) : 0;
    
    result.HTA = {
      value: hta,
      status: classifyRange({
        v: hta,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Head Tilt Angle (머리 좌우 기울기)"
    };
    result.HTA.value_deg = hta;
    result.HTA.meaning = result.HTA.desc;
  }
  
  // 6️⃣ SPP (Shoulder–Pelvis Parallelism): 어깨-골반 평행도
  if (L_acr && R_acr && L_asis && R_asis) {
    // 어깨선 각도
    const shoulderDx = R_acr.x - L_acr.x;
    const shoulderDy = R_acr.y - L_acr.y;
    const shoulderAngle = rad2deg(Math.atan2(shoulderDy, shoulderDx));
    
    // 골반선 각도
    const pelvisDx = R_asis.x - L_asis.x;
    const pelvisDy = R_asis.y - L_asis.y;
    const pelvisAngle = rad2deg(Math.atan2(pelvisDy, pelvisDx));
    
    // 각도 차이
    let angleDiff = Math.abs(shoulderAngle - pelvisAngle);
    if (angleDiff > 90) angleDiff = 180 - angleDiff; // 0-90도 범위로 정규화
    
    result.SPP = {
      value: angleDiff,
      status: classifyRange({
        v: angleDiff,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Shoulder–Pelvis Parallelism (어깨-골반 평행도)"
    };
    result.SPP.value_deg = angleDiff;
    result.SPP.meaning = result.SPP.desc;
  }
  
  // 7️⃣ FBA (Foot Base Angle): 발 정렬 각도 (발목과 발가락 필요, 현재는 발목만 있으므로 추정 불가)
  // 발가락 좌표가 없으면 계산하지 않음
  const L_toe = p("L_toe");
  const R_toe = p("R_toe");
  if (L_ankle && L_toe && R_ankle && R_toe) {
    // 좌측 발 정렬
    const L_dx = L_toe.x - L_ankle.x;
    const L_dy = L_toe.y - L_ankle.y;
    const L_angle = rad2deg(Math.atan2(L_dy, L_dx));
    
    // 우측 발 정렬
    const R_dx = R_toe.x - R_ankle.x;
    const R_dy = R_toe.y - R_ankle.y;
    const R_angle = rad2deg(Math.atan2(R_dy, R_dx));
    
    // 평균 각도 (외회전 각도)
    const avgAngle = (L_angle + R_angle) / 2;
    const fba = Math.abs(avgAngle - 90); // 90도에서 벗어난 정도
    
    result.FBA = {
      value: fba,
      status: classifyRange({
        v: fba,
        nMin: 0, nMax: 10,
        mildMin: 10, mildMax: 20,
        modMin: 20, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Foot Base Angle (발 정렬 각도)"
    };
    result.FBA.value_deg = fba;
    result.FBA.meaning = result.FBA.desc;
  }
  
  
  // 6️⃣ Knee Deviation (Front): 좌우 knee 높이 차이
  const L_knee = p("L_knee") || p("L_Knee");
  const R_knee = p("R_knee") || p("R_Knee");
  if (L_knee && R_knee) {
    const diffPx = Math.abs(L_knee.y - R_knee.y);
    const diffCm = pxToCm(diffPx, pxPerCm);
    const angle = rad2deg(Math.atan2(diffPx, Math.abs(L_knee.x - R_knee.x) || 1));
    result.Knee_Deviation = {
      value_deg: angle,
      status: classifyRange({
        v: angle,
        nMin: null, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      meaning: "무릎 높이 차이 (≤3° 정상)"
    };
  }
  
  // 7️⃣ Q-Angle: ASIS → patella 중심 → tibial tuberosity
  // (정면에서만 측정 가능, 측면 분석에는 포함하지 않음)
  const L_patella = p("L_patella") || p("L_Patella") || L_knee;
  const R_patella = p("R_patella") || p("R_Patella") || R_knee;
  if (L_asis && L_patella && L_ankle) {
    // Q-Angle은 ASIS에서 무릎까지의 선과 무릎에서 발목까지의 선 사이의 각도
    // 실제로는 무릎에서 ASIS와 발목으로 가는 각도
    const qAngle = angleAt(L_patella, L_asis, L_ankle);
    result.Q_Angle = {
      value: qAngle,
      value_deg: qAngle,
      status: classifyRange({
        v: qAngle,
        nMin: 10, nMax: 20, // 일반적으로 여성이 더 큼
        mildMin: 20, mildMax: 25,
        modMin: 25, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Q-Angle (대퇴사두근 각도)",
      meaning: "Q-Angle (10–20° 정상, 여성이 더 큼)"
    };
  }
  
  // 8️⃣ KAS (Knee Alignment Symmetry): 무릎 정렬 대칭성
  if (L_knee && L_ankle && R_knee && R_ankle) {
    // 좌측 무릎-발목 선의 각도
    const L_dx = L_ankle.x - L_knee.x;
    const L_dy = L_ankle.y - L_knee.y;
    const L_angle = rad2deg(Math.atan2(L_dy, L_dx));
    
    // 우측 무릎-발목 선의 각도
    const R_dx = R_ankle.x - R_knee.x;
    const R_dy = R_ankle.y - R_knee.y;
    const R_angle = rad2deg(Math.atan2(R_dy, R_dx));
    
    // 각도 차이
    let angleDiff = Math.abs(L_angle - R_angle);
    if (angleDiff > 90) angleDiff = 180 - angleDiff; // 0-90도 범위로 정규화
    
    result.KAS = {
      value: angleDiff,
      value_deg: angleDiff,
      status: classifyRange({
        v: angleDiff,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 5,
        modMin: 5, modMax: 8,
        sevMin: 8, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Knee Alignment Symmetry (무릎 정렬 대칭성)",
      meaning: "무릎 정렬 대칭성 (대칭 ±2° 이내)"
    };
  }
  
  // 9️⃣ LLAS (Lower Limb Axis Symmetry): 하지 축 대칭성
  if (L_asis && L_ankle && R_asis && R_ankle) {
    // 좌측 ASIS-발목 선의 각도
    const L_dx = L_ankle.x - L_asis.x;
    const L_dy = L_ankle.y - L_asis.y;
    const L_angle = rad2deg(Math.atan2(L_dy, L_dx));
    
    // 우측 ASIS-발목 선의 각도
    const R_dx = R_ankle.x - R_asis.x;
    const R_dy = R_ankle.y - R_asis.y;
    const R_angle = rad2deg(Math.atan2(R_dy, R_dx));
    
    // 각도 차이
    let angleDiff = Math.abs(L_angle - R_angle);
    if (angleDiff > 90) angleDiff = 180 - angleDiff; // 0-90도 범위로 정규화
    
    result.LLAS = {
      value: angleDiff,
      value_deg: angleDiff,
      status: classifyRange({
        v: angleDiff,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 5,
        modMin: 5, modMax: 8,
        sevMin: 8, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Lower Limb Axis Symmetry (하지 축 대칭성)",
      meaning: "하지 축 대칭성 (±2° 이내)"
    };
  }
  
  return result;
}

// ✅ 분석 결과 요약 HTML 생성
function buildAnalysisSummaryHtml(analysisResult) {
  const side = analysisResult.side || {};
  const front = analysisResult.front || {};
  const summary = analysisResult.summary || {};
  
  let html = '<div style="margin-bottom:20px; padding:15px; background:#f5f5f5; border-radius:8px;">';
  
  // 측면 분석 결과
  if(side.status !== "not_available") {
    html += '<div style="font-size:14px; font-weight:700; margin-bottom:8px; color:#0b0f14;">측면 분석 결과</div>';
    for(const [key, value] of Object.entries(side)) {
      if(value && typeof value === 'object' && value.value != null && key !== 'status') {
        const unit = value.value_cm != null ? 'cm' : '°';
        const val = value.value_deg != null ? value.value_deg : value.value_cm;
        const status = value.status || 'unknown';
        html += `<div style="font-size:11px; margin-bottom:4px; line-height:1.5;">${key}: ${val.toFixed(2)}${unit} (${status})</div>`;
      }
    }
    html += '<div style="margin-bottom:12px;"></div>';
  }
  
  // 정면 분석 결과
  if(front.status !== "not_available") {
    html += '<div style="font-size:14px; font-weight:700; margin-bottom:8px; color:#0b0f14;">정면 분석 결과</div>';
    for(const [key, value] of Object.entries(front)) {
      if(value && typeof value === 'object' && value.value != null && key !== 'status') {
        const unit = value.value_cm != null ? 'cm' : '°';
        const val = value.value_deg != null ? value.value_deg : value.value_cm;
        const status = value.status || 'unknown';
        html += `<div style="font-size:11px; margin-bottom:4px; line-height:1.5;">${key}: ${val.toFixed(2)}${unit} (${status})</div>`;
      }
    }
    html += '<div style="margin-bottom:12px;"></div>';
  }
  
  // 종합 점수
  html += '<div style="border-top:1px solid #ddd; padding-top:12px; margin-top:12px;"></div>';
  if(summary.PDS_total != null) {
    html += `<div style="font-size:12px; font-weight:700; color:#6b46c1;">PDS 종합점수: ${summary.PDS_total} (${summary.risk_level})</div>`;
  } else {
    html += '<div style="font-size:11px; color:#666;">종합분석: 해당없음</div>';
  }
  
  html += '</div>';
  return html;
}

// ✅ 운동 추천 엔진 - 분석 결과를 받아서 패턴별 근육과 운동 추천 생성
function generatePostureRecommendations(analysis) {
  const patterns = [];
  
  function addPattern({pattern, condition, tight, weak, exercises}) {
    patterns.push({
      pattern: pattern,
      condition: condition,
      tight_muscles: tight,
      weak_muscles: weak,
      recommended_exercises: exercises
    });
  }
  
  // 측면 분석 결과에서 값 추출
  const side = analysis.side || {};
  const front = analysis.front || {};
  
  // 측면 지표
  const cva = side.CVA?.value_deg;
  const nia = side.NIA?.value_deg;
  const hpd = side.HPD?.value_cm;
  const saa = side.SAA?.value_deg;
  const pta = side.PTA?.value_deg;
  const ka = side.KA?.value_deg;
  const bva = side.BVA?.value_deg;
  const gsb = side.GSB?.value_cm;
  
  // 정면 지표
  const frontKA = front.KA?.value_deg;
  
  // 거북목 (FHP)
  if (cva != null && cva < 50) {
    addPattern({
      pattern: "거북목(FHP)",
      condition: "CVA↓ / NIA↑ / HPD↑",
      tight: ["SCM", "상부승모", "견갑거근", "소흉근"],
      weak: ["심부경부굴근", "하부승모", "전거근"],
      exercises: {
        "매트": ["Chin Tuck & Axial Elongation (턱당기기 + 축신장)", "Swan Prep"],
        "리포머": ["Pulling Straps"],
        "캐딜락": ["Tower Swan"],
        "체어": ["Press Down Front"],
        "바렐": ["Swan on Ladder Barrel"]
      }
    });
  }
  
  // 라운드숄더 (RSP)
  if (saa != null && saa > 10) {
    addPattern({
      pattern: "라운드숄더(RSP)",
      condition: "SAA↑",
      tight: ["대흉근", "소흉근", "상부승모"],
      weak: ["하부승모", "능형근", "전거근"],
      exercises: {
        "매트": ["Prone Scapular Retraction"],
        "리포머": ["Rowing Back", "Pulling Straps"],
        "캐딜락": ["Arm Springs - Extension"],
        "체어": ["Spine Stretch Forward (Chair Ver.)"],
        "바렐": ["Shoulder Extension on Barrel"]
      }
    });
  }
  
  // 과전경사 골반 (Anterior Tilt)
  if (pta != null && pta > 15) {
    addPattern({
      pattern: "과전경사 골반 (Anterior Tilt)",
      condition: "PTA↑, ASIS 하강, PSIS 상승",
      tight: ["장요근", "대퇴직근", "척추기립근"],
      weak: ["복직근", "복횡근", "둔근"],
      exercises: {
        "매트": ["Pelvic Curl", "Dead Bug / Toe Tap"],
        "리포머": ["Bridge on Reformer"],
        "캐딜락": ["Roll Down with Push Through Bar"],
        "체어": ["Standing Hip Extension"],
        "바렐": ["Short Box Round Back"]
      }
    });
  }
  
  // 후경사 골반 (Posterior Tilt)
  if (pta != null && pta < 5) {
    addPattern({
      pattern: "후경사 골반 (Posterior Tilt)",
      condition: "PTA↓, PSIS 하강",
      tight: ["햄스트링", "복직근"],
      weak: ["장요근", "대퇴직근", "척추기립근"],
      exercises: {
        "매트": ["Leg Pull Front"],
        "리포머": ["Footwork - Parallel Heels"],
        "캐딜락": ["Leg Springs - Supine"],
        "체어": ["Swan Press"],
        "바렐": ["Swan on Barrel"]
      }
    });
  }
  
  // X자 다리 (Genu Valgum) - 측면 또는 정면 KA 사용
  const kaValue = ka || frontKA;
  if (kaValue != null && kaValue < 175) {
    addPattern({
      pattern: "X자 다리 (Genu Valgum)",
      condition: "KA↓, Q-Angle↑",
      tight: ["내전근", "내측광근"],
      weak: ["중둔근", "외회전근", "외측광근"],
      exercises: {
        "매트": ["Side-Lying Leg Lift"],
        "리포머": ["Side Splits"],
        "캐딜락": ["Standing Hip Abduction"],
        "체어": ["Step Up Lateral"],
        "바렐": ["Side Bend Stretch"]
      }
    });
  }
  
  // O자 다리 (Genu Varum)
  if (kaValue != null && kaValue > 180) {
    addPattern({
      pattern: "O자 다리 (Genu Varum)",
      condition: "KA↑",
      tight: ["외측광근", "비복근", "대퇴이두"],
      weak: ["내전근", "내측광근"],
      exercises: {
        "매트": ["Ball Squeeze Bridge"],
        "리포머": ["Footwork - Small V Position"],
        "캐딜락": ["Standing Leg Press - Adduction"],
        "체어": ["Seated Adduction"],
        "바렐": ["Adductor Stretch on Barrel"]
      }
    });
  }
  
  // 전방 체중 중심 (Forward Center)
  if (gsb != null && gsb > 2) {
    addPattern({
      pattern: "체중 중심 전방 (Forward Center)",
      condition: "GSB↑, BVA↑",
      tight: ["대퇴직근", "요추기립근", "종아리근"],
      weak: ["둔근", "햄스트링", "복부"],
      exercises: {
        "매트": ["Pelvic Curl"],
        "리포머": ["Scooter"],
        "캐딜락": ["Tower Roll Up"],
        "체어": ["Standing Leg Press"],
        "바렐": ["Swan"]
      }
    });
  }
  
  // 후방 체중 중심 (Backward Center)
  if (gsb != null && gsb < -2) {
    addPattern({
      pattern: "체중 중심 후방 (Backward Center)",
      condition: "GSB↓, BVA↓",
      tight: ["햄스트링", "둔근"],
      weak: ["장요근", "대퇴직근"],
      exercises: {
        "매트": ["Hip Flexor Stretch"],
        "리포머": ["Standing Lunge"],
        "캐딜락": ["Leg Springs - Supine"],
        "체어": ["Step Up Front"],
        "바렐": ["Lunge on Barrel"]
      }
    });
  }
  
  return { patterns: patterns };
}

// ✅ 통합 분석 함수 - 측면/정면 자동 감지
function analyzePostureAuto(options = {}) {
  const {
    sidePts = null,
    frontPts = null,
    pxPerCm = 50.0
  } = options;
  
  const result = {
    side: {},
    front: {},
    summary: {}
  };
  
  // 측면 분석
  if (sidePts != null && Object.keys(sidePts).length > 0) {
    result.side = analyzeFullPosture(sidePts, pxPerCm);
  } else {
    result.side.status = "not_available";
  }
  
  // 정면 분석
  if (frontPts != null && Object.keys(frontPts).length > 0) {
    result.front = analyzeFrontPosture(frontPts, pxPerCm);
  } else {
    result.front.status = "not_available";
  }
  
  // 통합 점수 계산
  const sidePDS = result.side.PDS?.value || 0;
  const frontPDS = result.front.PDS?.value || 0;
  
  const availableCount = [
    result.side.status !== "not_available",
    result.front.status !== "not_available"
  ].filter(e => e).length;
  
  if (availableCount > 0) {
    const avg = (sidePDS + frontPDS) / (availableCount === 2 ? 2 : 1);
    result.summary = {
      PDS_total: avg.toFixed(1),
      risk_level: avg < 10 
        ? "정상" 
        : avg < 15 
          ? "경미한 불균형" 
          : "중등도 이상 불균형"
    };
  } else {
    result.summary.status = "not_available";
  }
  
  return result;
}

// ✅ 통합 분석 + 운동 추천 결합
function analyzePostureAutoWithRecommendation(options = {}) {
  const {
    sidePts = null,
    frontPts = null,
    pxPerCm = 50.0
  } = options;
  
  // 기본 통합 분석 실행
  const result = analyzePostureAuto({
    sidePts: sidePts,
    frontPts: frontPts,
    pxPerCm: pxPerCm
  });
  
  // 분석 결과를 통합하여 운동 추천 생성
  const analysis = {
    side: result.side,
    front: result.front,
    summary: result.summary
  };
  
  // 운동 추천 생성
  const recommendation = generatePostureRecommendations(analysis);
  result.recommendations = recommendation;
  
  return result;
}

// ✅ 실시간 분석 엔진 (Stream 기반)
class LivePostureAnalyzer {
  constructor() {
    this.listeners = [];
    this.isAnalyzing = false;
    this.lastResult = null;
  }
  
  // 리스너 추가 (실시간 결과 수신)
  addListener(callback) {
    this.listeners.push(callback);
  }
  
  // 리스너 제거
  removeListener(callback) {
    const index = this.listeners.indexOf(callback);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }
  
  // 결과 브로드캐스트
  _broadcast(result) {
    this.lastResult = result;
    this.listeners.forEach(callback => {
      try {
        callback(result);
      } catch (error) {
        console.error('Listener error:', error);
      }
    });
  }
  
  // 실시간 분석 실행 (매 프레임/좌표 변경 시)
  analyzeFrame(options = {}) {
    if (this.isAnalyzing) {
      return this.lastResult; // 이미 분석 중이면 마지막 결과 반환
    }
    
    this.isAnalyzing = true;
    
    try {
      const {
        sidePts = null,
        frontPts = null,
        pxPerCm = 50.0
      } = options;
      
      // 통합 분석 실행
      const analysisResult = analyzePostureAutoWithRecommendation({
        sidePts: sidePts,
        frontPts: frontPts,
        pxPerCm: pxPerCm
      });
      
      // 실시간 결과 포맷 (JSON 출력 예시 구조)
      const result = {
        timestamp: new Date().toISOString(),
        analysis: {
          side: analysisResult.side,
          front: analysisResult.front,
          summary: analysisResult.summary
        },
        recommendations: analysisResult.recommendations || { patterns: [] }
      };
      
      // 주요 지표 추출 (실시간 표시용)
      const sideMetrics = analysisResult.side || {};
      const frontMetrics = analysisResult.front || {};
      const summary = analysisResult.summary || {};
      
      result.liveMetrics = {
        CVA: sideMetrics.CVA ? { value: sideMetrics.CVA.value_deg, status: sideMetrics.CVA.status } : null,
        PTA: sideMetrics.PTA ? { value: sideMetrics.PTA.value_deg, status: sideMetrics.PTA.status } : null,
        KA: sideMetrics.KA ? { value: sideMetrics.KA.value_deg, status: sideMetrics.KA.status } : (frontMetrics.KA ? { value: frontMetrics.KA.value_deg, status: frontMetrics.KA.status } : null),
        PDS: summary.PDS_total ? parseFloat(summary.PDS_total) : 0,
        risk_level: summary.risk_level || 'unknown'
      };
      
      // 브로드캐스트
      this._broadcast(result);
      
      return result;
    } finally {
      this.isAnalyzing = false;
    }
  }
  
  // 현재 세션의 키포인트로 실시간 분석
  analyzeCurrentSession() {
    const S = sessions[cur];
    const pxPerCm = S.pxPerCm || 50.0;
    
    // 측면 및 정면 키포인트 변환
    const sidePoints = {};
    const frontPoints = {};
    
    for(const [key, value] of S.sidePoints.entries()) {
      if(value && value.x != null && value.y != null) {
        sidePoints[key] = { x: value.x, y: value.y };
      }
    }
    
    for(const [key, value] of S.frontPoints.entries()) {
      if(value && value.x != null && value.y != null) {
        frontPoints[key] = { x: value.x, y: value.y };
      }
    }
    
    return this.analyzeFrame({
      sidePts: Object.keys(sidePoints).length > 0 ? sidePoints : null,
      frontPts: Object.keys(frontPoints).length > 0 ? frontPoints : null,
      pxPerCm: pxPerCm
    });
  }
}

// 전역 실시간 분석기 인스턴스
const liveAnalyzer = new LivePostureAnalyzer();

// 🏋️‍♀️ 패턴 기반 필라테스 추천 시스템 (BASI/Polestar/STOTT 기준)
const pilatesPatterns = {
  // 1️⃣ 거북목(FHP): CVA↓, NIA↑, HPD↑
  'FHP': {
    name: '거북목 (Forward Head Posture)',
    condition: 'CVA↓ / NIA↑ / HPD↑',
    tight: ['SCM', '상부승모', '견갑거근', '소흉근'],
    weak: ['심부경부굴근', '하부승모', '전거근'],
    interpretation: '머리 전방 돌출, 경추 전만 감소',
    exercises: {
      매트: [
        { en: 'Chin Tuck & Axial Elongation', ko: '턱당기기 + 축신장', purpose: '경추 안정화' },
        { en: 'Swan Prep', ko: '스완 준비', purpose: '흉추 신전, 승모근 하부 강화' }
      ],
      리포머: [
        { en: 'Pulling Straps', ko: '풀링 스트랩', purpose: '견갑 후방 안정화' }
      ],
      캐딜락: [
        { en: 'Tower Swan', ko: '타워 스완', purpose: '흉추 신전 + 견갑 후방운동' }
      ],
      체어: [
        { en: 'Press Down Front', ko: '프레스 다운 프론트', purpose: '경추 정렬 + 전거근 활성화' }
      ],
      바렐: [
        { en: 'Swan on Ladder Barrel', ko: '래더 배럴 스완', purpose: '흉추 가동성, 승모하부 강화' }
      ]
    }
  },
  
  // 2️⃣ 라운드숄더(RSP): SAA↑
  'RSP': {
    name: '라운드숄더 (Rounded Shoulder Posture)',
    condition: 'SAA↑',
    tight: ['대흉근', '소흉근', '상부승모'],
    weak: ['하부승모', '능형근', '전거근'],
    interpretation: '견갑 전인·상방회전',
    exercises: {
      매트: [
        { en: 'Prone Scapular Retraction', ko: '프론 사투라 견갑골 후인', purpose: '견갑골 후인 강화' }
      ],
      리포머: [
        { en: 'Rowing Back / Pulling Straps', ko: '로잉 백 / 풀링 스트랩', purpose: '견갑 안정화' }
      ],
      캐딜락: [
        { en: 'Arm Springs - Extension', ko: '암 스프링 - 익스텐션', purpose: '어깨 후방근 강화' }
      ],
      체어: [
        { en: 'Spine Stretch Forward (Chair Ver.)', ko: '스파인 스트레치 포워드 (체어 버전)', purpose: '견갑 안정화 및 흉추 신전' }
      ],
      바렐: [
        { en: 'Shoulder Extension on Barrel', ko: '배럴 어깨 익스텐션', purpose: '흉추 가동성 + 어깨 후인근 강화' }
      ]
    }
  },
  
  // 3️⃣ 과전경사 골반: PTA↑
  'AnteriorTilt': {
    name: '과전경사 골반 (Anterior Pelvic Tilt)',
    condition: 'PTA↑, ASIS 하강, PSIS 상승',
    tight: ['장요근', '대퇴직근', '척추기립근'],
    weak: ['복직근', '복횡근', '둔근'],
    interpretation: '골반 전방경사 / 요추 전만 증가',
    exercises: {
      매트: [
        { en: 'Pelvic Curl', ko: '펠빅 컬', purpose: '골반 후경사 유도' },
        { en: 'Dead Bug / Toe Tap', ko: '데드 버그 / 토 탭', purpose: '복횡근 활성화' }
      ],
      리포머: [
        { en: 'Bridge on Reformer', ko: '리포머 브릿지', purpose: '후방 사슬 강화' }
      ],
      캐딜락: [
        { en: 'Roll Down with Push Through Bar', ko: '롤 다운 (푸시 스루 바)', purpose: '복부 코어 조절' }
      ],
      체어: [
        { en: 'Standing Hip Extension', ko: '스탠딩 힙 익스텐션', purpose: '둔근 강화' }
      ],
      바렐: [
        { en: 'Short Box Round Back', ko: '숏 박스 라운드 백', purpose: '코어 + 후방 사슬 강화' }
      ]
    }
  },
  
  // 4️⃣ 후경사 골반: PTA↓
  'PosteriorTilt': {
    name: '후경사 골반 (Posterior Pelvic Tilt)',
    condition: 'PTA↓, PSIS 하강',
    tight: ['햄스트링', '복직근'],
    weak: ['장요근', '대퇴직근', '척추기립근'],
    interpretation: '골반 후방경사 / 요추 편평',
    exercises: {
      매트: [
        { en: 'Leg Pull Front', ko: '레그 풀 프론트', purpose: '전방 사슬 강화' }
      ],
      리포머: [
        { en: 'Footwork - Parallel Heels', ko: '풋워크 - 패럴렐 힐즈', purpose: '고관절 신전 활성화' }
      ],
      캐딜락: [
        { en: 'Leg Springs - Supine', ko: '레그 스프링 - 슈파인', purpose: '장요근 기능적 수축' }
      ],
      체어: [
        { en: 'Swan Press', ko: '스완 프레스', purpose: '요추 신전 강화' }
      ],
      바렐: [
        { en: 'Swan on Barrel', ko: '배럴 스완', purpose: '요추 가동성 향상' }
      ]
    }
  },
  
  // 5️⃣ X자 다리: KA↓, Q-Angle↑
  'GenuValgum': {
    name: 'X자 다리 (Genu Valgum)',
    condition: 'KA↓, Q-Angle↑',
    tight: ['내전근', '내측광근'],
    weak: ['중둔근', '외회전근', '외측광근'],
    interpretation: '슬개골 외측 압박 패턴',
    exercises: {
      매트: [
        { en: 'Side-Lying Leg Lift', ko: '사이드 라잉 레그 리프트', purpose: '중둔근 강화' }
      ],
      리포머: [
        { en: 'Side Splits', ko: '사이드 스플릿', purpose: '외측 안정화' }
      ],
      캐딜락: [
        { en: 'Standing Hip Abduction', ko: '스탠딩 힙 외전', purpose: '고관절 외전 강화' }
      ],
      체어: [
        { en: 'Step Up Lateral', ko: '스텝 업 레터럴', purpose: '하지 외측 안정성' }
      ],
      바렐: [
        { en: 'Side Bend Stretch', ko: '사이드 벤드 스트레치', purpose: '고관절 정렬 및 안정성 개선' }
      ]
    }
  },
  
  // 6️⃣ O자 다리: KA↑
  'GenuVarum': {
    name: 'O자 다리 (Genu Varum)',
    condition: 'KA↑',
    tight: ['외측광근', '비복근', '대퇴이두'],
    weak: ['내전근', '내측광근'],
    interpretation: '외측 과부하',
    exercises: {
      매트: [
        { en: 'Ball Squeeze Bridge', ko: '볼 스퀴즈 브릿지', purpose: '내전근 활성화' }
      ],
      리포머: [
        { en: 'Footwork - Small V Position', ko: '풋워크 - 스몰 V 포지션', purpose: '내측광근 강화' }
      ],
      캐딜락: [
        { en: 'Standing Leg Press - Adduction', ko: '스탠딩 레그 프레스 - 내전', purpose: '내전근 강화' }
      ],
      체어: [
        { en: 'Seated Adduction', ko: '시티드 내전', purpose: '내측 근육 조절' }
      ],
      바렐: [
        { en: 'Adductor Stretch on Barrel', ko: '배럴 내전근 스트레치', purpose: '내전근 가동성 향상' }
      ]
    }
  },
  
  // 7️⃣ 체중 중심 전방: GSB↑, BVA↑
  'ForwardCenter': {
    name: '체중 중심 전방 (Forward Center)',
    condition: 'GSB↑, BVA↑',
    tight: ['대퇴직근', '요추기립근', '종아리근'],
    weak: ['둔근', '햄스트링', '복부'],
    interpretation: '체간 전방기울임',
    exercises: {
      매트: [
        { en: 'Pelvic Curl', ko: '펠빅 컬', purpose: '둔근/햄스트링 강화' }
      ],
      리포머: [
        { en: 'Scooter', ko: '스쿠터', purpose: '둔근 신전 조절' }
      ],
      캐딜락: [
        { en: 'Tower Roll Up', ko: '타워 롤 업', purpose: '코어 활성화' }
      ],
      체어: [
        { en: 'Standing Leg Press', ko: '스탠딩 레그 프레스', purpose: '후방 체중 이동 훈련' }
      ],
      바렐: [
        { en: 'Swan', ko: '스완', purpose: '흉추 안정화' }
      ]
    }
  },
  
  // 8️⃣ 체중 중심 후방: GSB↓, BVA↓
  'BackwardCenter': {
    name: '체중 중심 후방 (Backward Center)',
    condition: 'GSB↓, BVA↓',
    tight: ['햄스트링', '둔근'],
    weak: ['장요근', '대퇴직근'],
    interpretation: '체간 후방기울임',
    exercises: {
      매트: [
        { en: 'Hip Flexor Stretch', ko: '힙 플렉서 스트레치', purpose: '전방 사슬 활성화' }
      ],
      리포머: [
        { en: 'Standing Lunge', ko: '스탠딩 런지', purpose: '고관절 신전/굴곡 밸런스' }
      ],
      캐딜락: [
        { en: 'Leg Springs - Supine', ko: '레그 스프링 - 슈파인', purpose: '장요근 강화' }
      ],
      체어: [
        { en: 'Step Up Front', ko: '스텝 업 프론트', purpose: '하지 전방 안정화' }
      ],
      바렐: [
        { en: 'Lunge on Barrel', ko: '배럴 런지', purpose: '고관절 전방이동 훈련' }
      ]
    }
  }
};

// 하위 호환성을 위한 기존 pilatesData 유지
const pilatesData = {
  '목 신전근 긴장': {
    매트: ['Roll-Up', 'Spine Stretch Forward'],
    리포머: ['Neck Stretch on Box'],
    캐딜락: ['Tower - Arm Springs'],
    체어: ['Tricep Dips'],
    바렐: ['Chest Stretch']
  },
  '상부승모근 과긴장': {
    매트: ['Arm Circles', 'Swimming Prep'],
    리포머: ['Rowing - From Chest'],
    캐딜락: ['Arm Springs - Chest Expansion'],
    체어: ['Tricep Press'],
    바렐: ['Side Stretch Over']
  },
  '전방어깨자세': {
    매트: ['Swan Dive', 'T-Raise'],
    리포머: ['Backstroke', 'Pulling Straps'],
    캐딜락: ['Push Through Bar'],
    체어: ['Push Down - Front'],
    바렐: ['Chest Expansion']
  },
  '어깨안정근 약화': {
    매트: ['Plank to Pike', 'Side Plank'],
    리포머: ['Long Stretch Series'],
    캐딜락: ['Arm Springs - Bug'],
    체어: ['Mountain Climber'],
    바렐: ['Side Arm Work']
  },
  '회전근개 불균형': {
    매트: ['Side Lying Arm Series'],
    리포머: ['Arm Work - Salute'],
    캐딜락: ['Tower - Rotation'],
    체어: ['Seated Rotation'],
    바렐: ['Spiral Stretch']
  },
  '복직근 약화': {
    매트: ['The Hundred', 'Teaser'],
    리포머: ['Stomach Series - Hundred'],
    캐딜락: ['Roll Down Bar'],
    체어: ['Teaser Prep'],
    바렐: ['Sit Up Series']
  },
  '복사근 불균형': {
    매트: ['Criss Cross', 'Saw'],
    리포머: ['Short Box - Twist'],
    캐딜락: ['Twist & Reach'],
    체어: ['Side Bend'],
    바렐: ['Twist on Barrel']
  },
  '깊은코어 약화': {
    매트: ['Dead Bug', 'Modified Hundred'],
    리포머: ['Footwork - Parallel'],
    캐딜락: ['Breathing with Springs'],
    체어: ['Seated Balance'],
    바렐: ['Core Integration']
  },
  '흉추 과후만': {
    매트: ['Swan', 'Extension Series'],
    리포머: ['Short Box - Arch'],
    캐딜락: ['Monkey Stretch'],
    체어: ['Back Extension'],
    바렐: ['Chest Opening']
  },
  '요추 과전만': {
    매트: ['Pelvic Curl', 'Imprint & Release'],
    리포머: ['Pelvic Press', 'Knee Stretches'],
    캐딜락: ['Tower - Hip Work'],
    체어: ['Hip Flexor Stretch'],
    바렐: ['Hip Opening']
  },
  '척추기립근 약화': {
    매트: ['Swimming', 'Rocking'],
    리포머: ['Long Back Stretch'],
    캐딜락: ['Back Extension Springs'],
    체어: ['Swan on Chair'],
    바렐: ['Round Back']
  },
  '고관절 굴곡근 단축': {
    매트: ['Hip Flexor Stretch', 'Lunge'],
    리포머: ['Lunge Series', 'Runner Stretch'],
    캐딜락: ['Tower - Hip Stretch'],
    체어: ['Standing Lunge'],
    바렐: ['Hip Flexor Series']
  },
  '둔근 약화': {
    매트: ['Bridge Series', 'Clam'],
    리포머: ['Footwork - Relevé', 'Leg Press'],
    캐딜락: ['Leg Springs - Circles'],
    체어: ['Glute Press Back'],
    바렐: ['Hip Extension']
  },
  '골반 불안정': {
    매트: ['Single Leg Bridge', 'Single Leg Stretch'],
    리포머: ['Single Leg Work'],
    캐딜락: ['Leg Springs - Adduction'],
    체어: ['Standing Balance'],
    바렐: ['Stability Challenge']
  },
  '대퇴사두근 약화': {
    매트: ['Wall Squat', 'Single Leg Squat'],
    리포머: ['Footwork - Heels', 'Squats'],
    캐딜락: ['Leg Press Springs'],
    체어: ['Standing Press Down'],
    바렐: ['Leg Strengthening']
  },
  '햄스트링 단축': {
    매트: ['Leg Pull Front', 'Roll Over'],
    리포머: ['Hamstring Stretch', 'Tendon Stretch'],
    캐딜락: ['Tower - Leg Stretch'],
    체어: ['Leg Pull Back'],
    바렐: ['Hip Flexor Stretch']
  },
  '종아리 근육 긴장': {
    매트: ['Calf Stretch', 'Ankle Circles'],
    리포머: ['Calf Raises', 'Tendon Stretch'],
    캐딜락: ['Foot Corrector Work'],
    체어: ['Heel Raises'],
    바렐: ['Ankle Mobility']
  }
};

// 근육 이름을 필라테스 문제로 매핑
function mapMuscleToPilatesIssue(muscleName) {
  const mapping = {
    '상부승모근': '상부승모근 과긴장',
    '견갑거근': '상부승모근 과긴장',
    'SCM': '상부승모근 과긴장',
    '흉쇄유돌근': '상부승모근 과긴장',
    '심부경부굴근': '목 굴곡근 약화',
    '전거근': '목 굴곡근 약화',
    '하부승모근': '전방어깨자세',
    '장요근': '고관절 굴곡근 단축',
    '요추기립근': '요추 과전만',
    '대퇴직근': '고관절 굴곡근 단축',
    '흉요근막': '요추 과전만',
    '복횡근': '깊은코어 약화',
    '둔근': '둔근 약화',
    '대둔근': '둔근 약화',
    '중둔근': '둔근 약화',
    '하둔근': '둔근 약화',
    '복직근': '복직근 약화',
    '대퇴사두근': '대퇴사두근 약화',
    '햄스트링': '햄스트링 단축',
    '비복근': '종아리 근육 긴장',
    '가자미근': '종아리 근육 긴장',
    '슬와근': '햄스트링 단축'
  };
  return mapping[muscleName] || null;
}

// 필라테스 동작 추천 함수
function recommendPilates(tight, weak) {
  const pilatesIssues = new Map();
  
  // 긴장된 근육에 대한 필라테스
  tight.forEach(muscle => {
    const issue = mapMuscleToPilatesIssue(muscle);
    if(issue && pilatesData[issue]) {
      if(!pilatesIssues.has(issue)) {
        pilatesIssues.set(issue, { type: '긴장', muscles: [], pilates: pilatesData[issue] });
      }
      pilatesIssues.get(issue).muscles.push(muscle);
    }
  });
  
  // 약화된 근육에 대한 필라테스
  weak.forEach(muscle => {
    const issue = mapMuscleToPilatesIssue(muscle);
    if(issue && pilatesData[issue]) {
      if(!pilatesIssues.has(issue)) {
        pilatesIssues.set(issue, { type: '약화', muscles: [], pilates: pilatesData[issue] });
      }
      pilatesIssues.get(issue).muscles.push(muscle);
    }
  });
  
  return Array.from(pilatesIssues.entries()).map(([issue, data]) => ({
    issue,
    type: data.type,
    muscles: [...new Set(data.muscles)],
    pilates: data.pilates
  }));
}
const internalAngle = (a,b,c) => {
  const ab = Math.atan2(a.y - b.y, a.x - b.x);
  const cb = Math.atan2(c.y - b.y, c.x - b.x);
  let d = Math.abs(ab - cb);
  if(d > Math.PI) d = 2 * Math.PI - d;
  return d;
};

document.getElementById("btnBefore").onclick = () => switchSession("Before");
document.getElementById("btnAfter").onclick = () => switchSession("After");

// 정면/옆모습 선택 버튼
document.getElementById("btnOrientationSide").onclick = () => setOrientation("side");
document.getElementById("btnOrientationFront").onclick = () => setOrientation("front");

function updateCoordSelectOptions() {
  const selectEl = document.getElementById("coordSelectPoint");
  if(!selectEl) return;
  
  const orientation = sessions[cur].poseData?.orientation || "side";
  const currentKeypoints = orientation === "front" ? keypointsFront : keypointsSide;
  const currentValue = selectEl.value;
  
  // 기존 옵션 제거 (첫 번째 옵션인 "점 선택..." 제외)
  while(selectEl.options.length > 1) {
    selectEl.remove(1);
  }
  
  // 현재 orientation에 맞는 키포인트 추가
  currentKeypoints.forEach(kp => {
    const option = document.createElement('option');
    option.value = kp.key;
    option.textContent = kp.key;
    selectEl.appendChild(option);
  });
  
  // 이전에 선택된 점이 현재 키포인트 목록에 있으면 유지
  if(currentValue && currentKeypoints.some(kp => kp.key === currentValue)) {
    selectEl.value = currentValue;
  } else {
    selectEl.value = "";
    selectedPoint = null;
  }
}

function setOrientation(orientation) {
  if(!sessions[cur].poseData) {
    sessions[cur].poseData = { orientation: orientation, landmarks: null };
  } else {
    sessions[cur].poseData.orientation = orientation;
  }
  document.getElementById("btnOrientationSide").classList.toggle("active", orientation === "side");
  document.getElementById("btnOrientationFront").classList.toggle("active", orientation === "front");
  console.log(`${cur} 세션의 방향을 ${orientation === "side" ? "옆모습" : "정면"}으로 설정`);
  
  // 좌표 선택 드롭다운 업데이트
  updateCoordSelectOptions();
  
  // 원본 크기 초기화 (orientation마다 다른 이미지 크기를 가질 수 있음)
  originalCanvasSize.width = 0;
  originalCanvasSize.height = 0;
  originalCanvasSize.styleWidth = 0;
  originalCanvasSize.styleHeight = 0;
  
  // orientation 변경 시 캔버스 다시 그리기
  const currentImg = orientation === "front" ? sessions[cur].imgFront : sessions[cur].imgSide;
  if(currentImg) {
    resizeCanvasFor(currentImg);
  }
  draw();
}

function switchSession(s) {
  cur = s;
  document.getElementById("btnBefore").classList.toggle("active", s === "Before");
  document.getElementById("btnAfter").classList.toggle("active", s === "After");
  document.getElementById("currentSession").textContent = s;
  
  // 세션 전환 시 orientation 버튼 업데이트
  const orientation = sessions[s].poseData?.orientation || "side";
  document.getElementById("btnOrientationSide").classList.toggle("active", orientation === "side");
  document.getElementById("btnOrientationFront").classList.toggle("active", orientation === "front");
  
  // 좌표 선택 드롭다운 업데이트
  updateCoordSelectOptions();
  
  // 원본 크기 초기화 (세션마다 다른 이미지 크기를 가질 수 있음)
  originalCanvasSize.width = 0;
  originalCanvasSize.height = 0;
  originalCanvasSize.styleWidth = 0;
  originalCanvasSize.styleHeight = 0;
  
  // 세션의 이미지로 캔버스 크기 조정
  const img = orientation === "front" ? sessions[s].imgFront : sessions[s].imgSide;
  if(img) {
    resizeCanvasFor(img);
  }
  
  draw();
  // 세션 전환 시에는 기존 분석이 있으면 유지, 없으면 metrics만 계산
  if(sessions[s].analysis) {
    // 기존 분석이 있으면 전체 업데이트
    const score = sessions[s].score;
    const metrics = sessions[s].metrics;
    const analysis = sessions[s].analysis;
    updateScoreAndAnalysis(score, metrics.cva, metrics.pelvic, metrics.knee, analysis);
  } else {
    computeMetricsOnly(); // 분석이 없으면 metrics만 계산
  }
  updateCompare();
}

function resizeCanvasFor(img) {
  const canvasWrap = cv.parentElement;
  const maxW = canvasWrap.clientWidth - 24;
  const maxH = canvasWrap.clientHeight - 24;
  
  // 원본 크기 계산 (처음 한 번만 또는 editMode가 아닐 때)
  let baseW, baseH;
  if(!editMode || originalCanvasSize.width === 0 || originalCanvasSize.height === 0) {
  if(img) {
    // 컨테이너에 맞게 원본 비율 유지하며 크기 계산
    const r = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight);
    baseW = Math.round(img.naturalWidth * r);
    baseH = Math.round(img.naturalHeight * r);
  } else {
    baseW = 1200;
    baseH = 800;
  }
  
    // 원본 크기 저장
    originalCanvasSize.width = baseW;
    originalCanvasSize.height = baseH;
    originalCanvasSize.styleWidth = baseW;
    originalCanvasSize.styleHeight = baseH;
  } else {
    // 이미 저장된 원본 크기 사용 (editMode에서 확대 시)
    baseW = originalCanvasSize.width;
    baseH = originalCanvasSize.height;
  }
  
  // 확대 배율 적용 (비율 유지)
  const zoomMultiplier = editMode ? currentZoom : 1;
  const finalW = baseW * zoomMultiplier;
  const finalH = baseH * zoomMultiplier;
  
  // 캔버스 크기 설정
  cv.width = finalW * DPR;
  cv.height = finalH * DPR;
  cv.style.width = finalW + "px";
  cv.style.height = finalH + "px";
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  
  // 확대된 경우 스크롤 가능하도록 설정
  if(editMode && currentZoom > 1) {
    canvasWrap.classList.add("zoomed");
    canvasWrap.style.overflow = "auto";
    canvasWrap.style.overflowX = "auto";
    canvasWrap.style.overflowY = "auto";
  } else {
    canvasWrap.classList.remove("zoomed");
    canvasWrap.style.overflow = "auto";
    canvasWrap.style.overflowX = "hidden";
    canvasWrap.style.overflowY = "hidden";
  }
  
  // 다시 그리기
  draw();
}

function ensureDefaultPoints(session) {
  const S = sessions[session];
  // 원본 크기 기준으로 좌표 계산
  const W = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
  const H = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
  
  const orientation = S.poseData?.orientation || "side";
  const currentImg = orientation === "front" ? S.imgFront : S.imgSide;
  const currentKeypoints = orientation === "front" ? keypointsFront : keypointsSide;
  const currentPoints = orientation === "front" ? S.frontPoints : S.sidePoints;
  
  if(currentPoints.size === 0 && currentImg) {
    // Flutter 1:1 매칭 키로 기본값 설정
    const defaults = orientation === "front" ? {
      c7: {x:W*0.5, y:H*0.2},
      L_acromion: {x:W*0.3, y:H*0.3},
      R_acromion: {x:W*0.7, y:H*0.3},
      L_asis: {x:W*0.35, y:H*0.5},
      R_asis: {x:W*0.65, y:H*0.5},
      L_knee: {x:W*0.4, y:H*0.75},
      R_knee: {x:W*0.6, y:H*0.75},
      L_ankle: {x:W*0.4, y:H*0.95},
      R_ankle: {x:W*0.6, y:H*0.95},
    } : {
      tragus: {x:W*0.35, y:H*0.3},
      c7: {x:W*0.3, y:H*0.35},
      acromion: {x:W*0.35, y:H*0.4},
      hip: {x:W*0.38, y:H*0.6},
      knee: {x:W*0.42, y:H*0.8},
      ankle: {x:W*0.44, y:H*0.95},
      asis: {x:W*0.40, y:H*0.58},
      psis: {x:W*0.35, y:H*0.6},
    };
    for(const kp of currentKeypoints) {
      if(defaults[kp.key]) currentPoints.set(kp.key, {...defaults[kp.key]});
    }
  }
}

function getPts(session) {
  const orientation = sessions[session].poseData?.orientation || "side";
  const map = orientation === "front" ? sessions[session].frontPoints : sessions[session].sidePoints;
  const currentKeypoints = orientation === "front" ? keypointsFront : keypointsSide;
  const out = {};
  
  // 새로운 소문자 키로 저장된 값 가져오기
  for(const k of currentKeypoints) {
    out[k.key] = map.get(k.key);
  }
  
  // 기존 대문자 키 호환성 레이어 (draw, computeMetricsOnly 등에서 사용)
  if(orientation === "side") {
    out['Tragus'] = out['tragus'];
    out['C7'] = out['c7'];
    out['Shoulder'] = out['acromion'];  // 기존 Shoulder 키 지원
    out['Acromion'] = out['acromion'];
    out['Hip'] = out['hip'];
    out['Knee'] = out['knee'];
    out['Ankle'] = out['ankle'];
    out['ASIS'] = out['asis'];
    out['PSIS'] = out['psis'];
  }
  // 정면은 이미 일치하므로 추가 매핑 불필요 (c7만 처리)
  if(orientation === "front") {
    out['C7'] = out['c7'];
  }
  
  return out;
}

// 현재 orientation에 맞는 키포인트 반환
function getKeypoints() {
  const orientation = sessions[cur].poseData?.orientation || "side";
  return orientation === "front" ? keypointsFront : keypointsSide;
}

function draw() {
  const S = sessions[cur];
  const W = cv.width / DPR, H = cv.height / DPR;
  ctx.clearRect(0, 0, cv.width, cv.height);
  ctx.fillStyle = "#0a0e13";
  ctx.fillRect(0, 0, W, H);

  // orientation에 따라 적절한 이미지 선택
  const orientation = S.poseData?.orientation || "side";
  const currentImg = orientation === "front" ? S.imgFront : S.imgSide;

  if(currentImg) {
    // 원본 크기 저장 (처음 한 번만)
    if(originalCanvasSize.width === 0) {
      const maxW = cv.parentElement.clientWidth - 24;
      const maxH = cv.parentElement.clientHeight - 24;
      const r = Math.min(maxW / currentImg.naturalWidth, maxH / currentImg.naturalHeight);
      originalCanvasSize.width = Math.round(currentImg.naturalWidth * r);
      originalCanvasSize.height = Math.round(currentImg.naturalHeight * r);
      originalCanvasSize.styleWidth = originalCanvasSize.width;
      originalCanvasSize.styleHeight = originalCanvasSize.height;
    }
    // 이미지 그리기 (비율 유지하며 확대된 크기로)
    ctx.drawImage(currentImg, 0, 0, W, H);
  }

  ensureDefaultPoints(cur);
  const P = getPts(cur);
  const currentKeypoints = getKeypoints();

  // 확대 배율 적용
  const scaleX = editMode ? currentZoom : 1;
  const scaleY = editMode ? currentZoom : 1;

  // 보조선 그리기
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.strokeStyle = 'rgba(124,156,255,0.85)';

  if(P.C7 && P.Tragus) {
    ctx.beginPath();
    ctx.moveTo(0, P.C7.y * scaleY);
    ctx.lineTo(W, P.C7.y * scaleY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(P.C7.x * scaleX, P.C7.y * scaleY);
    ctx.lineTo(P.Tragus.x * scaleX, P.Tragus.y * scaleY);
    ctx.stroke();
  }

  if(P.Shoulder && P.Hip) {
    ctx.beginPath();
    ctx.moveTo(P.Shoulder.x * scaleX, P.Shoulder.y * scaleY);
    ctx.lineTo(P.Hip.x * scaleX, P.Hip.y * scaleY);
    ctx.stroke();
  }
  if(P.Hip && P.Knee) {
    ctx.beginPath();
    ctx.moveTo(P.Hip.x * scaleX, P.Hip.y * scaleY);
    ctx.lineTo(P.Knee.x * scaleX, P.Knee.y * scaleY);
    ctx.stroke();
  }
  if(P.Knee && P.Ankle) {
    ctx.beginPath();
    ctx.moveTo(P.Knee.x * scaleX, P.Knee.y * scaleY);
    ctx.lineTo(P.Ankle.x * scaleX, P.Ankle.y * scaleY);
    ctx.stroke();
  }

  if(P.ASIS && P.PSIS) {
    ctx.strokeStyle = 'rgba(255,184,108,0.95)';
    ctx.beginPath();
    ctx.moveTo(P.ASIS.x * scaleX, P.ASIS.y * scaleY);
    ctx.lineTo(P.PSIS.x * scaleX, P.PSIS.y * scaleY);
    ctx.stroke();
    ctx.strokeStyle = 'rgba(255,184,108,0.35)';
    const midy = (P.ASIS.y + P.PSIS.y) / 2;
    ctx.beginPath();
    ctx.moveTo(0, midy * scaleY);
    ctx.lineTo(W, midy * scaleY);
    ctx.stroke();
  }

  ctx.setLineDash([]);

  // 모든 dot들을 연결하는 점선 그리기
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.strokeStyle = 'rgba(100,100,100,0.4)';
  ctx.beginPath();
  let firstPoint = true;
  for(const kp of currentKeypoints) {
    const pt = P[kp.key];
    if(!pt) continue;
    const x = pt.x * scaleX;
    const y = pt.y * scaleY;
    if(firstPoint) {
      ctx.moveTo(x, y);
      firstPoint = false;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // 점 그리기 (orientation에 맞는 키포인트 사용)
  for(const kp of currentKeypoints) {
    const pt = P[kp.key];
    if(!pt) continue;
    const isSelected = editMode && selectedPoint === kp.key;
    drawHandle(pt.x * scaleX, pt.y * scaleY, kp.key, kp.color, isSelected);
  }
  
  // 좌표 수정 모드에서 선택된 점이 있고 아직 생성되지 않았다면 안내 표시
  if(editMode && selectedPoint && !P[selectedPoint]) {
    const W = cv.width / DPR, H = cv.height / DPR;
    ctx.fillStyle = 'rgba(124,156,255,0.7)';
    ctx.font = 'bold 16px "Noto Sans KR"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('좌표를 입력하고 "적용" 버튼을 클릭하세요', W / 2, H / 2);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
  }
  
  // 캘리브레이션 점 표시 (캘리브레이션 모드일 때)
  if(calibrationMode && S.calibrationPoint1) {
    ctx.fillStyle = '#ffb86c';
    ctx.strokeStyle = '#ffb86c';
    ctx.lineWidth = 2;
    
    // 점 1 표시
    const p1 = S.calibrationPoint1;
    ctx.beginPath();
    ctx.arc(p1.x * scaleX, p1.y * scaleY, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // 점 2가 있으면 표시하고 선 그리기
    if(S.calibrationPoint2) {
      const p2 = S.calibrationPoint2;
      ctx.beginPath();
      ctx.arc(p2.x * scaleX, p2.y * scaleY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // 두 점 사이 선 그리기
      ctx.beginPath();
      ctx.moveTo(p1.x * scaleX, p1.y * scaleY);
      ctx.lineTo(p2.x * scaleX, p2.y * scaleY);
      ctx.stroke();
    }
  }
}

function drawHandle(x, y, label, color, isSelected = false) {
  // 선택된 점은 더 크고 강조 표시
  const radius = isSelected ? 12 : 8;
  const strokeWidth = isSelected ? 3 : 2;
  
  // 선택된 점은 외곽 링 표시
  if(isSelected) {
    ctx.fillStyle = 'rgba(124,156,255,0.3)';
    ctx.beginPath();
    ctx.arc(x, y, radius + 4, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // 점을 더 크게 그리고 드래그 영역을 넓게
  ctx.fillStyle = color;
  ctx.strokeStyle = isSelected ? 'rgba(124,156,255,1)' : 'rgba(0,0,0,0.8)';
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.lineWidth = strokeWidth;
  ctx.stroke();
  ctx.font = '12px "Noto Sans KR"';
  const pad = 4;
  const tw = ctx.measureText(label).width;
  const th = 16;
  ctx.fillStyle = isSelected ? 'rgba(124,156,255,0.8)' : 'rgba(0,0,0,0.6)';
  ctx.fillRect(x + 10, y - 12, tw + pad * 2, th);
  ctx.fillStyle = '#e7eef7';
  ctx.fillText(label, x + 10 + pad, y + 1);
}

// 각도와 점수만 계산 (실시간 표시용, AI 분석 없음)
function computeMetricsOnly() {
  const S = sessions[cur];
  const P = getPts(cur);
  let cva = null, pelvic = null, knee = null;

  if(P.C7 && P.Tragus) {
    // CVA: C7 SP에서 시작하는 수평선과 C7 SP에서 Tragus로 가는 벡터 사이의 각도
    const dx = P.Tragus.x - P.C7.x;
    const dy = P.Tragus.y - P.C7.y;
    const angle = Math.atan2(dy, dx);
    let cvaDeg = rad2deg(angle);
    
    // CVA는 0~90도 범위로 정규화
    if(cvaDeg < 0) {
      cvaDeg = 180 + cvaDeg;
    }
    if(cvaDeg > 90) {
      cvaDeg = 180 - cvaDeg;
    }
    cva = cvaDeg;
  }
  if(P.ASIS && P.PSIS) {
    // TRUNK 각도: 수평선과 ASIS-PSIS 선 사이의 각도
    // ASIS에서 PSIS로 가는 벡터의 각도를 계산
    const dx = P.PSIS.x - P.ASIS.x;
    const dy = P.PSIS.y - P.ASIS.y;
    const angle = Math.atan2(dy, dx);
    let pelvicDeg = rad2deg(angle);
    
    // 수평선 기준으로 각도 정규화 (-90~90도 범위)
    // -176.4도는 180 + (-176.4) = 3.6도로 변환되어야 함
    // 각도를 -180~180 범위에서 -90~90 범위로 변환
    if(pelvicDeg < -90) {
      // -176.4도 같은 경우: 180 + (-176.4) = 3.6도
      pelvicDeg = 180 + pelvicDeg;
    } else if(pelvicDeg > 90) {
      // 176.4도 같은 경우: 176.4 - 180 = -3.6도
      pelvicDeg = pelvicDeg - 180;
    }
    
    pelvic = pelvicDeg;
  }
  if(P.Hip && P.Knee && P.Ankle) {
    knee = rad2deg(internalAngle(P.Hip, P.Knee, P.Ankle));
  }

  S.metrics = { cva, pelvic, knee };
  const score = computeScore(cva, pelvic, knee);
  S.score = score;
  
  // AI 분석은 하지 않음 (저장 버튼 클릭 시에만)
  
  updateDisplay();
  updateCompare();
  // 점수만 업데이트 (AI 분석 없음)
  const scoreEl = document.getElementById("totalScore");
  const reasonEl = document.getElementById("scoreReason");
  if(scoreEl && score) {
    scoreEl.textContent = score.score;
    if(score >= 85) {
      scoreEl.style.color = "#2ec4b6";
    } else if(score >= 70) {
      scoreEl.style.color = "#ffd166";
    } else {
      scoreEl.style.color = "#ff6b6b";
    }
  }
  if(reasonEl && score) {
    if(score.reasons && score.reasons.length > 0) {
      reasonEl.textContent = "감점 근거: " + score.reasons.join(", ");
    } else {
      reasonEl.textContent = "모든 측정값이 정상 범위 내에 있습니다.";
    }
  }
}

// 전체 계산 (AI 분석 포함) - 저장 버튼 클릭 시에만 호출
function computeAll() {
  const S = sessions[cur];
  const pxPerCm = S.pxPerCm || 50.0;
  
  // 측면 및 정면 키포인트를 Map 형태로 변환
  const sidePoints = {};
  const frontPoints = {};
  
  // 측면 키포인트
  for(const [key, value] of S.sidePoints.entries()) {
    if(value && value.x != null && value.y != null) {
      sidePoints[key] = { x: value.x, y: value.y };
    }
  }
  
  // 정면 키포인트
  for(const [key, value] of S.frontPoints.entries()) {
    if(value && value.x != null && value.y != null) {
      frontPoints[key] = { x: value.x, y: value.y };
    }
  }
  
  // 통합 분석 실행 (운동 추천 포함)
  const analysisResult = analyzePostureAutoWithRecommendation({
    sidePts: Object.keys(sidePoints).length > 0 ? sidePoints : null,
    frontPts: Object.keys(frontPoints).length > 0 ? frontPoints : null,
    pxPerCm: pxPerCm
  });
  
  // 통합 분석 결과 저장
  S.analysisResult = analysisResult;
  
  // 기존 호환성을 위한 처리
  const sideMetrics = analysisResult.side;
  const frontMetrics = analysisResult.front;
  
  // 측면 분석 결과가 있으면 기존 방식으로도 저장
  if(sideMetrics.status !== "not_available") {
    const cva = sideMetrics.CVA?.value_deg || null;
    const pelvic = sideMetrics.PTA?.value_deg || null;
    const knee = sideMetrics.KA?.value_deg || null;
    
    S.metrics = { 
      cva, 
      pelvic, 
      knee,
      fullMetrics: sideMetrics,
      orientation: "side"
    };
    
    const score = computeScore(cva, pelvic, knee);
    S.score = score;
    
    // AI 분석 실행
    const analysis = analyzeMuscles(cva, pelvic, knee, sideMetrics);
    S.analysis = analysis;
    
    updateDisplay();
    updateCompare();
    updateScoreAndAnalysis(score, cva, pelvic, knee, analysis);
    
  } else if(frontMetrics.status !== "not_available") {
    // 정면 분석만 있는 경우
    S.metrics = { 
      fullMetrics: frontMetrics,
      orientation: "front"
    };
    S.score = null;
    S.analysis = { 
      fullMetrics: frontMetrics,
      orientation: "front",
      comments: [],
      details: [],
      exercises: []
    };
    updateDisplay();
    updateCompare();
    displayFrontAnalysis(frontMetrics);
    // 전체 항목 표시를 위해 updateScoreAndAnalysis 호출
    updateScoreAndAnalysis(null, null, null, null, S.analysis);
  } else {
    // 분석 결과가 없는 경우
    S.metrics = {};
    S.score = null;
    S.analysis = null;
    updateDisplay();
    updateCompare();
    // 빈 데이터로 UI 초기화
    updateScoreAndAnalysis(null, null, null, null, null);
  }
}

// 정면 분석 결과 표시
function displayFrontAnalysis(fullMetrics) {
  const commentEl = document.getElementById("aiComment");
  const commentPanel = document.getElementById("aiCommentPanel");
  
  if(!fullMetrics || Object.keys(fullMetrics).length === 0) {
    commentPanel.style.display = "none";
    return;
  }
  
  let commentText = "📷 정면 자세 분석 결과:\n\n";
  const details = [];
  
  for(const [key, value] of Object.entries(fullMetrics)) {
    if(value && value.value_deg != null) {
      const statusText = {
        "normal": "✅ 정상",
        "mild": "⚠️ 경미",
        "moderate": "⚠️ 중등도",
        "severe": "🔴 심각"
      }[value.status] || value.status;
      
      commentText += `${key}: ${value.value_deg.toFixed(1)}° (${statusText})\n`;
      details.push(`• ${value.meaning || key}`);
    } else if(value && value.value_cm != null) {
      const statusText = {
        "normal": "✅ 정상",
        "mild": "⚠️ 경미",
        "moderate": "⚠️ 중등도",
        "severe": "🔴 심각"
      }[value.status] || value.status;
      
      commentText += `${key}: ${value.value_cm.toFixed(2)}cm (${statusText})\n`;
      details.push(`• ${value.meaning || key}`);
    }
  }
  
  if(details.length > 0) {
    commentText += "\n" + details.join("\n");
  }
  
  commentEl.innerHTML = commentText.replace(/\n/g, '<br>');
  commentPanel.style.display = "block";
  
}


// 전체 분석 항목 기준으로 체형 종합 점수 계산
function computeScoreFromFullMetrics(fullMetrics) {
  if(!fullMetrics || Object.keys(fullMetrics).length === 0) {
    return { score: null, reasons: [], penalties: 0 };
  }
  
  let penalties = 0;
  let reasons = [];
  
  // 1. CVA (Craniovertebral Angle) - 정상 ≥50°
  const cva = fullMetrics.CVA?.value;
  if(cva != null) {
    if(cva < 50) {
      const delta = 50 - cva;
      const penalty = Math.min(40, delta * 1.6);
      penalties += penalty;
      reasons.push(`CVA ${cva.toFixed(1)}° (정상 ≥50°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 2. HPD (Head Protrusion Distance) - 정상 ≤2cm
  const hpd = fullMetrics.HPD?.value;
  if(hpd != null && hpd > 2) {
    const delta = hpd - 2;
    const penalty = Math.min(20, delta * 5);
    penalties += penalty;
    reasons.push(`HPD ${hpd.toFixed(1)}cm (정상 ≤2cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 3. NIA (Neck Inclination Angle) - 정상 0-20°
  const nia = fullMetrics.NIA?.value;
  if(nia != null && nia > 20) {
    const delta = nia - 20;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`NIA ${nia.toFixed(1)}° (정상 0-20°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 4. TIA (Trunk Inclination Angle) - 정상 0-10°
  const tia = fullMetrics.TIA?.value;
  if(tia != null && tia > 10) {
    const delta = tia - 10;
    const penalty = Math.min(20, delta * 2);
    penalties += penalty;
    reasons.push(`TIA ${tia.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 5. SAA (Scapular Alignment Angle) - 정상 0-10°
  const saa = fullMetrics.SAA?.value;
  if(saa != null && saa > 10) {
    const delta = saa - 10;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`SAA ${saa.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 6. PTA (Pelvic Tilt Angle) - 정상 0-15°
  const pta = fullMetrics.PTA?.value;
  if(pta != null) {
    if(pta > 15) {
      const delta = pta - 15;
      const penalty = Math.min(30, delta * 2);
      penalties += penalty;
      reasons.push(`PTA ${pta.toFixed(1)}° (정상 0-15°) - ${penalty.toFixed(0)}점 감점`);
    } else if(pta < 0) {
      const delta = Math.abs(pta);
      const penalty = Math.min(20, delta * 2);
      penalties += penalty;
      reasons.push(`PTA ${pta.toFixed(1)}° (정상 0-15°, 후방 경사) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 7. KA (Knee Alignment Angle) - 정상 175-185°
  const ka = fullMetrics.KA?.value;
  if(ka != null) {
    if(ka < 175) {
      const delta = 175 - ka;
      const penalty = Math.min(25, delta * 2.5);
      penalties += penalty;
      reasons.push(`KA ${ka.toFixed(1)}° (정상 175-185°) - ${penalty.toFixed(0)}점 감점`);
    } else if(ka > 185) {
      const delta = ka - 185;
      const penalty = Math.min(25, delta * 2.5);
      penalties += penalty;
      reasons.push(`KA ${ka.toFixed(1)}° (정상 175-185°, 과신전) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 8. Tibial Angle - 정상 0-10°
  const tibial = fullMetrics.Tibial_Angle?.value;
  if(tibial != null && tibial > 10) {
    const delta = tibial - 10;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`Tibial ${tibial.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 9. Q-Angle - 정상 10-20° (남성 10-15°, 여성 15-20°)
  const qAngle = fullMetrics.Q_Angle?.value;
  if(qAngle != null) {
    if(qAngle < 10) {
      const delta = 10 - qAngle;
      const penalty = Math.min(15, delta * 1.5);
      penalties += penalty;
      reasons.push(`Q-Angle ${qAngle.toFixed(1)}° (정상 10-20°) - ${penalty.toFixed(0)}점 감점`);
    } else if(qAngle > 20) {
      const delta = qAngle - 20;
      const penalty = Math.min(20, delta * 2);
      penalties += penalty;
      reasons.push(`Q-Angle ${qAngle.toFixed(1)}° (정상 10-20°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 10. Knee Deviation - 정상 0-3°
  const kneeDev = fullMetrics.Knee_Deviation?.value;
  if(kneeDev != null && kneeDev > 3) {
    const delta = kneeDev - 3;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`Knee Dev ${kneeDev.toFixed(1)}° (정상 0-3°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 11. LLD (Leg Length Discrepancy) - 정상 ≤1cm
  const lld = fullMetrics.LLD?.value;
  if(lld != null && lld > 1) {
    const delta = lld - 1;
    const penalty = Math.min(25, delta * 10);
    penalties += penalty;
    reasons.push(`LLD ${lld.toFixed(1)}cm (정상 ≤1cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 12. GSB (Global Sagittal Balance) - 정상 ≤2cm
  const gsb = fullMetrics.GSB?.value;
  if(gsb != null && gsb > 2) {
    const delta = gsb - 2;
    const penalty = Math.min(20, delta * 5);
    penalties += penalty;
    reasons.push(`GSB ${gsb.toFixed(1)}cm (정상 ≤2cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 13. BVA (Body Vertical Alignment) - 정상 ≤2cm
  const bva = fullMetrics.BVA?.value;
  if(bva != null && bva > 2) {
    const delta = bva - 2;
    const penalty = Math.min(20, delta * 5);
    penalties += penalty;
    reasons.push(`BVA ${bva.toFixed(1)}cm (정상 ≤2cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 14. SCI (Spinal Curvature Index) - 정상 0.15-0.35
  const sci = fullMetrics.SCI?.value;
  if(sci != null) {
    if(sci < 0.15) {
      const delta = 0.15 - sci;
      const penalty = Math.min(15, delta * 50);
      penalties += penalty;
      reasons.push(`SCI ${sci.toFixed(2)} (정상 0.15-0.35, 만곡 부족) - ${penalty.toFixed(0)}점 감점`);
    } else if(sci > 0.35) {
      const delta = sci - 0.35;
      const penalty = Math.min(15, delta * 50);
      penalties += penalty;
      reasons.push(`SCI ${sci.toFixed(2)} (정상 0.15-0.35, 과만곡) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 15. HPA (Head–Pelvis Angle) - 정상 0-10°
  const hpa = fullMetrics.HPA?.value;
  if(hpa != null && hpa > 10) {
    const delta = hpa - 10;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`HPA ${hpa.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // PDS는 별도로 계산되므로 여기서는 제외
  
  const score = Math.round(clamp(100 - penalties, 0, 100));
  return { score, reasons, penalties };
}

// 기존 호환성을 위한 함수 (하위 호환)
function computeScore(cva, pelvic, knee) {
  // fullMetrics가 없으면 기존 방식 사용
  const S = sessions[cur];
  const fullMetrics = S.metrics?.fullMetrics;
  if(fullMetrics && Object.keys(fullMetrics).length > 0) {
    return computeScoreFromFullMetrics(fullMetrics);
  }
  
  // 기존 방식 (fallback)
  let penalties = 0;
  let reasons = [];
  
  if(cva != null) {
    const target = 50;
    const delta = Math.max(0, target - cva);
    const penalty = Math.min(40, delta * 1.6);
    penalties += penalty;
    if(penalty > 0) {
      reasons.push(`CVA ${cva.toFixed(1)}° (목표 ${target}°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  if(pelvic != null) {
    const abs = Math.abs(pelvic);
    const target = 0;
    const penalty = Math.min(30, abs * 2.0);
    penalties += penalty;
    if(penalty > 0) {
      reasons.push(`골반 기울기 ${pelvic.toFixed(1)}° (목표 ${target}°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  if(knee != null) {
    const target = 180;
    const delta = Math.max(0, target - knee);
    const penalty = Math.min(30, delta * 1.0);
    penalties += penalty;
    if(penalty > 0) {
      reasons.push(`무릎 각 ${knee.toFixed(1)}° (목표 ${target}°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  const score = Math.round(clamp(100 - penalties, 0, 100));
  return { score, reasons, penalties };
}

function analyzeMuscles(cva, pelvic, knee, fullMetrics = null) {
  const tight = [];
  const weak = [];
  const comments = [];
  const details = [];
  const exercises = [];
  
  // ⚙️ 해석 요약 패턴 분석
  const patterns = [];
  
  // 패턴 1: 거북목(FHP): CVA↓, NIA↑, HPD↑
  if(fullMetrics) {
    const cvaVal = fullMetrics.CVA?.value_deg;
    const niaVal = fullMetrics.NIA?.value_deg;
    const hpdVal = fullMetrics.HPD?.value_cm;
    
    if(cvaVal != null && cvaVal < 50 && niaVal != null && niaVal > 20 && hpdVal != null && hpdVal > 2) {
      patterns.push({
        name: "거북목(FHP)",
        description: `CVA↓(${cvaVal.toFixed(1)}°), NIA↑(${niaVal.toFixed(1)}°), HPD↑(${hpdVal.toFixed(1)}cm)`,
        meaning: "경추 신전, 심부 굴근 약화",
        priority: "high"
      });
      tight.push('상부승모근', '견갑거근', 'SCM', '흉쇄유돌근');
      weak.push('심부경부굴근', '전거근');
    }
    
    // 패턴 2: 라운드 숄더(RSP): acromion 전방 이동, SAA↑
    const saaVal = fullMetrics.SAA?.value_deg;
    if(saaVal != null && saaVal > 10) {
      patterns.push({
        name: "라운드 숄더(RSP)",
        description: `SAA↑(${saaVal.toFixed(1)}°)`,
        meaning: "흉근 단축, 하부승모 약화",
        priority: "high"
      });
      tight.push('흉근', '소흉근');
      weak.push('하부승모', '전거근', '중부승모');
    }
    
    // 패턴 3: 과전경사 골반: PTA↑ (>15°), ASIS↓(하강)
    const ptaVal = fullMetrics.PTA?.value_deg;
    if(ptaVal != null && ptaVal > 15) {
      patterns.push({
        name: "과전경사 골반(Anterior Tilt)",
        description: `PTA↑(${ptaVal.toFixed(1)}°)`,
        meaning: "요추 전만 증가, hip flexor 단축",
        priority: "high"
      });
      tight.push('장요근', '요추기립근', '대퇴직근', '흉요근막');
      weak.push('복횡근', '둔근', '대둔근', '중둔근', '하둔근');
    }
    
    // 패턴 4: 후경사 골반: PTA↓ (<5°), PSIS↓(하강)
    if(ptaVal != null && ptaVal < 5) {
      patterns.push({
        name: "후경사 골반(Posterior Tilt)",
        description: `PTA↓(${ptaVal.toFixed(1)}°)`,
        meaning: "햄스트링/복근 단축",
        priority: "medium"
      });
      tight.push('햄스트링', '복직근', '복횡근');
      weak.push('장요근', '요추기립근');
    }
    
    // 패턴 5: X자 다리(Valgus): KA↓ (<175°), Q-angle↑
    const kaVal = fullMetrics.KA?.value_deg;
    const qAngleVal = fullMetrics.Q_Angle?.value_deg;
    if(kaVal != null && kaVal < 175) {
      patterns.push({
        name: "X자 다리(Valgus)",
        description: `KA↓(${kaVal.toFixed(1)}°)${qAngleVal != null ? `, Q-angle↑(${qAngleVal.toFixed(1)}°)` : ''}`,
        meaning: "내측 무릎 부하 증가",
        priority: "high"
      });
      tight.push('대퇴내전근', '비복근');
      weak.push('대둔근', '중둔근', '대퇴외전근');
    }
    
    // 패턴 6: O자 다리(Varus): KA↑ (>180°)
    if(kaVal != null && kaVal > 180) {
      patterns.push({
        name: "O자 다리(Varus)",
        description: `KA↑(${kaVal.toFixed(1)}°)`,
        meaning: "외측 무릎 부하 증가",
        priority: "high"
      });
      tight.push('대퇴외전근', '비복근');
      weak.push('대둔근', '중둔근', '대퇴내전근');
    }
    
    // 패턴 7: 체중 중심 전방 이동: BVA↑, GSB↑
    const bvaVal = fullMetrics.BVA?.value_deg;
    const gsbVal = fullMetrics.GSB?.value_cm;
    if(bvaVal != null && bvaVal > 2 && gsbVal != null && gsbVal > 2) {
      patterns.push({
        name: "체중 중심 전방 이동",
        description: `BVA↑(${bvaVal.toFixed(1)}°), GSB↑(${gsbVal.toFixed(1)}cm)`,
        meaning: "요추 전만, 종골 스트레스",
        priority: "medium"
      });
      tight.push('장요근', '요추기립근');
      weak.push('복횡근', '둔근');
    }
    
    // 패턴 8: 체중 중심 후방 이동: BVA↓, GSB↓
    if(bvaVal != null && bvaVal < -2 || (gsbVal != null && gsbVal < -2)) {
      patterns.push({
        name: "체중 중심 후방 이동",
        description: `BVA↓(${bvaVal.toFixed(1)}°), GSB↓(${gsbVal.toFixed(1)}cm)`,
        meaning: "둔근 긴장, 햄스트링 단축",
        priority: "medium"
      });
      tight.push('둔근', '햄스트링');
      weak.push('대퇴사두근', '장요근');
    }
    
    // 패턴 정보를 comments에 추가
    if(patterns.length > 0) {
      comments.push(`\n📊 자세 패턴 분석:`);
      patterns.forEach((p, idx) => {
        comments.push(`${idx + 1}. ${p.name}: ${p.description} → ${p.meaning}`);
      });
    }
  }
  
  // CVA 분석 (상세)
  // CVA >= 50도는 정상 범위
  if(cva != null) {
    if(cva >= 50) {
      // 50도 이상이면 정상 범위
      if(cva <= 55) {
        comments.push(`경추 정렬 양호: CVA ${cva.toFixed(1)}° (정상 범위)`);
        details.push(`• 경추 정렬이 양호한 상태입니다.`);
        details.push(`• 현재 상태를 유지하기 위한 정기적인 스트레칭을 권장합니다.`);
      } else {
        // 55도 초과는 후방 경사 (과도한 경우)
        comments.push(`경추 후방 경사: CVA ${cva.toFixed(1)}°로 정상 범위를 초과합니다.`);
        details.push(`• 경추가 과도하게 후방으로 기울어져 있습니다.`);
        exercises.push('1. 경추 전방 굴곡 운동: 천천히 턱을 가슴 방향으로 내리기 (10회×2세트)');
      }
    } else {
      // 50도 미만은 전방두 자세
      if(cva < 45) {
        tight.push('상부승모근', '견갑거근', 'SCM', '흉쇄유돌근');
        weak.push('심부경부굴근', '하부승모근', '전거근');
        comments.push(`전방두 자세 심각: CVA ${cva.toFixed(1)}°로 정상 범위(≥50°)보다 ${(50-cva).toFixed(1)}° 낮습니다.`);
        details.push(`• 상부승모근과 견갑거근이 지속적으로 수축되어 목과 어깨 통증을 유발할 수 있습니다.`);
        details.push(`• 심부경부굴근이 약화되어 머리 무게를 지지하지 못해 전방 이동이 가속화됩니다.`);
        details.push(`• 장기적으로 경추 디스크 압력 증가 및 두통, 어깨 뻣뻣함이 발생할 수 있습니다.`);
        exercises.push('1. 턱 당기기 운동: 벽에 등을 대고 턱을 뒤로 당기며 10초 유지 (3세트)');
        exercises.push('2. 심부경부굴근 활성화: 누워서 턱을 가슴에 가깝게 당기며 머리만 살짝 들어올리기 (10회×3세트)');
        exercises.push('3. 하부승모근 강화: 팔을 30도 각도로 올리며 어깨뼈를 아래로 눌러 모으기 (15회×3세트)');
        exercises.push('4. 상부승모근 스트레칭: 머리를 옆으로 기울여 반대편 어깨 방향으로 스트레칭 (좌우 각 30초)');
      } else {
        tight.push('상부승모근', '견갑거근');
        weak.push('심부경부굴근');
        comments.push(`전방두 자세 경미: CVA ${cva.toFixed(1)}°로 정상 범위(≥50°)에 근접합니다.`);
        details.push(`• 상부승모근과 견갑거근에 약간의 긴장이 있습니다.`);
        details.push(`• 심부경부굴근 활성화가 필요합니다.`);
        exercises.push('1. 턱 당기기 운동: 벽에 등을 대고 턱을 뒤로 당기기 (10초×3세트)');
        exercises.push('2. 심부경부굴근 강화: 누워서 머리만 살짝 들어올리기 (10회×2세트)');
        exercises.push('3. 상부승모근 스트레칭: 좌우 각 30초씩 스트레칭');
      }
    }
  }
  
  // 골반 기울기 분석 (상세)
  if(pelvic != null) {
    const abs = Math.abs(pelvic);
    if(abs > 5) {
      if(pelvic > 0) {
        tight.push('장요근', '요추기립근', '대퇴직근', '흉요근막');
        weak.push('복횡근', '둔근', '대둔근', '중둔근', '하둔근');
        comments.push(`골반 전방경사 심각: ${pelvic.toFixed(1)}°로 목표 0°보다 ${pelvic.toFixed(1)}° 큽니다.`);
        details.push(`• 장요근이 단축되어 골반을 앞으로 당기고 있습니다.`);
        details.push(`• 요추 전만이 증가하여 허리 통증 위험이 높습니다.`);
        details.push(`• 복횡근과 둔근이 약화되어 골반 안정성이 떨어집니다.`);
        exercises.push('1. 장요근 스트레칭: 한쪽 무릎을 앞으로 내밀고 반대편 다리를 뒤로 뻗어 스트레칭 (좌우 각 30초×3회)');
        exercises.push('2. 둔근 강화: 누워서 엉덩이를 들어올리며 둔근 수축 (15회×3세트)');
        exercises.push('3. 복횡근 활성화: 네 발로 엎드려서 복부를 안으로 당기며 호흡 (10회×3세트)');
        exercises.push('4. 힙 브릿지: 누워서 무릎을 구부리고 엉덩이를 들어올리기 (15회×3세트)');
      } else {
        tight.push('둔근', '햄스트링', '요추신근');
        weak.push('복직근', '장요근', '대퇴사두근');
        comments.push(`골반 후방경사: ${pelvic.toFixed(1)}°로 목표 0°보다 작습니다.`);
        details.push(`• 둔근과 햄스트링이 과도하게 긴장되어 있습니다.`);
        details.push(`• 복직근과 장요근이 약화되어 골반이 뒤로 기울어집니다.`);
        exercises.push('1. 둔근 스트레칭: 앉아서 한쪽 무릎을 가슴에 당기기 (좌우 각 30초)');
        exercises.push('2. 햄스트링 스트레칭: 다리를 뻗고 앞으로 숙이기 (30초×3회)');
        exercises.push('3. 복직근 강화: 크런치 운동 (15회×3세트)');
        exercises.push('4. 장요근 강화: 무릎 당기기 운동 (10회×3세트)');
      }
    } else {
      comments.push(`골반 정렬 양호: ${pelvic.toFixed(1)}°`);
      details.push(`• 골반 정렬이 양호한 상태입니다.`);
    }
  }
  
  // 무릎 각도 분석 (상세)
  if(knee != null) {
    if(knee < 175) {
      if(knee < 165) {
        tight.push('햄스트링', '비복근', '가자미근', '슬와근');
        weak.push('대퇴사두근', '둔근', '대퇴직근');
        comments.push(`무릎 과굴곡 심각: ${knee.toFixed(1)}°로 목표 180°보다 ${(180-knee).toFixed(1)}° 낮습니다.`);
        details.push(`• 햄스트링과 비복근이 심각하게 단축되어 무릎을 구부리고 있습니다.`);
        details.push(`• 대퇴사두근이 약화되어 무릎을 펴지 못합니다.`);
        details.push(`• 장기적으로 무릎 관절 압력 증가 및 전방 십자인대 부상 위험이 있습니다.`);
        exercises.push('1. 햄스트링 스트레칭: 서서 다리를 올리고 앞으로 숙이기 (좌우 각 30초×3회)');
        exercises.push('2. 비복근 스트레칭: 벽에 손을 대고 한쪽 다리를 뒤로 내밀며 스트레칭 (좌우 각 30초)');
        exercises.push('3. 대퇴사두근 강화: 의자에 앉아 다리를 펴며 무릎 락 (10초 유지×10회)');
        exercises.push('4. 스쿼트: 천천히 앉았다 일어서기 (10회×3세트)');
      } else {
        tight.push('햄스트링', '비복근');
        weak.push('대퇴사두근');
        comments.push(`무릎 약간 굴곡: ${knee.toFixed(1)}°로 목표에 근접합니다.`);
        details.push(`• 햄스트링과 비복근에 약간의 긴장이 있습니다.`);
        details.push(`• 대퇴사두근 강화가 필요합니다.`);
        exercises.push('1. 햄스트링 스트레칭: 좌우 각 30초씩 스트레칭');
        exercises.push('2. 대퇴사두근 강화: 의자에 앉아 다리 펴기 (10회×2세트)');
        exercises.push('3. 스쿼트: 10회×2세트');
      }
    } else if(knee <= 185) {
      comments.push(`무릎 정렬 양호: ${knee.toFixed(1)}°`);
      details.push(`• 무릎 정렬이 양호한 상태입니다.`);
    } else {
      comments.push(`무릎 과신전: ${knee.toFixed(1)}°로 목표를 초과합니다.`);
      details.push(`• 무릎이 과도하게 펴져 있어 후방 십자인대 부상 위험이 있습니다.`);
      exercises.push('1. 무릎 미세 굴곡 연습: 서서 무릎을 살짝 구부리기 (10회×2세트)');
      exercises.push('2. 대퇴사두근 이완: 누워서 무릎 아래에 베개를 넣고 스트레칭');
    }
  }
  
  // 종합 운동 추천
  if(exercises.length === 0 && (tight.length > 0 || weak.length > 0)) {
    exercises.push('1. 전신 스트레칭: 매일 아침 10분간 전신 스트레칭');
    exercises.push('2. 코어 강화: 플랭크 30초 유지 (3세트)');
    exercises.push('3. 자세 교정 운동: 벽에 등을 대고 서서 몸 정렬 유지 (1분×3회)');
  }
  
  // 필라테스 추천
  const pilates = recommendPilates([...new Set(tight)], [...new Set(weak)]);
  
  return { 
    tight: [...new Set(tight)], 
    weak: [...new Set(weak)], 
    comments,
    details,
    exercises: [...new Set(exercises)],
    pilates
  };
}

// 체형 유형 분석 함수
function analyzePostureType(metrics) {
  if(!metrics || Object.keys(metrics).length === 0) {
    return "분석 데이터가 충분하지 않습니다.";
  }
  
  let analysis = [];
  let summarySection = '';
  let detailSections = [];
  let recommendations = [];
  
  // 측정값 추출
  const cva = metrics.CVA?.value;
  const hpd = metrics.HPD?.value;
  const nia = metrics.NIA?.value;
  const pta = metrics.PTA?.value;
  const tia = metrics.TIA?.value;
  const ka = metrics.KA?.value;
  const lld = metrics.LLD?.value;
  const bva = metrics.BVA?.value;
  const gsb = metrics.GSB?.value;
  const sci = metrics.SCI?.value;
  const hpa = metrics.HPA?.value;
  const qAngle = metrics['Q_Angle']?.value;
  const kneeDev = metrics['Knee_Deviation']?.value;
  const pds = metrics.PDS?.value;
  const pdsStatus = metrics.PDS?.status;
  
  // 문제 카운트
  let issueCount = 0;
  
  // === 1. 거북목 자세 (Forward Head Posture) ===
  if(cva != null && cva < 50) {
    issueCount++;
    const severity = cva < 40 ? '심각' : cva < 45 ? '중등도' : '경미';
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:13px;">📍 거북목 자세 (Forward Head Posture) - ${severity}</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>현재 상태:</strong> CVA ${cva.toFixed(1)}° (정상: ≥50°), HPD ${hpd != null ? hpd.toFixed(1) + 'cm' : '미측정'}<br>
          <strong>주요 원인:</strong> 장시간 스마트폰·컴퓨터 사용, 잘못된 베개 높이, 깊은 근육(Deep neck flexor) 약화<br>
          <strong>발생 증상:</strong> 
          • 목뒤 통증 및 경직 (Upper trapezius, Levator scapulae 긴장)
          • 두통 (Tension headache), 어지럼증
          • 어깨 결림 및 날개뼈 통증
          • 턱관절 장애(TMJ disorder) 유발 가능<br>
          <strong>근육 불균형:</strong>
          • 긴장된 근육: 상부 승모근, 견갑거근, 흉쇄유돌근, 후두하근
          • 약화된 근육: 심부 경추 굴곡근(Longus colli, capitis), 하부 승모근<br>
          <strong>교정 방향:</strong>
          ① 턱당김 운동(Chin tuck): 심부 경추 굴곡근 강화
          ② 흉추 신전 운동: 등 윗부분 유연성 확보
          ③ 견갑골 후인 운동: 어깨를 뒤로 당기는 근육 강화
          ④ 작업 환경 개선: 모니터 눈높이 조정, 스마트폰 사용 자세 개선<br>
          <strong>주의사항:</strong> 급격한 교정 시도는 경추 디스크에 무리를 줄 수 있으므로 점진적으로 접근해야 합니다.
        </div>
      </div>
    `);
  }
  
  // === 2. 골반 경사 문제 ===
  if(pta != null && (pta > 15 || pta < 0)) {
    issueCount++;
    if(pta > 15) {
      const severity = pta > 25 ? '심각' : pta > 20 ? '중등도' : '경미';
      detailSections.push(`
        <div style="border-left:3px solid #ffb86c; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffb86c; font-size:13px;">📍 골반 전방 경사 (Anterior Pelvic Tilt) - ${severity}</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> PTA ${pta.toFixed(1)}° (정상: 0-15°)<br>
            <strong>주요 원인:</strong> 장시간 앉아있는 생활, 하이힐 착용, 복부 근력 약화, 임신 후 회복 부족<br>
            <strong>발생 증상:</strong>
            • 요추 과전만(Hyperlordosis)으로 인한 만성 요통
            • 하복부 돌출 (pseudo-pregnancy appearance)
            • 엉덩이가 뒤로 튀어나온 자세
            • 고관절 굴곡근(Hip flexor) 단축으로 인한 보행 장애<br>
            <strong>근육 불균형:</strong>
            • 긴장·단축된 근육: 장요근(Iliopsoas), 대퇴직근(Rectus femoris), 척추기립근(Erector spinae)
            • 약화·신장된 근육: 복직근(Rectus abdominis), 대둔근(Gluteus maximus), 햄스트링<br>
            <strong>교정 방향:</strong>
            ① 고관절 굴곡근 스트레칭: 런지 자세에서 장요근 늘리기
            ② 코어 강화: 플랭크, 데드버그(Dead bug) 운동
            ③ 대둔근 활성화: 브릿지, 힙 쓰러스트, 클램쉘
            ④ 골반 후방 경사 연습: 벽에 등대고 골반 중립 자세 학습<br>
            <strong>복합 증후군:</strong> Lower Cross Syndrome(하부 교차 증후군)의 핵심 특징입니다.
          </div>
        </div>
      `);
    } else if(pta < 0) {
      detailSections.push(`
        <div style="border-left:3px solid #ffb86c; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffb86c; font-size:13px;">📍 골반 후방 경사 (Posterior Pelvic Tilt)</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> PTA ${pta.toFixed(1)}° (정상: 0-15°)<br>
            <strong>주요 원인:</strong> 과도한 코어 운동, 장시간 구부정한 앉은 자세, 햄스트링 과긴장<br>
            <strong>발생 증상:</strong>
            • 평평한 허리(Flat back)로 인한 충격 흡수 감소
            • 골반저근 기능 저하
            • 엉덩이 편평화, 하체 혈액순환 저하<br>
            <strong>교정 방향:</strong>
            ① 햄스트링 스트레칭
            ② 대둔근·척추기립근 강화
            ③ 골반 전방 경사 연습 (단, 과하지 않게)
          </div>
        </div>
      `);
    }
  }
  
  // === 3. 상부 교차 증후군 (Upper Cross Syndrome) 체크 ===
  const hasUpperCross = (cva != null && cva < 50) && (nia != null && nia > 20);
  if(hasUpperCross) {
    issueCount++;
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px; background:rgba(255,107,107,0.05); padding:10px;">
        <strong style="color:#ff6b6b; font-size:13px;">⚠️ 상부 교차 증후군 (Upper Cross Syndrome) 의심</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>증후군 설명:</strong> 거북목과 둥근 어깨가 동시에 나타나는 현대인의 대표적 자세 불균형 패턴입니다.<br>
          <strong>전형적 특징:</strong>
          • 머리 전방 돌출 (CVA: ${cva.toFixed(1)}°)
          • 목 과도한 신전 (NIA: ${nia != null ? nia.toFixed(1) + '°' : '미측정'})
          • 흉추 후만 증가 (등이 굽음)
          • 어깨 전방 회전<br>
          <strong>교정 우선순위:</strong>
          ① 긴장 해소: 상부 승모근, 대흉근, 흉쇄유돌근 이완
          ② 활성화: 심부 경추 굴곡근, 중·하부 승모근, 전거근
          ③ 자세 교육: 앉은 자세에서 흉추 신전 유지
        </div>
      </div>
    `);
  }
  
  // === 4. 무릎 정렬 문제 ===
  if(ka != null && (ka > 185 || ka < 175)) {
    issueCount++;
    if(ka > 185) {
      const severity = ka > 195 ? '심각' : ka > 190 ? '중등도' : '경미';
      detailSections.push(`
        <div style="border-left:3px solid #ffd166; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffd166; font-size:13px;">📍 무릎 과신전 (Genu Recurvatum) - ${severity}</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> KA ${ka.toFixed(1)}° (정상: 175-185°)<br>
            <strong>주요 원인:</strong> 관절 과이완성(Joint hypermobility), 대퇴사두근 우세, 햄스트링 약화, 잘못된 서기 습관<br>
            <strong>발생 증상:</strong>
            • 무릎 후방 인대 과부하 (PCL, 후방 관절낭 스트레스)
            • 슬개골 압박 증가로 슬개대퇴 통증 증후군 위험
            • 무릎 불안정성, 장기적으로 조기 관절염 유발<br>
            <strong>교정 방향:</strong>
            ① 햄스트링 강화: 레그컬, 루마니안 데드리프트
            ② 대퇴사두근 과긴장 완화
            ③ 서기 자세 교정: 무릎을 살짝 구부린 상태 유지 연습
            ④ 고유수용성 훈련: 한 발 서기, 밸런스 보드<br>
            <strong>주의사항:</strong> 무릎을 "딱" 펴는 습관을 즉시 중단해야 합니다.
          </div>
        </div>
      `);
    } else {
      detailSections.push(`
        <div style="border-left:3px solid #ffd166; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffd166; font-size:13px;">📍 무릎 과굴곡 자세</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> KA ${ka.toFixed(1)}° (정상: 175-185°)<br>
            <strong>주요 원인:</strong> 햄스트링 과긴장, 종아리 근육 단축, 골반 후방 경사 동반<br>
            <strong>교정 방향:</strong> 햄스트링·종아리 스트레칭, 대퇴사두근 강화
          </div>
        </div>
      `);
    }
  }
  
  // === 5. 다리 길이 불균형 & 측만 위험 ===
  if(lld != null && lld > 1) {
    issueCount++;
    const severity = lld > 2 ? '심각' : lld > 1.5 ? '중등도' : '경미';
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:13px;">📍 다리 길이 불균형 (Leg Length Discrepancy) - ${severity}</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>현재 상태:</strong> LLD ${lld.toFixed(1)}cm (정상: ≤1cm)<br>
          <strong>구분:</strong>
          • 구조적 불균형: 실제 뼈 길이 차이 (X-ray 촬영 필요)
          • 기능적 불균형: 근육 불균형·골반 회전으로 인한 겉보기 차이<br>
          <strong>발생 증상:</strong>
          • 골반 기울어짐 → 척추 측만증(Scoliosis) 유발
          • 보행 시 비대칭 → 무릎·고관절·허리 통증
          • 한쪽 다리 피로 누적<br>
          <strong>교정 방향:</strong>
          ① 기능적 불균형: 골반 교정 운동, 중둔근(Gluteus medius) 강화, TFL·QL 스트레칭
          ② 구조적 불균형: 깔창(Heel lift) 사용 고려, 전문의 상담 필수<br>
          <strong>연쇄 반응:</strong> LLD → 골반 기울어짐 → 척추 측만 → 어깨 높이 차이 → 목 통증
        </div>
      </div>
    `);
  }
  
  // === 6. 전신 균형 문제 ===
  if((bva != null && bva > 2) || (gsb != null && gsb > 2)) {
    issueCount++;
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:13px;">📍 전신 정렬 불균형 (Global Postural Imbalance)</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>현재 상태:</strong> BVA ${bva != null ? bva.toFixed(1) + 'cm' : '미측정'}, GSB ${gsb != null ? gsb.toFixed(1) + 'cm' : '미측정'}<br>
          <strong>의미:</strong> 주요 관절들이 수직 중력선에서 크게 벗어나 있어 전신 근골격계에 과부하가 걸린 상태입니다.<br>
          <strong>발생 증상:</strong>
          • 쉽게 피로함, 장시간 서 있거나 걷기 힘듦
          • 만성 통증의 다발성 발생 (목, 어깨, 허리, 무릎 등)
          • 에너지 소모 증가, 호흡 효율 감소<br>
          <strong>교정 방향:</strong>
          ① 전체적인 자세 재정렬 프로그램 필요 (통합적 접근)
          ② 필라테스, 요가 등 전신 균형 운동
          ③ 전문가(물리치료사, 카이로프랙터) 상담 권장
        </div>
      </div>
    `);
  }
  
  // === 7. 척추 만곡 이상 ===
  if(sci != null && (sci < 0.15 || sci > 0.35)) {
    issueCount++;
    if(sci < 0.15) {
      detailSections.push(`
        <div style="border-left:3px solid #ffb86c; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffb86c; font-size:13px;">📍 척추 만곡 부족 (Hypolordosis / Flat Back)</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> SCI ${sci.toFixed(2)} (정상: 0.15-0.35)<br>
            <strong>의미:</strong> 척추의 자연스러운 S자 곡선이 부족하여 충격 흡수 능력이 저하된 상태<br>
            <strong>발생 증상:</strong> 허리 피로 증가, 디스크 압력 증가, 뻣뻣한 등<br>
            <strong>교정 방향:</strong> 척추 신전 운동(Cat-Cow, Cobra pose), 흉추 모빌리티 확보
          </div>
        </div>
      `);
    } else {
      detailSections.push(`
        <div style="border-left:3px solid #ffb86c; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffb86c; font-size:13px;">📍 척추 과만곡 (Hyperlordosis / Swayback)</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> SCI ${sci.toFixed(2)} (정상: 0.15-0.35)<br>
            <strong>의미:</strong> 척추 만곡이 과도하여 디스크와 후관절에 압박이 가중됨<br>
            <strong>발생 증상:</strong> 요통, 디스크 압박, 척추 불안정성<br>
            <strong>교정 방향:</strong> 코어 안정화, 골반 중립 자세 훈련, 과전만 감소 운동
          </div>
        </div>
      `);
    }
  }
  
  // === 종합 평가 및 요약 ===
  if(pds != null) {
    if(pdsStatus === 'normal') {
      summarySection = `<div style="background:rgba(46,196,182,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#2ec4b6; font-size:14px;">✓ 전반적으로 양호한 자세</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          대부분의 측정값이 정상 범위에 있습니다. (PDS: ${pds.toFixed(1)}점)<br>
          현재 상태를 유지하기 위해 규칙적인 스트레칭과 근력 운동을 지속하세요.
        </div>
      </div>`;
    } else if(pdsStatus === 'mild') {
      summarySection = `<div style="background:rgba(255,209,102,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#ffd166; font-size:14px;">⚠️ 경미한 자세 불균형</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          ${issueCount}개 항목에서 개선이 필요합니다. (PDS: ${pds.toFixed(1)}점)<br>
          지금부터 교정을 시작하면 단기간 내 개선이 가능한 수준입니다.
        </div>
      </div>`;
    } else if(pdsStatus === 'moderate') {
      summarySection = `<div style="background:rgba(255,184,108,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#ffb86c; font-size:14px;">⚠️ 중등도 자세 불균형</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          ${issueCount}개 항목에서 교정이 필요합니다. (PDS: ${pds.toFixed(1)}점)<br>
          체계적인 교정 운동 프로그램과 생활 습관 개선이 필요합니다.
        </div>
      </div>`;
    } else {
      summarySection = `<div style="background:rgba(255,107,107,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:14px;">🚨 심각한 자세 불균형</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          ${issueCount}개 항목에서 정상 범위를 벗어났습니다. (PDS: ${pds.toFixed(1)}점)<br>
          <strong>전문가 상담을 강력히 권장합니다.</strong> (물리치료사, 정형외과 전문의, 카이로프랙터)<br>
          방치 시 만성 통증 및 구조적 변형이 고착될 수 있습니다.
        </div>
      </div>`;
    }
  }
  
  // === 통합 권장사항 ===
  if(issueCount > 0) {
    recommendations.push(`
      <div style="background:rgba(124,156,255,0.08); padding:12px; border-radius:8px; margin-top:16px;">
        <strong style="color:#7c9cff; font-size:13px;">💡 통합 교정 권장사항</strong>
        <div style="margin-top:8px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>1. 일상생활 개선:</strong><br>
          • 작업 환경: 모니터 눈높이, 의자 높이, 책상 거리 조정<br>
          • 수면 자세: 경추 지지 베개, 옆으로 누워 자기<br>
          • 스마트폰: 눈높이까지 들고 보기, 사용 시간 제한<br><br>
          
          <strong>2. 운동 프로그램:</strong><br>
          • 매일: 스트레칭 10-15분 (긴장된 근육 이완)<br>
          • 주 3-4회: 근력 운동 30분 (약화된 근육 강화)<br>
          • 주 2-3회: 유산소 운동 30분 (전신 순환 개선)<br><br>
          
          <strong>3. 전문가 도움:</strong><br>
          • 물리치료: 수기 치료, 도수 치료, 운동 치료<br>
          • 필라테스/요가: 전문 강사의 1:1 교정 수업<br>
          • 정기 검진: 3-6개월마다 자세 재평가<br><br>
          
          <strong>4. 교정 순서:</strong><br>
          ① 1-2주차: 긴장된 근육 이완 (마사지, 폼롤러, 스트레칭)<br>
          ② 3-4주차: 약화된 근육 활성화 (저강도 운동)<br>
          ③ 5주차 이후: 점진적 강화 및 자세 통합 훈련
        </div>
      </div>
    `);
  }
  
  // === 최종 출력 조합 ===
  if(detailSections.length === 0) {
    return summarySection || "현재 자세는 전반적으로 양호합니다.";
  }
  
  return summarySection + detailSections.join('') + recommendations.join('');
}

function updateScoreAndAnalysis(scoreData, cva, pelvic, knee, analysis) {
  const scoreEl = document.getElementById("totalScore");
  const reasonEl = document.getElementById("scoreReason");
  const commentEl = document.getElementById("aiComment");
  const commentPanel = document.getElementById("aiCommentPanel");
  const musclePanel = document.getElementById("musclePanel");
  const tightList = document.getElementById("muscleTightList");
  const weakList = document.getElementById("muscleWeakList");
  const detailList = document.getElementById("muscleDetailList");
  const exercisePanel = document.getElementById("exercisePanel");
  const exerciseList = document.getElementById("exerciseList");
  const pilatesPanel = document.getElementById("pilatesPanel");
  const pilatesList = document.getElementById("pilatesList");
  const allMetricsList = document.getElementById("allMetricsList");
  const pdsValueEl = document.getElementById("pdsValue");
  
  // 전체 분석 항목 표시
  const S = sessions[cur];
  const fullMetrics = S.metrics?.fullMetrics || {};
  if(allMetricsList && fullMetrics) {
    const metricsOrder = [
      {key: 'CVA', name: 'CVA', unit: '°'},
      {key: 'HPD', name: 'HPD', unit: 'cm'},
      {key: 'NIA', name: 'NIA', unit: '°'},
      {key: 'TIA', name: 'TIA', unit: '°'},
      {key: 'SAA', name: 'SAA', unit: '°'},
      {key: 'PTA', name: 'PTA', unit: '°'},
      {key: 'KA', name: 'KA', unit: '°'},
      {key: 'Tibial_Angle', name: 'Tibial', unit: '°'},
      {key: 'Q_Angle', name: 'Q-Angle', unit: '°'},
      {key: 'Knee_Deviation', name: 'Knee Dev', unit: '°'},
      {key: 'LLD', name: 'LLD', unit: 'cm'},
      {key: 'GSB', name: 'GSB', unit: 'cm'},
      {key: 'BVA', name: 'BVA', unit: 'cm'},
      {key: 'SCI', name: 'SCI', unit: 'ratio'},
      {key: 'HPA', name: 'HPA', unit: '°'},
      {key: 'PDS', name: 'PDS', unit: 'score'}
    ];
    
    let html = '';
    metricsOrder.forEach(m => {
      const metric = fullMetrics[m.key];
      if(metric) {
        const value = metric.value !== undefined ? metric.value : (metric.value_deg !== undefined ? metric.value_deg : (metric.value_cm !== undefined ? metric.value_cm : null));
        const status = metric.status || 'unknown';
        const unit = metric.unit || m.unit;
        if(value !== null && value !== undefined) {
          const statusColor = status === 'normal' ? '#2ec4b6' : status === 'mild' ? '#ffd166' : status === 'moderate' ? '#ffb86c' : '#ff6b6b';
          const statusText = status === 'normal' ? '✓' : status === 'mild' ? '⚠' : status === 'moderate' ? '⚠⚠' : status === 'severe' ? '✗' : '?';
          html += `<div style="display:flex; justify-content:space-between; margin-bottom:3px; padding:2px 0;">
            <span style="color:var(--muted);">${m.name}:</span>
            <span style="color:${statusColor};">${value.toFixed(1)}${unit} ${statusText}</span>
          </div>`;
        }
      }
    });
    allMetricsList.innerHTML = html || '<div style="color:var(--muted);">분석 데이터 없음</div>';
    
    // PDS 표시
    if(fullMetrics.PDS && pdsValueEl) {
      const pds = fullMetrics.PDS.value;
      const pdsStatus = fullMetrics.PDS.status;
      const pdsColor = pdsStatus === 'normal' ? '#2ec4b6' : pdsStatus === 'mild' ? '#ffd166' : '#ff6b6b';
      pdsValueEl.textContent = `${pds.toFixed(1)} (${pdsStatus})`;
      pdsValueEl.style.color = pdsColor;
    } else if(pdsValueEl) {
      pdsValueEl.textContent = '—';
    }
  }
  
  // 전체 분석 항목 기준으로 점수 재계산 (fullMetrics가 있으면)
  if(fullMetrics && Object.keys(fullMetrics).length > 0) {
    const scoreResult = computeScoreFromFullMetrics(fullMetrics);
    if(scoreResult.score != null) {
      scoreData = scoreResult;
    }
  }
  
  if(scoreData && scoreData.score != null) {
    const score = scoreData.score;
    scoreEl.textContent = score;
    
    // 점수 색상
    if(score >= 85) {
      scoreEl.style.color = "#2ec4b6";
    } else if(score >= 70) {
      scoreEl.style.color = "#ffd166";
    } else {
      scoreEl.style.color = "#ff6b6b";
    }
    
    // 점수 근거
    if(scoreData.reasons && scoreData.reasons.length > 0) {
      reasonEl.textContent = "감점 근거: " + scoreData.reasons.join(", ");
    } else {
      reasonEl.textContent = "모든 측정값이 정상 범위 내에 있습니다.";
    }
  } else {
    scoreEl.textContent = "—";
    reasonEl.textContent = "";
  }
  
  // AI 코멘트 (더 상세하게)
  if(analysis && analysis.comments && analysis.comments.length > 0) {
    let commentText = analysis.comments.join(" ");
    if(analysis.details && analysis.details.length > 0) {
      commentText += "\n\n" + analysis.details.join("\n");
    }
    commentEl.innerHTML = commentText.replace(/\n/g, '<br>');
    commentPanel.style.display = "block";
    
    // 체형 유형 분석 추가
    const postureTypeContent = document.getElementById("postureTypeContent");
    if(postureTypeContent && fullMetrics) {
      let postureType = analyzePostureType(fullMetrics);
      postureTypeContent.innerHTML = postureType;
    }
  } else {
    commentPanel.style.display = "none";
  }
  
  // 근육 분석 (상세)
  if(analysis && (analysis.tight.length > 0 || analysis.weak.length > 0)) {
    if(analysis.tight.length > 0) {
      tightList.innerHTML = analysis.tight.join(", ").replace(/,/g, ', ');
    } else {
      tightList.textContent = "없음";
      tightList.style.color = "var(--muted)";
    }
    
    if(analysis.weak.length > 0) {
      weakList.innerHTML = analysis.weak.join(", ").replace(/,/g, ', ');
    } else {
      weakList.textContent = "없음";
      weakList.style.color = "var(--muted)";
    }
    
    // 상세 분석 표시
    if(analysis.details && analysis.details.length > 0) {
      detailList.innerHTML = analysis.details.join("<br>");
    } else {
      detailList.textContent = "상세 분석 없음";
    }
    
    musclePanel.style.display = "block";
  } else {
    musclePanel.style.display = "none";
  }
  
  // 운동 추천
  if(analysis && analysis.exercises && analysis.exercises.length > 0) {
    exerciseList.innerHTML = analysis.exercises.map(ex => `<div style="margin-bottom:6px;">${ex}</div>`).join("");
    exercisePanel.style.display = "block";
  } else {
    exercisePanel.style.display = "none";
  }
  
  // 필라테스 추천
  if(analysis && analysis.pilates && analysis.pilates.length > 0) {
    let pilatesHTML = '';
    analysis.pilates.forEach((item, idx) => {
      pilatesHTML += `<div style="margin-bottom:15px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;">`;
      pilatesHTML += `<div style="font-size:13px; font-weight:600; margin-bottom:6px; color:#9c88ff;">${idx + 1}. ${item.issue} (${item.muscles.join(', ')})</div>`;
      pilatesHTML += `<div style="font-size:11px; color:var(--muted); margin-bottom:6px;">${item.type === '긴장' ? '긴장 완화' : '강화'} 필요</div>`;
      const tools = ['매트', '리포머', '캐딜락', '체어', '바렐'];
      tools.forEach(tool => {
        if(item.pilates[tool] && item.pilates[tool].length > 0) {
          pilatesHTML += `<div style="margin-top:4px; font-size:11px;"><strong style="color:#9c88ff;">${tool}:</strong> <span style="color:var(--ink);">${item.pilates[tool].join(', ')}</span></div>`;
        }
      });
      pilatesHTML += `</div>`;
    });
    pilatesList.innerHTML = pilatesHTML;
    pilatesPanel.style.display = "block";
  } else {
    pilatesPanel.style.display = "none";
  }
}

function updateDisplay() {
  const M = sessions[cur].metrics;
  document.getElementById("dispCva").textContent = M.cva != null ? M.cva.toFixed(1) + "°" : "—";
  document.getElementById("dispPel").textContent = M.pelvic != null ? M.pelvic.toFixed(1) + "°" : "—";
  document.getElementById("dispKnee").textContent = M.knee != null ? M.knee.toFixed(1) + "°" : "—";
}

function fmtDeg(v) {
  return (v == null || isNaN(v)) ? "—" : v.toFixed(1) + "°";
}

function deltaStr(b, a, suf = "") {
  if(b == null || a == null || isNaN(b) || isNaN(a)) return "—";
  const d = a - b;
  const sign = d > 0 ? "+" : "";
  return sign + d.toFixed(1) + (suf || "");
}

function updateCompare() {
  const B = sessions.Before, A = sessions.After;
  
  // fullMetrics에서 16가지 항목 가져오기
  const bMetrics = B.metrics?.fullMetrics || {};
  const aMetrics = A.metrics?.fullMetrics || {};
  
  // 헬퍼 함수: 메트릭 값 가져오기
  const getMetricValue = (metrics, key) => {
    const metric = metrics[key];
    if(!metric) return null;
    return metric.value !== undefined ? metric.value : 
           (metric.value_deg !== undefined ? metric.value_deg : 
           (metric.value_cm !== undefined ? metric.value_cm : null));
  };
  
  // 16가지 항목 업데이트
  const compareItems = [
    {key: 'CVA', id: 'Cva', unit: '°'},
    {key: 'HPD', id: 'Hpd', unit: 'cm'},
    {key: 'NIA', id: 'Nia', unit: '°'},
    {key: 'TIA', id: 'Tia', unit: '°'},
    {key: 'SAA', id: 'Saa', unit: '°'},
    {key: 'PTA', id: 'Pta', unit: '°'},
    {key: 'KA', id: 'Ka', unit: '°'},
    {key: 'Tibial_Angle', id: 'Tibial', unit: '°'},
    {key: 'Q_Angle', id: 'Qangle', unit: '°'},
    {key: 'Knee_Deviation', id: 'Kneedev', unit: '°'},
    {key: 'LLD', id: 'Lld', unit: 'cm'},
    {key: 'GSB', id: 'Gsb', unit: 'cm'},
    {key: 'BVA', id: 'Bva', unit: 'cm'},
    {key: 'SCI', id: 'Sci', unit: ''},
    {key: 'HPA', id: 'Hpa', unit: '°'},
    {key: 'PDS', id: 'Pds', unit: ''}
  ];
  
  compareItems.forEach(item => {
    const vB = getMetricValue(bMetrics, item.key);
    const vA = getMetricValue(aMetrics, item.key);
    
    const elB = document.getElementById(`cmp${item.id}B`);
    const elA = document.getElementById(`cmp${item.id}A`);
    const elD = document.getElementById(`cmp${item.id}D`);
    
    if(elB && elA && elD) {
      if(vB != null) {
        elB.textContent = vB.toFixed(item.unit === '' ? 2 : 1) + item.unit;
      } else {
        elB.textContent = "—";
      }
      
      if(vA != null) {
        elA.textContent = vA.toFixed(item.unit === '' ? 2 : 1) + item.unit;
      } else {
        elA.textContent = "—";
      }
      
      if(vB != null && vA != null) {
        elD.textContent = deltaStr(vB, vA, item.unit);
      } else {
        elD.textContent = "—";
      }
    }
  });
  
  // 점수 비교 업데이트
  const sB = B.score ? B.score.score : null, sA = A.score ? A.score.score : null;
  const scoreElB = document.getElementById("cmpScoreB");
  const scoreElA = document.getElementById("cmpScoreA");
  const scoreElD = document.getElementById("cmpScoreD");
  
  if(scoreElB && scoreElA && scoreElD) {
    scoreElB.textContent = sB != null ? sB : "—";
    scoreElA.textContent = sA != null ? sA : "—";
    if(sB != null && sA != null) {
      scoreElD.textContent = deltaStr(sB, sA, "");
    } else {
      scoreElD.textContent = "—";
    }
  }
}

// 좌표 수정 모드 토글
const btnEditCoords = document.getElementById("btnEditCoords");
const coordEditPanel = document.getElementById("coordEditPanel");
if(btnEditCoords && coordEditPanel) {
  btnEditCoords.onclick = () => {
    editMode = !editMode;
    console.log("좌표 수정 모드:", editMode ? "활성" : "비활성");
    if(editMode) {
      // 원본 크기 저장
      if(originalCanvasSize.width === 0) {
        originalCanvasSize.width = cv.width / DPR;
        originalCanvasSize.height = cv.height / DPR;
        originalCanvasSize.styleWidth = parseFloat(cv.style.width) || cv.width / DPR;
        originalCanvasSize.styleHeight = parseFloat(cv.style.height) || cv.height / DPR;
      }
      coordEditPanel.style.display = "block";
      btnEditCoords.style.background = "rgba(124,156,255,0.4)";
      btnEditCoords.textContent = "✏️ 좌표 수정 모드 (활성)";
      // 확대 적용
      applyZoom();
    } else {
      // 원래 크기로 복원
      currentZoom = 1;
      coordEditPanel.style.display = "none";
      btnEditCoords.style.background = "rgba(124,156,255,0.2)";
      btnEditCoords.textContent = "✏️ 좌표 수정 모드";
      selectedPoint = null;
      const selectEl = document.getElementById("coordSelectPoint");
      const xEl = document.getElementById("coordX");
      const yEl = document.getElementById("coordY");
      const zoomEl = document.getElementById("zoomLevel");
      if(selectEl) selectEl.value = "";
      if(xEl) xEl.value = "";
      if(yEl) yEl.value = "";
      if(zoomEl) zoomEl.value = "1";
      // 원본 크기 초기화하여 다시 계산되도록
      originalCanvasSize.width = 0;
      originalCanvasSize.height = 0;
      originalCanvasSize.styleWidth = 0;
      originalCanvasSize.styleHeight = 0;
      // 원본 크기로 복원
      const S = sessions[cur];
      const orientation = S.poseData?.orientation || "side";
      const img = orientation === "front" ? S.imgFront : S.imgSide;
      if(img) {
        resizeCanvasFor(img);
      }
      draw(); // 다시 그리기
    }
  };
} else {
  console.error("좌표 수정 모드 요소를 찾을 수 없습니다:", {btnEditCoords, coordEditPanel});
}

// 확대 적용 함수
function applyZoom() {
  const S = sessions[cur];
  const orientation = S.poseData?.orientation || "side";
  const img = orientation === "front" ? S.imgFront : S.imgSide;
  
  if(!editMode || !img) {
    return;
  }
  
  const zoomEl = document.getElementById("zoomLevel");
  if(zoomEl) {
    const newZoom = parseInt(zoomEl.value) || 1;
    currentZoom = clamp(newZoom, 1, 4); // 1~4배로 제한
  }
  
  // 원본 이미지로 확대 적용 (비율 유지)
  resizeCanvasFor(img);
  
  // 좌표 입력 필드 업데이트
  if(selectedPoint) {
    const P = getPts(cur);
    const pt = P[selectedPoint];
    if(pt && coordX && coordY) {
      // 좌표는 항상 원본 크기 기준으로 표시
      coordX.value = pt.x.toFixed(1);
      coordY.value = pt.y.toFixed(1);
    }
  }
}

// 확대 배율 변경
const zoomLevel = document.getElementById("zoomLevel");
if(zoomLevel) {
  zoomLevel.addEventListener("change", () => {
    if(editMode) {
      applyZoom();
    }
  });
}

// 점 선택 드롭다운 변경
const coordSelectPoint = document.getElementById("coordSelectPoint");
const coordX = document.getElementById("coordX");
const coordY = document.getElementById("coordY");

// 점 선택 시 좌표 표시 함수
function updateCoordDisplay() {
  if(!coordX || !coordY) return;
  
  if(selectedPoint) {
    const P = getPts(cur);
    const pt = P[selectedPoint];
    if(pt) {
      // 원본 크기 기준 좌표 표시
      coordX.value = pt.x.toFixed(1);
      coordY.value = pt.y.toFixed(1);
    } else {
      // 점이 없으면 기본값 설정 (이미지가 있는 경우 중앙 근처)
      if(sessions[cur].img) {
        const originalW = originalCanvasSize.width || (cv.width / DPR);
        const originalH = originalCanvasSize.height || (cv.height / DPR);
        const defaultX = (originalW / 2).toFixed(1);
        const defaultY = (originalH / 2).toFixed(1);
        coordX.value = defaultX;
        coordY.value = defaultY;
      } else {
        coordX.value = "";
        coordY.value = "";
      }
    }
    draw();
  } else {
    coordX.value = "";
    coordY.value = "";
    draw();
  }
}

if(coordSelectPoint && coordX && coordY) {
  coordSelectPoint.addEventListener("change", e => {
    selectedPoint = e.target.value || null;
    console.log("선택된 점:", selectedPoint);
    updateCoordDisplay();
  });
  
  // 초기화 시에도 좌표 표시 업데이트 (점이 이미 선택되어 있으면)
  if(selectedPoint) {
    updateCoordDisplay();
  }
} else {
  console.error("좌표 입력 요소를 찾을 수 없습니다:", {coordSelectPoint, coordX, coordY});
}

// 드래그할 때도 좌표 업데이트를 위해 함수를 전역으로 노출
window.updateCoordDisplay = updateCoordDisplay;

// 좌표 적용 (저장 버튼 역할 - AI 분석 실행)
const coordApply = document.getElementById("coordApply");
if(coordApply) {
  coordApply.onclick = () => {
    if(!selectedPoint) {
      alert("점을 선택해주세요.");
      return;
    }
    const x = parseFloat(coordX.value);
    const y = parseFloat(coordY.value);
    if(isNaN(x) || isNaN(y)) {
      alert("올바른 좌표를 입력해주세요.");
      return;
    }
    // 좌표는 항상 원본 크기 기준으로 저장
    const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
    const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
    const orientation = sessions[cur].poseData?.orientation || "side";
    const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
    const clampedX = clamp(x, 0, originalW);
    const clampedY = clamp(y, 0, originalH);
    map.set(selectedPoint, {
      x: clampedX,
      y: clampedY
    });
    draw();
    // 저장 버튼이므로 AI 분석 실행
    computeAll();
    // 입력 필드 업데이트
    coordX.value = clampedX.toFixed(1);
    coordY.value = clampedY.toFixed(1);
    
    // 실시간 분석 실행
    if(typeof liveAnalyzer !== 'undefined') {
      liveAnalyzer.analyzeCurrentSession();
    }
    // 저장 후 원래 크기로 복원
    if(editMode) {
      currentZoom = 1;
      const zoomEl = document.getElementById("zoomLevel");
      if(zoomEl) zoomEl.value = "1";
      if(sessions[cur].img) {
        resizeCanvasFor(sessions[cur].img);
        draw();
      }
    }
  };
}

// 취소
const coordCancel = document.getElementById("coordCancel");
if(coordCancel) {
  coordCancel.onclick = () => {
    selectedPoint = null;
    if(coordSelectPoint) coordSelectPoint.value = "";
    if(coordX) coordX.value = "";
    if(coordY) coordY.value = "";
    draw();
  };
}

// X, Y 좌표 입력 필드에서 Enter 키로도 적용 가능
if(coordX) {
  coordX.addEventListener("keypress", e => {
    if(e.key === "Enter") {
      if(coordApply) coordApply.click();
    }
  });
}
if(coordY) {
  coordY.addEventListener("keypress", e => {
    if(e.key === "Enter") {
      if(coordApply) coordApply.click();
    }
  });
}

// 좌표 증감 버튼 기능 (자동 적용)
function adjustCoordinate(coordField, delta) {
  if(!coordField) return;
  
  // 현재 값이 비어있으면 기본값 설정
  let currentValue = parseFloat(coordField.value);
  if(isNaN(currentValue)) {
    // 좌표가 없으면 중앙값으로 설정
    const originalW = originalCanvasSize.width || (cv.width / DPR);
    const originalH = originalCanvasSize.height || (cv.height / DPR);
    if(coordField === coordX) {
      currentValue = originalW / 2;
    } else {
      currentValue = originalH / 2;
    }
  }
  
  const newValue = currentValue + delta;
  coordField.value = newValue.toFixed(1);
  
  // 자동으로 적용 (점이 선택되어 있고 좌표가 유효한 경우)
  if(selectedPoint && !isNaN(newValue)) {
    const xField = coordX;
    const yField = coordY;
    if(!xField || !yField) return;
    
    const x = parseFloat(xField.value);
    const y = parseFloat(yField.value);
    
    if(!isNaN(x) && !isNaN(y)) {
      // 좌표는 항상 원본 크기 기준으로 저장
      const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
      const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
      const orientation = sessions[cur].poseData?.orientation || "side";
      const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
      const clampedX = clamp(x, 0, originalW);
      const clampedY = clamp(y, 0, originalH);
      
      map.set(selectedPoint, {
        x: clampedX,
        y: clampedY
      });
      
      // 입력 필드도 업데이트 (클램핑된 값)
      xField.value = clampedX.toFixed(1);
      yField.value = clampedY.toFixed(1);
      
    draw();
    computeMetricsOnly(); // 실시간 분석 없음 (저장 버튼 클릭 시에만 AI 분석)
    }
  }
}

// 증감 버튼 연속 클릭 변수
let incrementTimer = null;
let incrementInterval = null;

function startIncrement(coordField, delta) {
  // 즉시 한 번 실행
  adjustCoordinate(coordField, delta);
  
  // 짧은 딜레이 후 연속 실행
  incrementTimer = setTimeout(() => {
    incrementInterval = setInterval(() => {
      adjustCoordinate(coordField, delta);
    }, 50); // 50ms마다 실행 (빠른 증감)
  }, 300); // 300ms 후 연속 실행 시작
}

function stopIncrement() {
  if(incrementTimer) {
    clearTimeout(incrementTimer);
    incrementTimer = null;
  }
  if(incrementInterval) {
    clearInterval(incrementInterval);
    incrementInterval = null;
  }
}

// X 좌표 증감 버튼
const coordXDec = document.getElementById("coordXDec");
const coordXInc = document.getElementById("coordXInc");
if(coordXDec) {
  coordXDec.onmousedown = () => {
    if(coordX) startIncrement(coordX, -0.1);
  };
  coordXDec.onmouseup = stopIncrement;
  coordXDec.onmouseleave = stopIncrement;
  coordXDec.ontouchstart = (e) => {
    e.preventDefault();
    if(coordX) startIncrement(coordX, -0.1);
  };
  coordXDec.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordXDec.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}
if(coordXInc) {
  coordXInc.onmousedown = () => {
    if(coordX) startIncrement(coordX, 0.1);
  };
  coordXInc.onmouseup = stopIncrement;
  coordXInc.onmouseleave = stopIncrement;
  coordXInc.ontouchstart = (e) => {
    e.preventDefault();
    if(coordX) startIncrement(coordX, 0.1);
  };
  coordXInc.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordXInc.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}

// Y 좌표 증감 버튼 (Y는 화면 아래로 갈수록 값이 커지므로 반대로)
const coordYDec = document.getElementById("coordYDec");
const coordYInc = document.getElementById("coordYInc");
if(coordYDec) {
  coordYDec.onmousedown = () => {
    if(coordY) startIncrement(coordY, 0.1); // Y는 위로 가려면 값이 증가해야 함
  };
  coordYDec.onmouseup = stopIncrement;
  coordYDec.onmouseleave = stopIncrement;
  coordYDec.ontouchstart = (e) => {
    e.preventDefault();
    if(coordY) startIncrement(coordY, 0.1);
  };
  coordYDec.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordYDec.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}
if(coordYInc) {
  coordYInc.onmousedown = () => {
    if(coordY) startIncrement(coordY, -0.1); // Y는 아래로 가려면 값이 감소해야 함
  };
  coordYInc.onmouseup = stopIncrement;
  coordYInc.onmouseleave = stopIncrement;
  coordYInc.ontouchstart = (e) => {
    e.preventDefault();
    if(coordY) startIncrement(coordY, -0.1);
  };
  coordYInc.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordYInc.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}

// 드래그 기능 (마우스 + 터치)
function getEventPos(e) {
  const r = cv.getBoundingClientRect();
  const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
  
  // 캔버스 상대 좌표 (캔버스 기준)
  // getBoundingClientRect()는 이미 스크롤된 위치를 반영하므로
  // clientX - r.left는 캔버스 전체에서의 CSS 픽셀 위치입니다
  let x = clientX - r.left;
  let y = clientY - r.top;
  
  // 확대 모드
  if(editMode && currentZoom > 1) {
    // x, y는 이미 확대된 캔버스 전체에서의 CSS 픽셀 위치 (스크롤 포함)
    // 따라서 zoom으로 나누기만 하면 원본 크기 좌표가 됨
    x = x / currentZoom;
    y = y / currentZoom;
    
    // 원본 크기 범위로 제한
    const originalW = originalCanvasSize.width || (cv.width / DPR / currentZoom);
    const originalH = originalCanvasSize.height || (cv.height / DPR / currentZoom);
    x = Math.max(0, Math.min(x, originalW));
    y = Math.max(0, Math.min(y, originalH));
    
    console.log('확대 모드 좌표 변환:', {
      clientX, clientY,
      rLeft: r.left.toFixed(1), rTop: r.top.toFixed(1),
      beforeZoom: {x: (clientX - r.left).toFixed(1), y: (clientY - r.top).toFixed(1)},
      afterZoom: {x: x.toFixed(1), y: y.toFixed(1)},
      zoom: currentZoom
    });
  } else {
    // 일반 모드: CSS 좌표를 캔버스 논리 좌표로 변환
    const cssWidth = r.width;
    const cssHeight = r.height;
    
    // 원본 크기 기준으로 변환
    const originalW = originalCanvasSize.width || (cv.width / DPR);
    const originalH = originalCanvasSize.height || (cv.height / DPR);
    
    // CSS 좌표를 논리 좌표로 변환
    x = (x / cssWidth) * originalW;
    y = (y / cssHeight) * originalH;
    
    // 범위 제한
    x = Math.max(0, Math.min(x, originalW));
    y = Math.max(0, Math.min(y, originalH));
  }
  
  return { x, y };
}

function startDrag(e) {
  // 상태 초기화 (touchstart에서 이미 초기화했을 수 있지만 다시 초기화)
  // 이전 상태가 완전히 정리되었는지 확인
  if(dragKey) {
    console.log('⚠️ startDrag: 이전 드래그 상태가 아직 남아있음:', dragKey);
  }
  
  // 상태 초기화 (명시적으로)
  dragKey = null;
  isScrolling = false;
  scrollDistance = 0;
  
  // 터치 이벤트인 경우 손가락 개수 확인
  let touchCount = 0;
  if(e.touches) {
    touchCount = e.touches.length;
    touchStartTime = Date.now();
  }
  
  // 확대 모드에서 스크롤은 두 손가락만 허용
  if(editMode && currentZoom > 1 && touchCount === 2) {
    // 두 손가락 터치: 스크롤 모드만 허용 (점 드래그 불가)
    isScrolling = true;
    dragKey = null;
    if(e.touches && e.touches.length > 0) {
      scrollStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      scrollStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    }
    return false;
  }
  
  // 한 손가락 터치만 점 드래그 허용
  if(touchCount > 1 && !(editMode && currentZoom > 1)) {
    // 확대 모드가 아닌데 두 손가락 이상이면 무시
    return false;
  }
  
  const pos = getEventPos(e);
  const P = getPts(cur);
  
  // Long press 관련 상태 초기화 (더 이상 사용하지 않지만 정리용)
  if(longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  longPressDetected = false;
  longPressNearPoint = null;
  
  // 먼저 모든 점을 체크하여 점을 터치했는지 확인
  // getEventPos는 이미 원본 크기 기준으로 좌표를 반환하므로, 점 좌표와 직접 비교 가능
  let bestPoint = null;
  let bestDistance = 1e9;
  
  // threshold 계산: 확대 모드에서는 1cm 정도의 감지 영역만 유지
  // 1cm를 픽셀로 변환 (일반적으로 96 DPI 기준 약 37.8픽셀, 하지만 실제로는 devicePixelRatio 고려)
  // 실제 화면 크기를 고려하여 더 정확하게 계산
  const r = cv.getBoundingClientRect();
  const screenWidth = r.width; // CSS 픽셀
  
  // 2cm를 픽셀로 변환 (96 DPI 기준: 1cm ≈ 37.8px, 2cm ≈ 75.6px)
  // 하지만 실제 화면에서는 devicePixelRatio를 고려해야 함
  // 간단하게 화면 크기 기준으로 2cm를 추정 (화면 너비의 약 5% 정도)
  const cmToPixel = screenWidth * 0.05; // 화면 너비의 5%를 2cm로 추정
  // 확대 모드에서는 원본 좌표 기준이므로 threshold를 적절히 설정
  // 너무 크면 빈 화면을 눌러도 드래그가 시작될 수 있으므로 적절한 범위 유지
  const baseThreshold = Math.max(50, Math.min(100, cmToPixel)); // 최소 50px, 최대 100px (2cm)
  
  // 확대 모드에서는 원본 크기 기준으로 threshold를 계산
  // 모든 확대 배율에서 동일한 인식 범위를 유지하기 위해 원본 좌표 기준으로 threshold 사용
  let threshold;
  if(editMode && currentZoom > 1) {
    // 확대 모드: 원본 좌표 기준으로 threshold 설정
    // 모든 확대 배율(2, 3, 4배)에서 동일한 인식 범위를 유지
    // 원본 좌표 기준이므로 threshold는 그대로 사용
    threshold = baseThreshold; // 확대 모드에서는 원본 기준 threshold 사용 (모든 배율에서 동일)
  } else {
    // 일반 모드: 화면 픽셀 기준 (라벨 영역 포함)
    threshold = baseThreshold * 1.5; // 라벨 영역 포함을 위해 약간 더 크게
  }
  
  console.log('드래그 감지 시작, threshold:', threshold, 'editMode:', editMode, 'zoom:', currentZoom, 'pos:', pos, 'baseThreshold:', baseThreshold);
  
  // 좌표 수정 모드일 때는 선택된 점만 체크 (배율 1일 때도 동일하게 적용)
  if(editMode && selectedPoint) {
    const pt = P[selectedPoint];
    if(pt) {
      // 배율 1이어도 원본 좌표 기준으로 거리 계산 (threshold도 원본 기준)
      // pos는 이미 원본 크기 기준으로 변환되어 있음
      const d = Math.hypot(pt.x - pos.x, pt.y - pos.y);
      if(d < threshold) {
        bestPoint = selectedPoint;
        bestDistance = d;
        console.log('✅ 선택된 점 드래그 시작 (배율 ' + currentZoom + '):', selectedPoint, '거리:', d.toFixed(2));
      } else {
        console.log('❌ 선택된 점이 너무 멀어서 드래그 불가:', selectedPoint, '거리:', d.toFixed(2), 'threshold:', threshold);
      }
    }
    // 선택된 점만 체크하므로 다른 점은 체크하지 않음 (bestPoint가 null이면 드래그 시작 안 됨)
  } else if(editMode && !selectedPoint) {
    // editMode지만 선택된 점이 없으면 드래그 불가
    console.log('⚠️ editMode이지만 선택된 점이 없어서 드래그 불가');
    return false;
  } else {
    // 일반 모드 (editMode가 false): 모든 점 체크 (현재 orientation에 맞는 키포인트 사용)
    const currentKeypoints = getKeypoints();
    for(const k of currentKeypoints) {
      const p = P[k.key];
      if(!p) continue;
      
      let d;
      
      // 일반 모드에서는 확대/축소 없이 CSS 좌표 기준으로 거리 계산
        // pos는 이미 원본 크기 기준으로 변환되어 있음
        // 모든 확대 배율에서 동일한 계산 방식 사용
        d = Math.hypot(p.x - pos.x, p.y - pos.y);
        if(d < threshold) {
          console.log('✅ 확대 모드 점 감지:', k.key, '점 좌표:', p, '터치 좌표:', pos, '거리:', d.toFixed(2), 'threshold:', threshold, 'zoom:', currentZoom);
        }
      } else {
        // 일반 모드: 화면 좌표 기준으로 거리 계산 (라벨 영역 포함)
        const scaleX = 1;
        const scaleY = 1;
        const screenPtX = p.x * scaleX;
        const screenPtY = p.y * scaleY;
        const screenPosX = pos.x * scaleX;
        const screenPosY = pos.y * scaleY;
        
        // 점과의 거리 계산
        d = Math.hypot(screenPtX - screenPosX, screenPtY - screenPosY);
        
        // 라벨 영역 체크 (점 오른쪽에 라벨이 있음)
        // 라벨은 점 오른쪽에 위치: x + 10부터 시작, 너비는 대략 100픽셀, 높이는 16픽셀
        const labelX = screenPtX + 10;
        const labelY = screenPtY - 12;
        const labelWidth = 100; // 라벨 최대 너비
        const labelHeight = 16;
        
        // 라벨 영역 내에 있는지 확인
        if(screenPosX >= labelX && screenPosX <= labelX + labelWidth &&
           screenPosY >= labelY && screenPosY <= labelY + labelHeight) {
          d = 0; // 라벨 영역 내에 있으면 최우선
        }
      }
      
      if(d < threshold && d < bestDistance) {
        bestPoint = k.key;
        bestDistance = d;
      }
    }
  }
  
  // 점 근처를 터치했을 때만 드래그 모드로 전환
  // bestPoint가 설정되고 threshold 내에 있을 때만 드래그 시작
  if(bestPoint && bestDistance < threshold) {
    // preventDefault는 이벤트 리스너에서 처리하므로 여기서는 하지 않음
    isScrolling = false;
    dragKey = bestPoint; // 확실하게 설정
    
    // 스크롤 시작 위치 저장 (드래그 중에도 사용)
    if(e.touches && e.touches.length > 0) {
      scrollStartX = e.touches[0].clientX;
      scrollStartY = e.touches[0].clientY;
    } else {
      scrollStartX = e.clientX;
      scrollStartY = e.clientY;
    }
    
    console.log('✅ 드래그 시작 성공:', bestPoint, '거리:', bestDistance.toFixed(2), 'threshold:', threshold, 'pos:', pos, 'dragKey:', dragKey, 'editMode:', editMode, 'zoom:', currentZoom);
    return true;
  } else {
    // 점 근처를 누르지 않았으면 드래그 시작하지 않음
    console.log('❌ 점 근처를 누르지 않음, bestPoint:', bestPoint, '거리:', bestDistance < 1e9 ? bestDistance.toFixed(2) : 'N/A', 'threshold:', threshold, 'pos:', pos);
  }
  
  // 점이 아닌 빈 화면을 터치했으면 드래그 시작하지 않음
  // 확대 모드에서 한 손가락 터치는 스크롤 불가 (두 손가락만 스크롤)
  // 일반 모드에서는 아무 동작도 하지 않음
  isScrolling = false;
  dragKey = null; // 명시적으로 null로 설정
  return false;
}

function doDrag(e) {
  // 터치 이벤트인 경우 손가락 개수 확인
  let touchCount = 0;
  if(e.touches) {
    touchCount = e.touches.length;
  }
  
  // 두 손가락 터치: 스크롤만 허용 (확대 모드에서만)
  if(touchCount === 2 && editMode && currentZoom > 1) {
    e.preventDefault();
    e.stopPropagation();
    
    // 스크롤 모드 활성화 확인
    if(!isScrolling) {
      // 스크롤 모드가 아니면 초기화하고 시작
      isScrolling = true;
      dragKey = null;
    }
    
    // 두 손가락의 중심점 계산
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentX = (touch1.clientX + touch2.clientX) / 2;
    const currentY = (touch1.clientY + touch2.clientY) / 2;
    
    // 스크롤 시작 위치가 설정되지 않았으면 설정
    if(scrollStartX === 0 && scrollStartY === 0) {
      scrollStartX = currentX;
      scrollStartY = currentY;
      return;
    }
    
    // 스크롤만 수행
    const canvasWrap = cv.parentElement;
    const deltaX = scrollStartX - currentX;
    const deltaY = scrollStartY - currentY;
    canvasWrap.scrollLeft += deltaX;
    canvasWrap.scrollTop += deltaY;
    scrollStartX = currentX;
    scrollStartY = currentY;
    return;
  }
  
  // 한 손가락만 드래그 허용 (두 손가락 이상이면 무시)
  if(touchCount > 1 && !(editMode && currentZoom > 1 && touchCount === 2)) {
    return;
  }
  
  // dragKey가 없으면 드래그 처리 안 함
  if(!dragKey) {
    return;
  }
  
  // 드래그 모드가 이미 활성화되어 있으면 드래그 처리만 수행 (스크롤 완전 차단)
  if(dragKey) {
    e.preventDefault(); // 스크롤 방지
    e.stopPropagation(); // 이벤트 전파 차단
    
    const pos = getEventPos(e);
    // 좌표는 항상 원본 크기 기준으로 저장
    const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
    const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
    const x = clamp(pos.x, 0, originalW);
    const y = clamp(pos.y, 0, originalH);
    const orientation = sessions[cur].poseData?.orientation || "side";
    const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
    const p = map.get(dragKey);
    
    if(!p) {
      // 점이 없으면 드래그 종료
      console.log('점이 없어 드래그 종료:', dragKey);
      dragKey = null;
      isScrolling = false;
      return;
    }
    
    // 좌표 수정 모드에서는 선택된 점만 이동 (다른 점은 절대 이동 불가)
    if(editMode && selectedPoint) {
      if(dragKey !== selectedPoint) {
        // 선택된 점이 아니면 드래그 무시
        console.log('⚠️ 선택된 점이 아니므로 드래그 무시:', 'dragKey:', dragKey, 'selectedPoint:', selectedPoint);
        dragKey = null; // 드래그 종료
        return;
      }
    }
    
    // 좌표 업데이트 (즉시 반영)
    p.x = x;
    p.y = y;
    
    // 입력 필드도 실시간 업데이트 (원본 크기 기준)
    if(coordX && coordY) {
      coordX.value = x.toFixed(1);
      coordY.value = y.toFixed(1);
    }
    
    // 선택된 점과 일치하면 좌표 표시 업데이트
    if(selectedPoint === dragKey && typeof window.updateCoordDisplay === 'function') {
      window.updateCoordDisplay();
    }
    
    // 즉시 화면 업데이트
    draw();
    
    // 실시간 분석 업데이트 (throttle 적용)
    if(!dragUpdateTimer) {
      dragUpdateTimer = requestAnimationFrame(() => {
        computeAll(); // 전체 분석 실행
        dragUpdateTimer = null;
      });
    }
    
    return; // 드래그 모드에서는 스크롤 완전 차단
  }
}

// 드래그 업데이트 타이머
let dragUpdateTimer = null;

function endDrag(e) {
  // Long press 타이머 정리 (더 이상 사용하지 않지만 정리용)
  if(longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  
  // 드래그 업데이트 타이머 정리
  if(dragUpdateTimer) {
    cancelAnimationFrame(dragUpdateTimer);
    dragUpdateTimer = null;
  }
  
  // 드래그가 끝나면 상태 완전히 초기화 (다음 드래그를 위해)
  const wasDragging = dragKey !== null;
  if(dragKey) {
    console.log('드래그 종료:', dragKey);
    // 최종 분석 실행
    computeAll();
  }
  
  // 모든 상태 완전히 초기화 (매번 확실히)
  dragKey = null;
  isScrolling = false;
  scrollDistance = 0;
  scrollStartX = 0;
  scrollStartY = 0;
  longPressDetected = false;
  longPressNearPoint = null;
  
  // 마우스 상태도 초기화
  if(typeof isMouseDown !== 'undefined') {
    isMouseDown = false;
  }
  
  // 상태 초기화 확인 로그
  if(wasDragging) {
    console.log('드래그 상태 초기화 완료, 다음 드래그 준비됨');
  }
}

// 마우스 이벤트
let isMouseDown = false;
cv.addEventListener('mousedown', (e) => {
  isMouseDown = true;
  startDrag(e);
});

window.addEventListener('mouseup', () => {
  isMouseDown = false;
  endDrag();
});

window.addEventListener('mouseleave', () => {
  isMouseDown = false;
  endDrag();
});

window.addEventListener('mousemove', (e) => {
  if(isMouseDown || dragKey) {
    doDrag(e);
  }
});

// 터치 이벤트 (모바일 지원)
cv.addEventListener('touchstart', (e) => {
  const touchCount = e.touches ? e.touches.length : 0;
  
  // 이전 상태가 남아있으면 완전히 초기화 (드래그든 스크롤이든)
  // 스크롤 후 새로운 드래그를 위해 완전히 초기화
  if(dragKey || isScrolling) {
    console.log('⚠️ 이전 상태가 남아있음, 완전히 정리 - dragKey:', dragKey, 'isScrolling:', isScrolling);
    dragKey = null;
    isScrolling = false;
    scrollStartX = 0;
    scrollStartY = 0;
    scrollDistance = 0;
    // endDrag도 호출하여 완전히 정리
    endDrag(e);
  }
  
  // 두 손가락 스크롤인 경우 스크롤 시작 위치 설정
  if(touchCount === 2 && editMode && currentZoom > 1) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    scrollStartX = (touch1.clientX + touch2.clientX) / 2;
    scrollStartY = (touch1.clientY + touch2.clientY) / 2;
    isScrolling = true;
    dragKey = null;
    console.log('두 손가락 스크롤 시작, scrollStartX:', scrollStartX, 'scrollStartY:', scrollStartY);
    e.preventDefault();
    e.stopPropagation();
    return;
  }
  
  // 한 손가락 터치인 경우에만 점 찾기 시도
  if(touchCount === 1) {
    // 새로운 터치 시작 (이전 상태는 이미 초기화됨)
    const result = startDrag(e);
    
    // 점을 터치했으면 preventDefault
    if(result === true) {
      e.preventDefault();
      e.stopPropagation();
      console.log('한 손가락 터치 - 점 감지 성공, dragKey:', dragKey);
    } else {
      console.log('한 손가락 터치 - 점 감지 실패');
    }
  }
}, {passive: false});

window.addEventListener('touchmove', (e) => {
  const touchCount = e.touches ? e.touches.length : 0;
  
  // 두 손가락 터치인 경우 스크롤 모드
  if(touchCount === 2 && editMode && currentZoom > 1) {
    e.preventDefault();
    e.stopPropagation();
    isScrolling = true;
    dragKey = null; // 스크롤 모드에서는 드래그 키 제거
    doDrag(e);
    return;
  }
  
  // 두 손가락에서 한 손가락으로 변경된 경우 (스크롤 종료)
  if(touchCount === 1 && isScrolling && editMode && currentZoom > 1) {
    // 스크롤 모드 종료하고 상태 초기화
    console.log('스크롤 모드 종료 (두 손가락 → 한 손가락)');
    isScrolling = false;
    dragKey = null;
    scrollStartX = 0;
    scrollStartY = 0;
    // 드래그 처리 안 함 (새로운 터치가 필요)
    return;
  }
  
  // 한 손가락 터치인 경우
  if(touchCount === 1) {
    // dragKey가 설정되어 있으면 드래그 모드 (점 근처를 눌렀을 때만)
    if(dragKey) {
      e.preventDefault();
      e.stopPropagation();
      isScrolling = false; // 드래그 중에는 스크롤 아님
      doDrag(e);
      return;
    }
    
    // dragKey가 없으면 드래그 처리 안 함 (점 근처를 누르지 않았음)
    // 확대 모드에서도 빈 화면을 누르면 아무것도 하지 않음
    return;
  }
  
  // 터치가 없거나 3개 이상인 경우 상태 초기화
  if(touchCount === 0 || touchCount > 2) {
    isScrolling = false;
    dragKey = null;
  }
  
  // 기본 동작은 허용 (점이 아닌 곳을 터치한 경우)
}, {passive: false});

window.addEventListener('touchend', (e) => {
  // changedTouches를 확인하여 끝난 터치가 있는지 체크
  const remainingTouches = e.touches ? e.touches.length : 0;
  const endedTouches = e.changedTouches ? e.changedTouches.length : 0;
  
  // 모든 터치가 끝났는지 확인
  if(remainingTouches === 0) {
    // 모든 터치가 끝났으면 드래그/스크롤 완전히 종료
    console.log('모든 터치 종료, 상태 완전 초기화');
    endDrag(e);
    // 추가로 확실하게 초기화
    dragKey = null;
    isScrolling = false;
    scrollStartX = 0;
    scrollStartY = 0;
    scrollDistance = 0;
  } else if(endedTouches > 0) {
    // 일부 터치만 끝났는 경우
    // 두 손가락 스크롤 중 하나가 떨어졌으면 스크롤 모드 종료
    if(isScrolling && remainingTouches === 1) {
      console.log('스크롤 모드 종료 (한 손가락 남음), 상태 초기화');
      isScrolling = false;
      dragKey = null;
      scrollStartX = 0;
      scrollStartY = 0;
      scrollDistance = 0;
      // 다음 드래그를 위해 완전히 초기화
    } else if(remainingTouches === 1 && dragKey) {
      // 드래그 중이었는데 한 손가락이 남아있으면 드래그 계속
      // endDrag 호출하지 않음
    } else {
      // 그 외의 경우는 상태 초기화
      endDrag(e);
    }
  }
});
window.addEventListener('touchcancel', (e) => {
  // 터치가 취소되면 무조건 드래그/스크롤 종료
  console.log('터치 취소, 상태 초기화');
  endDrag(e);
});

// 업로드 (Before/After 각각 하나의 사진만 유지)
["filePicker","cameraPicker"].forEach(id => {
  document.getElementById(id).addEventListener("change", async e => {
    const f = e.target.files[0];
    if(!f) return;
    
    // 현재 선택된 orientation에 따라 적절한 이미지 저장
    const orientation = sessions[cur].poseData?.orientation || "side";
    const imgKey = orientation === "front" ? "imgFront" : "imgSide";
    
    const img = new Image();
    img.onload = async () => {
      // 기존 이미지가 있으면 메모리 정리 (orientation별로)
      const existingImg = sessions[cur][imgKey];
      if(existingImg && existingImg.src && existingImg.src.startsWith('blob:')) {
        URL.revokeObjectURL(existingImg.src);
      }
      
      // 새 이미지로 교체 (orientation별로 저장)
      sessions[cur][imgKey] = img;
      
      // 원본 크기 초기화 (새 이미지를 로드하므로 다시 계산)
      originalCanvasSize.width = 0;
      originalCanvasSize.height = 0;
      originalCanvasSize.styleWidth = 0;
      originalCanvasSize.styleHeight = 0;
      
      resizeCanvasFor(img);
      
      // 해당 orientation에 맞는 키포인트만 초기화
      const currentPoints = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
      currentPoints.clear();
      
      draw();
      computeMetricsOnly(); // 이미지 업로드 시에는 AI 분석 안 함
      
      // 포즈 감지 자동 실행 (선택된 orientation 사용)
      if(typeof applyPoseDetection === 'function') {
        await applyPoseDetection(img, cur);
      }
    };
    img.crossOrigin = "anonymous";
    img.src = URL.createObjectURL(f);
    
    // 파일 입력 초기화 (같은 파일 다시 선택 가능하도록)
    e.target.value = '';
  });
});

// Reset 버튼
document.getElementById("btnReset").onclick = () => {
  const orientation = sessions[cur].poseData?.orientation || "side";
  const currentPoints = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
  currentPoints.clear();
  draw();
  computeMetricsOnly(); // 리셋 시에는 AI 분석 안 함
};

// ✅ 캘리브레이션 기능
let calibrationMode = false;
document.getElementById("btnCalibrate").onclick = () => {
  calibrationMode = !calibrationMode;
  const panel = document.getElementById("calibrationPanel");
  const S = sessions[cur];
  
  if(calibrationMode) {
    panel.style.display = "block";
    // 세션에 캘리브레이션 점 저장
    S.calibrationPoint1 = null;
    S.calibrationPoint2 = null;
    document.getElementById("calPoint1").textContent = "클릭하여 선택";
    document.getElementById("calPoint2").textContent = "클릭하여 선택";
    document.getElementById("calibrationResult").textContent = "";
    // 캘리브레이션 모드에서는 클릭 이벤트로 점 선택
    cv.style.cursor = "crosshair";
    draw(); // 초기화
  } else {
    panel.style.display = "none";
    cv.style.cursor = "default";
    calibrationMode = false;
    // 캘리브레이션 점 초기화
    S.calibrationPoint1 = null;
    S.calibrationPoint2 = null;
    draw();
  }
};

// 캘리브레이션 클릭 핸들러 (다른 이벤트와 충돌 방지)
cv.addEventListener('click', (e) => {
  if(!calibrationMode) return;
  
  // 다른 이벤트와 충돌 방지
  e.preventDefault();
  e.stopPropagation();
  e.stopImmediatePropagation();
  
  const pos = getEventPos(e);
  const S = sessions[cur];
  
  if(!S.calibrationPoint1) {
    // 점 1 저장
    S.calibrationPoint1 = pos;
    document.getElementById("calPoint1").textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    draw(); // 점이 영구적으로 표시됨
    console.log('캘리브레이션 점 1:', pos);
  } else if(!S.calibrationPoint2) {
    // 점 2 저장
    S.calibrationPoint2 = pos;
    document.getElementById("calPoint2").textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    draw(); // 점과 선이 영구적으로 표시됨
    console.log('캘리브레이션 점 2:', pos);
    
    // 두 점 사이 거리 계산해서 미리보기 표시
    if(S.calibrationPoint1 && S.calibrationPoint2) {
      const distPx = dist(S.calibrationPoint1, S.calibrationPoint2);
      document.getElementById("calibrationResult").textContent = 
        `거리: ${distPx.toFixed(1)}px (실제 길이 입력 후 계산 버튼 클릭)`;
      document.getElementById("calibrationResult").style.color = "var(--muted)";
    }
  } else {
    // 두 점 모두 선택되었으면 다시 시작
    S.calibrationPoint1 = pos;
    S.calibrationPoint2 = null;
    document.getElementById("calPoint1").textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    document.getElementById("calPoint2").textContent = "클릭하여 선택";
    document.getElementById("calibrationResult").textContent = "";
    draw();
    console.log('캘리브레이션 재시작 - 점 1:', pos);
  }
}, true); // capture phase에서 먼저 처리

document.getElementById("btnCalibrateConfirm").onclick = () => {
  const S = sessions[cur];
  if(!S.calibrationPoint1 || !S.calibrationPoint2) {
    alert("두 점을 모두 선택해주세요.");
    return;
  }
  
  const realLengthCm = parseFloat(document.getElementById("calibrationLength").value);
  if(!realLengthCm || realLengthCm <= 0) {
    alert("실제 길이(cm)를 올바르게 입력해주세요.");
    return;
  }
  
  try {
    const pxPerCm = calibratePxPerCm(S.calibrationPoint1, S.calibrationPoint2, realLengthCm);
    S.pxPerCm = pxPerCm;
    document.getElementById("calibrationResult").textContent = 
      `✅ 캘리브레이션 완료: ${pxPerCm.toFixed(2)} px/cm`;
    document.getElementById("calibrationResult").style.color = "#2ec4b6";
    
    // 메트릭 재계산
    computeMetricsOnly();
    
    console.log(`캘리브레이션: ${pxPerCm.toFixed(2)} px/cm`);
  } catch(err) {
    alert("캘리브레이션 오류: " + err.message);
  }
};

document.getElementById("btnCalibrateCancel").onclick = () => {
  calibrationMode = false;
  document.getElementById("calibrationPanel").style.display = "none";
  const S = sessions[cur];
  S.calibrationPoint1 = null;
  S.calibrationPoint2 = null;
  cv.style.cursor = "default";
  draw();
};

// 좌표 저장 (저장 버튼 - AI 분석 실행)
document.getElementById("btnSaveJSON").onclick = () => {
  // 저장 전에 AI 분석 실행
  computeAll();
  
  const orientation = sessions[cur].poseData?.orientation || "side";
  const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
  const obj = Object.fromEntries(map);
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${cur}_${orientation}_keypoints.json`;
  a.click();
  URL.revokeObjectURL(a.href);
};

// 좌표 불러오기
document.getElementById("btnLoadJSON").onclick = () => {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = 'application/json';
  inp.onchange = e => {
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = () => {
      try {
        const obj = JSON.parse(r.result);
        const orientation = sessions[cur].poseData?.orientation || "side";
        const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
        map.clear();
        for(const k of Object.keys(obj)) map.set(k, obj[k]);
        draw();
        computeAll();
      } catch(err) {
        alert('JSON 파싱 실패: ' + err.message);
      }
    };
    r.readAsText(f);
  };
  inp.click();
};

// ✅ PDF 내보내기 유틸 (헤더/푸터 포함)
function exportAsPdf(options = {}) {
  const {
    fileName = `DIT_자세_분석_리포트_${cur}_${new Date().toISOString().split('T')[0]}.pdf`,
    userName = localStorage.getItem('userName') || '사용자',
    appName = 'DIT 자세 분석 AI',
    logoUrl = null
  } = options;
  
  return new Promise(async (resolve, reject) => {
    try {
      const S = sessions[cur];
      const M = S.metrics || {};
      const scoreData = S.score || {};
      const analysis = S.analysis || {};
      
      // 날짜 포맷
      const now = new Date();
      const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
      
      // 첫 페이지: 제목과 이미지
      const page1Container = document.createElement("div");
      page1Container.style.position = "fixed";
      page1Container.style.left = "-9999px";
      page1Container.style.top = "0";
      page1Container.style.width = "794px"; // A4 너비 @96dpi
      page1Container.style.padding = "30px 25px";
      page1Container.style.paddingBottom = "40px";
      page1Container.style.background = "#ffffff";
      page1Container.style.color = "#111";
      page1Container.style.fontFamily = '"Noto Sans KR", Arial, sans-serif';
      page1Container.style.fontSize = "12px";
      page1Container.style.lineHeight = "1.6";
      page1Container.style.boxSizing = "border-box";
      page1Container.style.overflow = "hidden";
      page1Container.style.wordWrap = "break-word";
      
      // 통합 분석 결과 가져오기 (운동 추천 포함)
      const analysisResult = S.analysisResult || analyzePostureAutoWithRecommendation({
        sidePts: S.sidePoints.size > 0 ? Object.fromEntries(S.sidePoints) : null,
        frontPts: S.frontPoints.size > 0 ? Object.fromEntries(S.frontPoints) : null,
        pxPerCm: S.pxPerCm || 50.0
      });
      
      // 측면 및 정면 이미지 준비
      const sideImg = S.imgSide ? S.imgSide.src : null;
      const frontImg = S.imgFront ? S.imgFront.src : null;
      
      // 로고 HTML (있으면)
      const logoHtml = logoUrl ? `<img src="${logoUrl}" style="width:32px; height:32px; margin-right:8px; vertical-align:middle;" />` : '';
      
      // 분석 결과 요약 HTML 생성
      const analysisSummaryHtml = buildAnalysisSummaryHtml(analysisResult);
      // 운동 추천 HTML 생성
      const exerciseRecommendationHtml = buildExerciseRecommendationHtml(analysisResult);
      
      page1Container.innerHTML = `
        <!-- 헤더 -->
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; padding-bottom:10px; border-bottom:1px solid #e0e0e0;">
          <div style="display:flex; align-items:center;">
            ${logoHtml}
            <span style="font-size:14px; font-weight:700; color:#0b0f14;">${appName}</span>
          </div>
          <span style="font-size:10px; color:#666;">${dateStr}</span>
        </div>
        
        <h1 style="margin:0; padding:0; font-size:24px; font-weight:800; color:#0b0f14; margin-bottom:12px; line-height:1.3; word-wrap:break-word;">DIT 자세 분석 리포트</h1>
        <div style="font-size:11px; color:#666; margin-bottom:25px; word-wrap:break-word;">세션: ${cur}</div>
        
        <!-- 분석 결과 요약 -->
        ${analysisSummaryHtml}
        
        ${sideImg ? `<div style="margin-top:20px;"><div style="font-size:12px; font-weight:600; margin-bottom:8px;">측면 이미지</div><img src="${sideImg}" style="width:100%; height:auto; border-radius:8px; border:1px solid #ddd; display:block; max-height:400px; object-fit:contain;" /></div>` : ''}
        
        ${frontImg ? `<div style="margin-top:20px;"><div style="font-size:12px; font-weight:600; margin-bottom:8px;">정면 이미지</div><img src="${frontImg}" style="width:100%; height:auto; border-radius:8px; border:1px solid #ddd; display:block; max-height:400px; object-fit:contain;" /></div>` : ''}
        
        <!-- 운동 추천 -->
        ${exerciseRecommendationHtml}
        
        <!-- 푸터 -->
        <div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
          <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
            <span>Generated by ${appName}</span>
            <span>User: ${userName}</span>
          </div>
        </div>
      `;
    
    document.body.appendChild(page1Container);
    
    // 첫 페이지 캡처
    const canvas1 = await html2canvas(page1Container, {
      scale: 2,
      backgroundColor: "#ffffff",
      useCORS: true,
      allowTaint: true,
      logging: false,
      windowWidth: page1Container.scrollWidth,
      windowHeight: page1Container.scrollHeight
    });
    
    document.body.removeChild(page1Container);
    
    // 두 번째 페이지: 체형 종합 점수부터 시작
    const page2Container = document.createElement("div");
    page2Container.style.position = "fixed";
    page2Container.style.left = "-9999px";
    page2Container.style.top = "0";
    page2Container.style.width = "794px";
    page2Container.style.padding = "30px 25px";
    page2Container.style.paddingBottom = "40px";
    page2Container.style.background = "#ffffff";
    page2Container.style.color = "#111";
    page2Container.style.fontFamily = '"Noto Sans KR", Arial, sans-serif';
    page2Container.style.fontSize = "12px";
    page2Container.style.lineHeight = "1.6";
    page2Container.style.boxSizing = "border-box";
    page2Container.style.overflow = "hidden";
    page2Container.style.wordWrap = "break-word";
    
    page2Container.innerHTML = `
      <div style="margin-bottom:25px; padding:18px; background:#f5f5f5; border-radius:10px; box-sizing:border-box; overflow:hidden;">
        <div style="font-size:16px; font-weight:700; margin-bottom:12px; line-height:1.4; word-wrap:break-word;">📊 체형 종합 점수</div>
        <div style="font-size:42px; font-weight:800; color:${scoreData.score >= 85 ? '#2ec4b6' : scoreData.score >= 70 ? '#ffd166' : '#ff6b6b'}; margin-bottom:10px; line-height:1.2;">${scoreData.score != null ? scoreData.score : '—'}</div>
        <div style="font-size:11px; color:#666; line-height:1.5; word-wrap:break-word; overflow-wrap:break-word;">${scoreData.reasons && scoreData.reasons.length > 0 ? scoreData.reasons.join(", ") : "모든 측정값이 정상 범위 내에 있습니다."}</div>
      </div>
      
      <div style="margin-bottom:25px; box-sizing:border-box;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px;">📐 측정 각도</div>
        <table style="width:100%; border-collapse:collapse; font-size:12px; table-layout:fixed;">
          <tr style="background:#f0f0f0;"><th style="padding:10px 8px; text-align:left; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">항목</th><th style="padding:10px 8px; text-align:left; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">측정값</th><th style="padding:10px 8px; text-align:left; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">정상 범위</th></tr>
          <tr><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">CVA</td><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">${M.cva != null ? M.cva.toFixed(1) + "°" : "—"}</td><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">≥50°</td></tr>
          <tr style="background:#fafafa;"><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">TRUNK</td><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">${M.pelvic != null ? M.pelvic.toFixed(1) + "°" : "—"}</td><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">|0–5°|</td></tr>
          <tr><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">KNEE</td><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">${M.knee != null ? M.knee.toFixed(1) + "°" : "—"}</td><td style="padding:10px 8px; border:1px solid #ddd; word-wrap:break-word;">175–185°</td></tr>
        </table>
      </div>
      
      ${analysis.comments && analysis.comments.length > 0 ? `
      <div style="margin-bottom:25px; padding:18px; background:#e8f5e9; border-radius:10px; border-left:4px solid #2ec4b6; box-sizing:border-box; overflow:hidden;">
        <div style="font-size:14px; font-weight:700; margin-bottom:10px; color:#2ec4b6; line-height:1.4; word-wrap:break-word;">🤖 AI 실시간 분석</div>
        <div style="font-size:12px; line-height:1.6; word-wrap:break-word; overflow-wrap:break-word;">${analysis.comments.join(" ")}</div>
        ${analysis.details && analysis.details.length > 0 ? `<div style="margin-top:12px; font-size:11px; line-height:1.6; color:#555; word-wrap:break-word; overflow-wrap:break-word;">${analysis.details.join("<br>")}</div>` : ""}
      </div>
      ` : ""}
      
      ${(analysis.tight && analysis.tight.length > 0) || (analysis.weak && analysis.weak.length > 0) ? `
      <div style="margin-bottom:25px; padding:18px; background:#fff3e0; border-radius:10px; border-left:4px solid #ffb86c; box-sizing:border-box; overflow:hidden;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#ffb86c; line-height:1.4; word-wrap:break-word;">💪 근육 상태 분석</div>
        ${analysis.tight && analysis.tight.length > 0 ? `<div style="margin-bottom:10px; line-height:1.5; word-wrap:break-word; overflow-wrap:break-word;"><strong style="color:#ff6b6b;">🔴 긴장된 근육:</strong> <span style="font-size:12px;">${analysis.tight.join(", ")}</span></div>` : ""}
        ${analysis.weak && analysis.weak.length > 0 ? `<div style="line-height:1.5; word-wrap:break-word; overflow-wrap:break-word;"><strong style="color:#7c9cff;">🔵 약화된 근육:</strong> <span style="font-size:12px;">${analysis.weak.join(", ")}</span></div>` : ""}
      </div>
      ` : ""}
      
      ${analysis.exercises && analysis.exercises.length > 0 ? `
      <div style="margin-bottom:25px; padding:18px; background:#e0f2f1; border-radius:10px; border-left:4px solid #2ec4b6; box-sizing:border-box; overflow:hidden;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#2ec4b6; line-height:1.4; word-wrap:break-word;">🏋️ 추천 운동</div>
        <div style="font-size:12px; line-height:1.8; word-wrap:break-word; overflow-wrap:break-word;">${analysis.exercises.map(ex => `<div style="margin-bottom:8px;">${ex}</div>`).join("")}</div>
      </div>
      ` : ""}
      
      <div style="margin-top:25px; padding:18px; background:#f5f5f5; border-radius:10px; font-size:11px; color:#666; box-sizing:border-box; overflow:hidden;">
        <div style="margin-bottom:8px; line-height:1.5; word-wrap:break-word; overflow-wrap:break-word;"><strong>Before 측정값:</strong> CVA ${fmtDeg(sessions.Before.metrics.cva)}, TRUNK ${fmtDeg(sessions.Before.metrics.pelvic)}, KNEE ${fmtDeg(sessions.Before.metrics.knee)}</div>
        <div style="line-height:1.5; word-wrap:break-word; overflow-wrap:break-word;"><strong>After 측정값:</strong> CVA ${fmtDeg(sessions.After.metrics.cva)}, TRUNK ${fmtDeg(sessions.After.metrics.pelvic)}, KNEE ${fmtDeg(sessions.After.metrics.knee)}</div>
      </div>
      
      <div style="margin-top:20px; font-size:10px; color:#999; text-align:center; line-height:1.5;">※ 본 리포트는 교육용으로 제공됩니다. 의료 진단을 대체하지 않습니다.</div>
    `;
    
    document.body.appendChild(page2Container);
    
    // 두 번째 페이지 캡처
    const canvas2 = await html2canvas(page2Container, {
      scale: 3, // 고해상도
      backgroundColor: "#ffffff",
      useCORS: true,
      allowTaint: true,
      logging: false,
      windowWidth: page2Container.scrollWidth,
      windowHeight: page2Container.scrollHeight
    });
    
    document.body.removeChild(page2Container);
    
    // PDF 생성 (마진 24px = 약 0.6cm)
    const pdf = new jsPDF({orientation:"portrait", unit:"px", format:"a4"});
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();
    const margin = 24; // Dart 코드의 margin: EdgeInsets.all(24)와 동일
    const imgW = pageW - (margin * 2);
    
    // 첫 페이지: 제목과 이미지
    const img1H = canvas1.height * (imgW / canvas1.width);
    const maxImg1H = pageH - (margin * 2);
    if(img1H <= maxImg1H) {
      pdf.addImage(canvas1.toDataURL("image/png"), "PNG", margin, margin, imgW, img1H);
    } else {
      // 이미지가 크면 자르기
      pdf.addImage(canvas1.toDataURL("image/png"), "PNG", margin, margin, imgW, maxImg1H);
    }
    
    // 두 번째 페이지: 체형 종합 점수부터
    pdf.addPage();
    const img2H = canvas2.height * (imgW / canvas2.width);
    const maxImg2H = pageH - (margin * 2);
    if(img2H <= maxImg2H) {
      pdf.addImage(canvas2.toDataURL("image/png"), "PNG", margin, margin, imgW, img2H);
    } else {
      // 긴 내용은 여러 페이지로 분할
      let remaining = img2H, sY = 0;
      const onePageH = maxImg2H;
      const sliceH = canvas2.height * (onePageH / img2H);
      while(remaining > 0) {
        const pageCanvas = document.createElement("canvas");
        pageCanvas.width = canvas2.width;
        pageCanvas.height = Math.min(sliceH, canvas2.height - sY);
        const pctx = pageCanvas.getContext("2d");
        pctx.drawImage(canvas2, 0, sY, canvas2.width, pageCanvas.height, 0, 0, canvas2.width, pageCanvas.height);
        const pageImg = pageCanvas.toDataURL("image/png");
        pdf.addImage(pageImg, "PNG", margin, margin, imgW, onePageH * (pageCanvas.height / sliceH));
        remaining -= onePageH;
        sY += sliceH;
        if(remaining > 0) pdf.addPage();
      }
    }
    
    pdf.save(fileName);
    
    resolve();
  } catch(error) {
    console.error("PDF 생성 실패:", error);
    reject(error);
  }
  });
}

// PDF 저장 (모바일 최적화, 페이지 분리)
document.getElementById("btnPDF").onclick = async () => {
  try {
    // 모바일에서 로딩 표시
    const btn = document.getElementById("btnPDF");
    const originalText = btn.textContent;
    btn.textContent = "⏳ PDF 생성 중...";
    btn.disabled = true;
    
    // 사용자명 입력 받기 (한 번만)
    let userName = localStorage.getItem('userName');
    if(!userName) {
      userName = prompt("사용자명을 입력하세요 (나중에 변경 가능):", "사용자") || "사용자";
      localStorage.setItem('userName', userName);
    }
    
    await exportAsPdf({
      userName: userName,
      appName: 'DIT 자세 분석 AI'
    });
    
    btn.textContent = originalText;
    btn.disabled = false;
    
    // 모바일에서 성공 메시지
    if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      alert("PDF가 저장되었습니다!");
    }
  } catch(error) {
    console.error("PDF 생성 실패:", error);
    alert("PDF 생성에 실패했습니다: " + error.message);
    const btn = document.getElementById("btnPDF");
    btn.textContent = "📄 PDF 저장";
    btn.disabled = false;
  }
};

// 그림으로 저장 (전체 내용 포함)
document.getElementById("btnImage").onclick = async () => {
  try {
    // 모바일에서 로딩 표시
    const btn = document.getElementById("btnImage");
    const originalText = btn.textContent;
    btn.textContent = "⏳ 이미지 생성 중...";
    btn.disabled = true;
    
    const S = sessions[cur];
    const fullMetrics = S.metrics?.fullMetrics || {};
    const scoreData = S.score || {};
    const analysis = S.analysis || {};
    
    // 전체 컨테이너 생성 (모든 내용 포함)
    const fullContainer = document.createElement("div");
    fullContainer.style.position = "fixed";
    fullContainer.style.left = "-9999px";
    fullContainer.style.top = "0";
    fullContainer.style.width = "794px"; // A4 너비 @96dpi
    fullContainer.style.padding = "30px 25px";
    fullContainer.style.paddingBottom = "40px";
    fullContainer.style.background = "#ffffff";
    fullContainer.style.color = "#111";
    fullContainer.style.fontFamily = '"Noto Sans KR", Arial, sans-serif';
    fullContainer.style.fontSize = "12px";
    fullContainer.style.lineHeight = "1.6";
    fullContainer.style.boxSizing = "border-box";
    fullContainer.style.wordWrap = "break-word";
    
    // 캔버스 이미지 가져오기
    const cvImg = cv.toDataURL("image/png");
    
    // 전체 분석 항목 HTML 생성
    const metricsOrder = [
      {key: 'CVA', name: 'CVA', unit: '°', normal: '≥50°'},
      {key: 'HPD', name: 'HPD', unit: 'cm', normal: '≤2cm'},
      {key: 'NIA', name: 'NIA', unit: '°', normal: '0-20°'},
      {key: 'TIA', name: 'TIA', unit: '°', normal: '0-10°'},
      {key: 'SAA', name: 'SAA', unit: '°', normal: '0-10°'},
      {key: 'PTA', name: 'PTA', unit: '°', normal: '0-15°'},
      {key: 'KA', name: 'KA', unit: '°', normal: '175-185°'},
      {key: 'Tibial_Angle', name: 'Tibial', unit: '°', normal: '0-10°'},
      {key: 'Q_Angle', name: 'Q-Angle', unit: '°', normal: '10-20°'},
      {key: 'Knee_Deviation', name: 'Knee Dev', unit: '°', normal: '0-3°'},
      {key: 'LLD', name: 'LLD', unit: 'cm', normal: '≤1cm'},
      {key: 'GSB', name: 'GSB', unit: 'cm', normal: '≤2cm'},
      {key: 'BVA', name: 'BVA', unit: 'cm', normal: '≤2cm'},
      {key: 'SCI', name: 'SCI', unit: '', normal: '0.15-0.35'},
      {key: 'HPA', name: 'HPA', unit: '°', normal: '0-10°'},
      {key: 'PDS', name: 'PDS', unit: '점', normal: '정상'}
    ];
    
    let allMetricsHTML = '';
    metricsOrder.forEach(m => {
      const metric = fullMetrics[m.key];
      if(metric && metric.value != null) {
        const value = metric.value;
        const status = metric.status || 'unknown';
        const statusColor = status === 'normal' ? '#2ec4b6' : status === 'mild' ? '#ffd166' : status === 'moderate' ? '#ffb86c' : '#ff6b6b';
        const statusText = status === 'normal' ? '✓' : status === 'mild' ? '⚠' : status === 'moderate' ? '⚠⚠' : status === 'severe' ? '✗' : '?';
        allMetricsHTML += `
          <tr>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word;">${m.name}</td>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word; color:${statusColor};"><strong>${value.toFixed(1)}${m.unit}</strong> ${statusText}</td>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word;">${m.normal}</td>
          </tr>
        `;
      }
    });
    
    // Before/After 비교 HTML 생성
    const B = sessions.Before;
    const A = sessions.After;
    let compareHTML = '';
    metricsOrder.forEach(m => {
      const bVal = B.metrics?.fullMetrics?.[m.key]?.value;
      const aVal = A.metrics?.fullMetrics?.[m.key]?.value;
      if(bVal != null || aVal != null) {
        const delta = (aVal != null && bVal != null) ? (aVal - bVal) : null;
        const deltaStr = delta != null ? (delta >= 0 ? '+' : '') + delta.toFixed(1) + m.unit : '—';
        compareHTML += `
          <tr>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word;">${m.name}</td>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word;">${bVal != null ? bVal.toFixed(1) + m.unit : '—'}</td>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word;">${aVal != null ? aVal.toFixed(1) + m.unit : '—'}</td>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word; color:${delta != null && delta < 0 ? '#2ec4b6' : delta != null && delta > 0 ? '#ff6b6b' : '#666'};">${deltaStr}</td>
            <td style="padding:8px; border:1px solid #ddd; word-wrap:break-word;">${m.normal}</td>
          </tr>
        `;
      }
    });
    
    // 필라테스 추천 HTML 생성
    let pilatesHTML = '';
    if(analysis.pilates && analysis.pilates.length > 0) {
      analysis.pilates.forEach(item => {
        pilatesHTML += `<div style="margin-bottom:15px; padding:12px; background:#f9f9f9; border-radius:8px; border-left:3px solid #9c88ff;">`;
        pilatesHTML += `<div style="font-size:13px; font-weight:600; margin-bottom:8px; color:#9c88ff;">${item.issue} (${item.muscles.join(', ')})</div>`;
        const tools = ['매트', '리포머', '캐딜락', '체어', '바렐'];
        tools.forEach(tool => {
          if(item.pilates[tool] && item.pilates[tool].length > 0) {
            pilatesHTML += `<div style="margin-top:6px; font-size:11px;"><strong>${tool}:</strong> ${item.pilates[tool].join(', ')}</div>`;
          }
        });
        pilatesHTML += `</div>`;
      });
    }
    
    fullContainer.innerHTML = `
      <h1 style="margin:0; padding:0; font-size:24px; font-weight:800; color:#0b0f14; margin-bottom:12px; line-height:1.3;">DIT 자세 분석 리포트</h1>
      <div style="font-size:11px; color:#666; margin-bottom:25px;">${new Date().toLocaleString('ko-KR')} | 세션: ${cur}</div>
      
      <!-- 이미지 -->
      <img src="${cvImg}" style="width:100%; height:auto; border-radius:8px; border:1px solid #ddd; display:block; margin-bottom:30px; max-height:950px; object-fit:contain;" />
      
      <!-- 체형 종합 점수 -->
      <div style="margin-bottom:25px; padding:18px; background:#f5f5f5; border-radius:10px;">
        <div style="font-size:16px; font-weight:700; margin-bottom:12px;">📊 체형 종합 점수</div>
        <div style="font-size:42px; font-weight:800; color:${scoreData.score >= 85 ? '#2ec4b6' : scoreData.score >= 70 ? '#ffd166' : '#ff6b6b'}; margin-bottom:10px;">${scoreData.score != null ? scoreData.score : '—'}</div>
        <div style="font-size:11px; color:#666; line-height:1.5;">${scoreData.reasons && scoreData.reasons.length > 0 ? scoreData.reasons.join("<br>") : "모든 측정값이 정상 범위 내에 있습니다."}</div>
        ${fullMetrics.PDS ? `<div style="margin-top:10px; font-size:12px; color:#666;">PDS: <strong style="color:#7c9cff;">${fullMetrics.PDS.value.toFixed(1)}</strong> (${fullMetrics.PDS.status})</div>` : ''}
      </div>
      
      <!-- 전체 분석 항목 -->
      ${allMetricsHTML ? `
      <div style="margin-bottom:25px;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px;">📊 전체 분석 항목 (16가지)</div>
        <table style="width:100%; border-collapse:collapse; font-size:11px;">
          <tr style="background:#f0f0f0;">
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">항목</th>
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">측정값</th>
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">정상 범위</th>
          </tr>
          ${allMetricsHTML}
        </table>
      </div>
      ` : ''}
      
      <!-- Before/After 비교 -->
      ${compareHTML ? `
      <div style="margin-bottom:25px;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px;">📊 Before/After 비교</div>
        <table style="width:100%; border-collapse:collapse; font-size:11px;">
          <tr style="background:#f0f0f0;">
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">항목</th>
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">Before</th>
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">After</th>
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">변화</th>
            <th style="padding:8px; text-align:left; border:1px solid #ddd; font-weight:600;">정상</th>
          </tr>
          ${compareHTML}
        </table>
      </div>
      ` : ''}
      
      <!-- AI 분석 -->
      ${analysis.comments && analysis.comments.length > 0 ? `
      <div style="margin-bottom:25px; padding:18px; background:#e8f5e9; border-radius:10px; border-left:4px solid #2ec4b6;">
        <div style="font-size:14px; font-weight:700; margin-bottom:10px; color:#2ec4b6;">🤖 AI 체형 분석</div>
        <div style="font-size:12px; line-height:1.6;">${analysis.comments.join(" ")}</div>
      </div>
      ` : ''}
      
      <!-- 근육 상태 -->
      ${(analysis.tight && analysis.tight.length > 0) || (analysis.weak && analysis.weak.length > 0) ? `
      <div style="margin-bottom:25px; padding:18px; background:#fff3e0; border-radius:10px; border-left:4px solid #ffb86c;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#ffb86c;">💪 근육 상태 분석</div>
        ${analysis.tight && analysis.tight.length > 0 ? `<div style="margin-bottom:10px; line-height:1.5;"><strong style="color:#ff6b6b;">🔴 긴장된 근육:</strong> <span style="font-size:12px;">${analysis.tight.join(", ")}</span></div>` : ''}
        ${analysis.weak && analysis.weak.length > 0 ? `<div style="line-height:1.5;"><strong style="color:#7c9cff;">🔵 약화된 근육:</strong> <span style="font-size:12px;">${analysis.weak.join(", ")}</span></div>` : ''}
      </div>
      ` : ''}
      
      <!-- 필라테스 추천 -->
      ${pilatesHTML ? `
      <div style="margin-bottom:25px; padding:18px; background:#f3e5f5; border-radius:10px; border-left:4px solid #9c88ff;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#9c88ff;">🧘 필라테스 세션 추천</div>
        ${pilatesHTML}
      </div>
      ` : ''}
      
      <!-- 추천 운동 -->
      ${analysis.exercises && analysis.exercises.length > 0 ? `
      <div style="margin-bottom:25px; padding:18px; background:#e0f2f1; border-radius:10px; border-left:4px solid #2ec4b6;">
        <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#2ec4b6;">🏋️ 추천 운동</div>
        <div style="font-size:12px; line-height:1.8;">${analysis.exercises.map(ex => `<div style="margin-bottom:8px;">${ex}</div>`).join("")}</div>
      </div>
      ` : ''}
      
      <div style="margin-top:30px; font-size:10px; color:#999; text-align:center;">※ 본 리포트는 교육용으로 제공됩니다. 의료 진단을 대체하지 않습니다.</div>
    `;
    
    document.body.appendChild(fullContainer);
    
    // 전체 컨테이너 캡처
    const fullCanvas = await html2canvas(fullContainer, {
      scale: 2,
      backgroundColor: "#ffffff",
      useCORS: true,
      allowTaint: true,
      logging: false,
      windowWidth: fullContainer.scrollWidth,
      windowHeight: fullContainer.scrollHeight
    });
    
    document.body.removeChild(fullContainer);
    
    // 이미지 다운로드
    const imgData = fullCanvas.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = imgData;
    link.download = `DIT_자세_분석_리포트_${cur}_${new Date().toISOString().split('T')[0]}.png`;
    link.click();
    
    btn.textContent = originalText;
    btn.disabled = false;
    
    // 모바일에서 성공 메시지
    if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      alert("이미지가 저장되었습니다!");
    }
  } catch(error) {
    console.error("이미지 생성 실패:", error);
    alert("이미지 생성에 실패했습니다: " + error.message);
    const btn = document.getElementById("btnImage");
    btn.textContent = "🖼️ 그림으로 저장";
    btn.disabled = false;
  }
};

// 공유하기 (Web Share API 사용)
document.getElementById("btnShare").onclick = async () => {
  try {
    const btn = document.getElementById("btnShare");
    const originalText = btn.textContent;
    btn.textContent = "⏳ 준비 중...";
    btn.disabled = true;
    
    const S = sessions[cur];
    const M = S.metrics || {};
    const scoreData = S.score || {};
    const analysis = S.analysis || {};
    
    // 공유할 이미지 생성 (간단한 버전)
    const cvImg = cv.toDataURL("image/png");
    
    // 공유할 텍스트 생성
    const shareText = `DIT 자세 분석 리포트 - ${cur}\n\n` +
      `📊 체형 종합 점수: ${scoreData.score != null ? scoreData.score : '—'}\n` +
      `📐 측정 각도:\n` +
      `  - CVA: ${M.cva != null ? M.cva.toFixed(1) + "°" : "—"} (정상: ≥50°)\n` +
      `  - TRUNK: ${M.pelvic != null ? M.pelvic.toFixed(1) + "°" : "—"} (정상: |0–5°|)\n` +
      `  - KNEE: ${M.knee != null ? M.knee.toFixed(1) + "°" : "—"} (정상: 175–185°)\n\n` +
      `${analysis.comments && analysis.comments.length > 0 ? analysis.comments.join(" ") + "\n\n" : ""}` +
      `${analysis.tight && analysis.tight.length > 0 ? "🔴 긴장된 근육: " + analysis.tight.join(", ") + "\n" : ""}` +
      `${analysis.weak && analysis.weak.length > 0 ? "🔵 약화된 근육: " + analysis.weak.join(", ") + "\n" : ""}` +
      `\n※ 본 리포트는 교육용으로 제공됩니다.`;
    
    // Web Share API 지원 여부 확인
    if (navigator.share) {
      // 이미지 파일 생성
      const response = await fetch(cvImg);
      const blob = await response.blob();
      const file = new File([blob], `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`, { type: 'image/png' });
      
      // 공유 시도
      try {
        await navigator.share({
          title: `DIT 자세 분석 리포트 - ${cur}`,
          text: shareText,
          files: [file]
        });
        
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (shareError) {
        // 사용자가 공유를 취소했거나 에러 발생
        if (shareError.name !== 'AbortError') {
          console.error('공유 실패:', shareError);
          // 폴백: 이미지 다운로드
          const link = document.createElement('a');
          link.href = cvImg;
          link.download = `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`;
          link.click();
        }
        btn.textContent = originalText;
        btn.disabled = false;
      }
    } else {
      // Web Share API를 지원하지 않는 경우: 클립보드에 복사
      try {
        // 텍스트를 클립보드에 복사
        await navigator.clipboard.writeText(shareText);
        
        // 이미지도 다운로드
        const link = document.createElement('a');
        link.href = cvImg;
        link.download = `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`;
        link.click();
        
        alert('분석 결과가 클립보드에 복사되었고 이미지가 다운로드되었습니다!\n\n다른 앱에 붙여넣어 공유하세요.');
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (clipboardError) {
        console.error('클립보드 복사 실패:', clipboardError);
        // 최종 폴백: 이미지 다운로드만
        const link = document.createElement('a');
        link.href = cvImg;
        link.download = `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`;
        link.click();
        alert('이미지가 다운로드되었습니다. 수동으로 공유해주세요.');
        btn.textContent = originalText;
        btn.disabled = false;
      }
    }
  } catch (error) {
    console.error("공유 실패:", error);
    alert("공유에 실패했습니다: " + error.message);
    const btn = document.getElementById("btnShare");
    btn.textContent = "📤 공유하기";
    btn.disabled = false;
  }
};

// 실시간 분석 리스너 등록 (UI 업데이트)
liveAnalyzer.addListener((result) => {
  updateLiveAnalysisUI(result);
});

// 초기화
resizeCanvasFor(null);
draw();
computeMetricsOnly(); // 초기화 시에는 AI 분석 안 함
updateCompare();

// 초기 실시간 분석 실행
setTimeout(() => {
  if(typeof liveAnalyzer !== 'undefined') {
    liveAnalyzer.analyzeCurrentSession();
  }
}, 500);
</script>

<!-- ✅ Pose Detection Libraries -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>

<script>
// 포즈 감지 모델 관리
let detectors = { front: null, side: null };

// 세션별 포즈 정보 저장 (기존 sessions 객체와 통합)
// sessions 객체에 orientation과 landmarks 정보 추가
if(!sessions.Before.poseData) {
  sessions.Before.poseData = { orientation: "side", landmarks: null };
}
if(!sessions.After.poseData) {
  sessions.After.poseData = { orientation: "side", landmarks: null };
}

// 초기 orientation 버튼 상태 설정 및 좌표 선택 드롭다운 초기화
document.addEventListener("DOMContentLoaded", () => {
  const orientation = sessions[cur].poseData?.orientation || "side";
  document.getElementById("btnOrientationSide").classList.toggle("active", orientation === "side");
  document.getElementById("btnOrientationFront").classList.toggle("active", orientation === "front");
  updateCoordSelectOptions();
});

// ✅ 모델 로드 상태 추적
let modelsLoading = { front: false, side: false };
let modelsLoaded = { front: false, side: false };

// ✅ 모델 로드 (정면: MoveNet, 옆모습: BlazePose)
async function loadPoseModels() {
  try {
    // 정면 모델 로드
    if (!modelsLoading.front && !modelsLoaded.front) {
      modelsLoading.front = true;
      detectors.front = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
      modelsLoaded.front = true;
      modelsLoading.front = false;
      console.log("✅ 정면 모델 로드 완료");
    }
    
    // 옆모습 모델 로드
    if (!modelsLoading.side && !modelsLoaded.side) {
      modelsLoading.side = true;
      detectors.side = await poseDetection.createDetector(
        poseDetection.SupportedModels.BlazePose,
        { runtime: "tfjs", modelType: "full", enableSmoothing: true }
      );
      modelsLoaded.side = true;
      modelsLoading.side = false;
      console.log("✅ 옆모습 모델 로드 완료");
    }
    
    console.log("✅ 정면·옆모습 모델 로드 완료");
  } catch(error) {
    console.error("모델 로드 실패:", error);
    modelsLoading.front = false;
    modelsLoading.side = false;
  }
}

loadPoseModels();

// ✅ 분석 시 orientation에 맞는 모델 사용
async function detectPose(img, orientation) {
  // 모델이 로드 중이면 기다림
  let waitCount = 0;
  const maxWait = 50; // 최대 5초 대기 (100ms * 50)
  
  while (!modelsLoaded[orientation] && !detectors[orientation] && waitCount < maxWait) {
    if (!modelsLoading[orientation]) {
      // 모델 로드가 시작되지 않았으면 시작
      await loadPoseModels();
    }
    await new Promise(resolve => setTimeout(resolve, 100)); // 100ms 대기
    waitCount++;
  }
  
  const detector = detectors[orientation];
  if (!detector) {
    // 모델 로드 실패 시 재시도
    console.log(`${orientation} 모델 재시도 중...`);
    await loadPoseModels();
    
    if (!detectors[orientation]) {
      alert(`${orientation}용 모델 로드에 실패했습니다. 페이지를 새로고침해주세요.`);
      return null;
    }
  }
  
  try {
    const poses = await detector.estimatePoses(img);
    if (!poses.length) {
      alert(`${orientation} 방향에서 사람을 인식하지 못했습니다`);
      return null;
    }
    return poses[0];
  } catch(error) {
    console.error("포즈 감지 실패:", error);
    alert("포즈 감지 중 오류가 발생했습니다");
    return null;
  }
}

// ✅ 포즈 좌표를 기존 점 시스템에 매핑 (MediaPipe Pose 랜드마크 인덱스 기반)
function mapPoseToKeypoints(pose, orientation) {
  if(!pose || !pose.keypoints) return null;
  
  const keypointMap = {};
  const keypoints = pose.keypoints;
  
  // MediaPipe Pose는 33개 랜드마크 제공 (인덱스 기반)
  // 0: nose, 7: left_ear, 8: right_ear, 11: left_shoulder, 12: right_shoulder
  // 23: left_hip, 24: right_hip, 25: left_knee, 26: right_knee
  // 27: left_ankle, 28: right_ankle
  
  if(orientation === "side") {
    // 옆모습: 보이는 쪽의 랜드마크 사용 (confidence 높은 쪽 선택)
    const leftEar = keypoints[7];
    const rightEar = keypoints[8];
    const leftShoulder = keypoints[11];
    const rightShoulder = keypoints[12];
    const leftHip = keypoints[23];
    const rightHip = keypoints[24];
    const leftKnee = keypoints[25];
    const rightKnee = keypoints[26];
    const leftAnkle = keypoints[27];
    const rightAnkle = keypoints[28];
    const nose = keypoints[0];
    
    // 어느 쪽이 더 보이는지 판단 (x 좌표가 더 작거나 큰 쪽)
    let useLeft = true;
    if(leftShoulder && rightShoulder) {
      // 어깨의 x 차이로 판단 (옆모습에서는 한쪽이 더 앞에 나와 있음)
      const leftScore = (leftShoulder.visibility || 0) + (leftHip?.visibility || 0) + (leftKnee?.visibility || 0);
      const rightScore = (rightShoulder.visibility || 0) + (rightHip?.visibility || 0) + (rightKnee?.visibility || 0);
      useLeft = leftScore >= rightScore;
    }
    
    console.log('옆모습 감지:', useLeft ? '왼쪽 사용' : '오른쪽 사용');
    
    // tragus: ear (더 보이는 쪽) - Flutter 1:1 매칭
    const ear = useLeft ? leftEar : rightEar;
    if(ear && ear.visibility >= 0.3) {
      keypointMap['tragus'] = { x: ear.x, y: ear.y, score: ear.visibility };
    } else if(!ear || ear.visibility < 0.3) {
      // ear가 안 보이면 nose 사용
      if(nose && nose.visibility >= 0.3) {
        keypointMap['tragus'] = { x: nose.x, y: nose.y + 0.03, score: nose.visibility * 0.8 };
      }
    }
    
    // acromion: 어깨 (더 보이는 쪽) - Flutter 1:1 매칭
    const shoulder = useLeft ? leftShoulder : rightShoulder;
    if(shoulder && shoulder.visibility >= 0.3) {
      keypointMap['acromion'] = { x: shoulder.x, y: shoulder.y, score: shoulder.visibility };
      
      // c7: 어깨보다 약간 위/뒤 - Flutter 1:1 매칭
      keypointMap['c7'] = { 
        x: shoulder.x - 0.02, // 어깨보다 약간 뒤
        y: shoulder.y - 0.03, // 어깨보다 약간 위
        score: shoulder.visibility * 0.9
      };
    }
    
    // hip: 골반 (더 보이는 쪽) - Flutter 1:1 매칭
    const hip = useLeft ? leftHip : rightHip;
    if(hip && hip.visibility >= 0.3) {
      keypointMap['hip'] = { x: hip.x, y: hip.y, score: hip.visibility };
      
      // asis: hip보다 약간 앞/위 - Flutter 1:1 매칭
      keypointMap['asis'] = { 
        x: hip.x + 0.03, // 앞쪽
        y: hip.y - 0.01, // 약간 위
        score: hip.visibility * 0.85 
      };
      
      // psis: hip보다 약간 뒤 - Flutter 1:1 매칭
      keypointMap['psis'] = { 
        x: hip.x - 0.03, // 뒤쪽
        y: hip.y - 0.01, // 약간 위
        score: hip.visibility * 0.85 
      };
    }
    
    // knee: 무릎 (더 보이는 쪽) - Flutter 1:1 매칭
    const knee = useLeft ? leftKnee : rightKnee;
    if(knee && knee.visibility >= 0.3) {
      keypointMap['knee'] = { x: knee.x, y: knee.y, score: knee.visibility };
    }
    
    // ankle: 발목 (더 보이는 쪽) - Flutter 1:1 매칭
    const ankle = useLeft ? leftAnkle : rightAnkle;
    if(ankle && ankle.visibility >= 0.3) {
      keypointMap['ankle'] = { x: ankle.x, y: ankle.y, score: ankle.visibility };
    }
    
    console.log('옆모습 랜드마크 매핑:', Object.keys(keypointMap));
  }
  
  if(orientation === "front") {
    // 정면: 양쪽 모두 표시
    const leftShoulder = keypoints[11];
    const rightShoulder = keypoints[12];
    const leftHip = keypoints[23];
    const rightHip = keypoints[24];
    const leftKnee = keypoints[25];
    const rightKnee = keypoints[26];
    const leftAnkle = keypoints[27];
    const rightAnkle = keypoints[28];
    
    // 어깨 (confidence threshold 낮춤)
    if(leftShoulder && leftShoulder.visibility >= 0.3) {
      keypointMap['L_acromion'] = { x: leftShoulder.x, y: leftShoulder.y, score: leftShoulder.visibility };
    }
    if(rightShoulder && rightShoulder.visibility >= 0.3) {
      keypointMap['R_acromion'] = { x: rightShoulder.x, y: rightShoulder.y, score: rightShoulder.visibility };
    }
    
    // c7: 양쪽 어깨 중간 (목 아래) - Flutter 1:1 매칭
    if(keypointMap['L_acromion'] && keypointMap['R_acromion']) {
      keypointMap['c7'] = {
        x: (keypointMap['L_acromion'].x + keypointMap['R_acromion'].x) / 2,
        y: Math.min(keypointMap['L_acromion'].y, keypointMap['R_acromion'].y) - 0.04,
        score: Math.min(keypointMap['L_acromion'].score, keypointMap['R_acromion'].score)
      };
    } else if(keypointMap['L_acromion']) {
      keypointMap['c7'] = {
        x: keypointMap['L_acromion'].x,
        y: keypointMap['L_acromion'].y - 0.04,
        score: keypointMap['L_acromion'].score * 0.8
      };
    } else if(keypointMap['R_acromion']) {
      keypointMap['c7'] = {
        x: keypointMap['R_acromion'].x,
        y: keypointMap['R_acromion'].y - 0.04,
        score: keypointMap['R_acromion'].score * 0.8
      };
    }
    
    // 골반 (ASIS)
    if(leftHip && leftHip.visibility >= 0.3) {
      keypointMap['L_asis'] = { x: leftHip.x, y: leftHip.y, score: leftHip.visibility };
    }
    if(rightHip && rightHip.visibility >= 0.3) {
      keypointMap['R_asis'] = { x: rightHip.x, y: rightHip.y, score: rightHip.visibility };
    }
    
    // 무릎
    if(leftKnee && leftKnee.visibility >= 0.3) {
      keypointMap['L_knee'] = { x: leftKnee.x, y: leftKnee.y, score: leftKnee.visibility };
    }
    if(rightKnee && rightKnee.visibility >= 0.3) {
      keypointMap['R_knee'] = { x: rightKnee.x, y: rightKnee.y, score: rightKnee.visibility };
    }
    
    // 발목
    if(leftAnkle && leftAnkle.visibility >= 0.3) {
      keypointMap['L_ankle'] = { x: leftAnkle.x, y: leftAnkle.y, score: leftAnkle.visibility };
    }
    if(rightAnkle && rightAnkle.visibility >= 0.3) {
      keypointMap['R_ankle'] = { x: rightAnkle.x, y: rightAnkle.y, score: rightAnkle.visibility };
    }
    
    console.log('정면 랜드마크 매핑:', Object.keys(keypointMap));
  }
  
  return keypointMap;
}

// ✅ 포즈 감지 후 기존 시스템에 통합
async function applyPoseDetection(img, sessionName) {
  const session = sessions[sessionName];
  if(!session) return;
  
  // 세션의 orientation 사용 (기본값: side)
  if(!session.poseData) {
    session.poseData = { orientation: "side", landmarks: null };
  }
  const orientation = session.poseData.orientation || "side";
  
  console.log(`${sessionName} 세션: ${orientation === "side" ? "옆모습" : "정면"} 포즈 감지 시작`);
  
  const pose = await detectPose(img, orientation);
  if(!pose) return;
  
  // 포즈 정보 저장
  session.poseData.landmarks = pose.keypoints;
  
  // 기존 점 시스템에 매핑 (선택적)
  const keypointMap = mapPoseToKeypoints(pose, orientation);
  if(keypointMap) {
    // 매핑된 키포인트를 기존 점 시스템에 적용
    const map = orientation === "front" ? session.frontPoints : session.sidePoints;
    
    // 원본 크기 계산 (아직 없으면 계산)
    if(originalCanvasSize.width === 0) {
      const canvasWrap = cv.parentElement;
      const maxW = canvasWrap.clientWidth - 24;
      const maxH = canvasWrap.clientHeight - 24;
      const r = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight);
      originalCanvasSize.width = Math.round(img.naturalWidth * r);
      originalCanvasSize.height = Math.round(img.naturalHeight * r);
    }
    
    for(const [key, value] of Object.entries(keypointMap)) {
      if(value && value.x !== undefined && value.y !== undefined && value.score >= 0.2) {
        // MediaPipe는 정규화된 좌표(0-1)를 제공하므로 픽셀 좌표로 변환
        // 이미지 크기에 맞게 좌표 변환
        const imgX = value.x * img.naturalWidth;
        const imgY = value.y * img.naturalHeight;
        
        // 캔버스 크기에 맞게 스케일링
        const scaleX = originalCanvasSize.width / img.naturalWidth;
        const scaleY = originalCanvasSize.height / img.naturalHeight;
        
        const finalX = imgX * scaleX;
        const finalY = imgY * scaleY;
        
        map.set(key, {
          x: finalX,
          y: finalY
        });
        
        console.log(`✅ ${key} 매핑: 원본(${value.x.toFixed(3)}, ${value.y.toFixed(3)}) → 이미지픽셀(${imgX.toFixed(1)}, ${imgY.toFixed(1)}) → 캔버스(${finalX.toFixed(1)}, ${finalY.toFixed(1)}) [confidence: ${value.score.toFixed(2)}]`);
      }
    }
    
    // 화면 업데이트
    draw();
    computeAll(); // 전체 분석 실행
    console.log(`✅ ${sessionName} 포즈 감지 및 좌표 적용 완료 (${orientation === "side" ? "옆모습" : "정면"})`);
  }
  
  return pose;
}

// ✅ 포즈 감지는 위의 업로드 핸들러에서 자동으로 호출됨
// applyPoseDetection 함수가 이미 위에서 정의되어 있음
</script>
  </body>
</html>
