<!DOCTYPE html>
<html lang="ko">
  <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DIT 자세 분석 AI (최종 통합버전)</title>
<!-- ✅ 3. favicon.ico 404 오류 해결 (선택사항) -->
<link rel="icon" type="image/png" href="/posture-ai-kor/pwa-192x192.png">
<style>
:root {
  --bg: #0b0f14;
  --panel: rgba(30, 34, 42, 0.7);
  --accent: #7c9cff;
  --accent2: #ffb86c;
  --ink: #e7eef7;
  --muted: #9bb0c7;
  --radius: 18px;
  --font-body: 'Apple SD Gothic Neo', 'Malgun Gothic', 'Nanum Gothic', 'Noto Sans KR', 'Pretendard', 'Segoe UI', 'Roboto', sans-serif;
}

/* PDF용 안전 폰트 (구글 폰트 제외) */
.pdf-safe {
  font-family: var(--font-body), sans-serif !important;
  letter-spacing: 0.2px;
  line-height: 1.45;
}

.pdf-safe * {
  font-family: inherit !important;
}
* { box-sizing: border-box; }
html, body {
  margin: 0; 
  padding: 0;
  height: 100%;
  -webkit-overflow-scrolling: touch;
}
body {
  background: var(--bg); 
  color: var(--ink);
  font-family: var(--font-body);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  overflow-x: hidden;
}
button, input, select, textarea {
  font-family: var(--font-body);
}
.panel {
  background: var(--panel);
  backdrop-filter: blur(20px);
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 10px 25px rgba(0,0,0,0.4);
}
.sidebar { 
  padding: 12px; 
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 50vh;
  -webkit-overflow-scrolling: touch;
}
.title { 
  font-size: 16px; 
  font-weight:800; 
  margin-bottom: 6px; 
  line-height: 1.3;
}
.muted { 
  color: var(--muted); 
  font-size: 11px; 
  line-height: 1.4;
}
.btn {
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  padding: 10px 14px;
  background: rgba(255,255,255,0.05);
  color: var(--ink);
  cursor: pointer;
  font-size: 13px;
  width: 100%;
  text-align: center;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.btn:hover, .btn:active { 
  background: rgba(255,255,255,0.12); 
}
.seg { 
  display: flex; 
  border-radius: 10px; 
  overflow: hidden; 
  margin-top: 8px; 
  gap: 4px;
}
.seg button { 
  flex:1; 
  border:0; 
  background: rgba(255,255,255,0.04); 
  color:var(--muted); 
  padding:10px 8px; 
  cursor:pointer; 
  font-size: 13px;
  touch-action: manipulation;
}
.seg button.active { 
  background: rgba(124,156,255,0.25); 
  color:var(--ink); 
}
label.btn { 
  display: block;
  width: 100%;
  margin-bottom: 8px;
  position: relative;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
label.btn input { 
  position: absolute;
  opacity: 0;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  cursor: pointer;
  z-index: 10;
  pointer-events: auto;
  -webkit-tap-highlight-color: transparent;
  font-size: 0;
  margin: 0;
  padding: 0;
  border: 0;
}
.tbl { 
  width:100%; 
  border-collapse:collapse; 
  font-size:11px; 
  overflow-x: auto;
  display: table;
  -webkit-overflow-scrolling: touch;
}
.tbl th,.tbl td { 
  border-bottom:1px solid rgba(255,255,255,0.1); 
  padding:6px 4px; 
  text-align: center;
  font-size: 10px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.canvasWrap { 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  flex: 1;
  min-height: 50vh;
  padding: 8px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
}
.canvasWrap.zoomed {
  align-items: flex-start;
  justify-content: flex-start;
}
canvas { 
  border-radius:var(--radius); 
  background:#0a0e13; 
  cursor: crosshair; 
  touch-action: none; /* 드래그와 스크롤을 JavaScript로 제어 */
  display: block;
  flex-shrink: 0;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
  user-select: none;
  -webkit-user-select: none;
}
</style>
  </head>
  <body>
<aside class="panel sidebar" style="order: 1;">
  <div class="title">📸 DIT 자세 분석 AI</div>
  <div class="muted">파일 업로드 → 점을 드래그로 조정 → 각도 자동 계산</div>

  <div class="seg">
    <button id="btnBefore" class="active">Before</button>
    <button id="btnAfter">After</button>
  </div>
  <div style="margin-top:8px; display:flex; flex-direction:column; gap:8px;">
    <div class="seg" style="margin-bottom:4px;">
      <button id="btnOrientationSide" class="active">📐 옆모습</button>
      <button id="btnOrientationFront">📷 정면</button>
    </div>
    <label class="btn" for="filePicker">📷 파일 선택
      <input id="filePicker" type="file" accept="image/*">
    </label>
    <label class="btn" for="cameraPicker">📸 직접 촬영
      <input id="cameraPicker" type="file" accept="image/*" capture="environment">
    </label>
    <button class="btn" id="btnReset">↺ 초기화</button>
    <button class="btn" id="btnCalibrate" style="background: rgba(255,184,108,0.2);">📏 캘리브레이션</button>
  </div>

  <div id="calibrationPanel" style="margin-top:12px; padding:10px; background:rgba(255,184,108,0.1); border-radius:10px; display:none;">
    <div class="muted" style="margin-bottom:8px; font-weight:600;">📏 캘리브레이션</div>
    <div class="muted" style="font-size:11px; margin-bottom:8px;">기준 마커 두 점을 찍고 실제 길이(cm)를 입력하세요</div>
    <div style="margin-bottom:8px;">
      <input type="number" id="calibrationLength" placeholder="실제 길이 (cm)" step="0.1" min="0.1" style="width:100%; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); background:rgba(0,0,0,0.3); color:var(--ink);">
    </div>
    <div class="muted" style="font-size:11px; margin-bottom:4px;">점 1: <span id="calPoint1">클릭하여 선택</span></div>
    <div class="muted" style="font-size:11px; margin-bottom:8px;">점 2: <span id="calPoint2">클릭하여 선택</span></div>
    <button class="btn" id="btnCalibrateConfirm" style="width:100%; margin-bottom:8px;">✅ 계산</button>
    <button class="btn" id="btnCalibrateCancel" style="width:100%;">❌ 취소</button>
    <div id="calibrationResult" class="muted" style="font-size:11px; margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);"></div>
  </div>

  <div style="margin-top:10px; display:flex; flex-direction:column; gap:8px;">
    <button class="btn" id="btnEditCoords" style="background: rgba(124,156,255,0.2);">✏️ 좌표 수정 모드</button>
    <button class="btn" id="btnSaveJSON">💾 좌표 저장</button>
    <button class="btn" id="btnLoadJSON">📂 좌표 불러오기</button>
    <button class="btn" id="btnPDF">📄 PDF 저장</button>
    <button class="btn" id="btnImage">🖼️ 그림으로 저장</button>
    <button class="btn" id="btnShare">📤 공유하기</button>
    <button class="btn" id="btnAIAnalysis" style="background: rgba(46,196,182,0.3); border: 1px solid rgba(46,196,182,0.5);">🤖 AI 분석</button>
  </div>

  <!-- 골반 결과 표시 영역 -->
  <div id="pelvicDesc" style="white-space: pre-line; line-height:1.6; font-size:15px; margin-top:10px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px; display:none;"></div>

  <div id="coordEditPanel" style="margin-top:12px; padding:10px; background:rgba(124,156,255,0.1); border-radius:10px; display:none;">
    <div class="muted" style="margin-bottom:8px; font-weight:600;">좌표 수정</div>
    <div style="margin-bottom:8px;">
      <div class="muted" style="font-size:11px; margin-bottom:4px;">확대 배율</div>
      <select id="zoomLevel" class="btn" style="width:100%; padding:6px; margin-bottom:8px;">
        <option value="1">원본 크기 (1배)</option>
        <option value="2">2배 확대 (스크롤 가능)</option>
        <option value="3">3배 확대 (스크롤 가능)</option>
        <option value="4">4배 확대 (스크롤 가능)</option>
      </select>
      <div class="muted" style="font-size:10px; margin-top:4px; margin-bottom:8px; line-height:1.4;">확대 시 양손으로 드래그하여 이동 가능</div>
    </div>
    <div style="margin-bottom:8px;">
      <select id="coordSelectPoint" class="btn" style="width:100%; padding:6px; margin-bottom:6px;">
        <option value="">점 선택...</option>
        <!-- 옵션은 JavaScript에서 동적으로 업데이트됨 -->
      </select>
    </div>
    <div style="display:flex; flex-direction:column; gap:6px; margin-bottom:6px;">
      <div>
        <div class="muted" style="font-size:11px; margin-bottom:4px;">X 좌표</div>
        <div style="display:flex; gap:4px; align-items:center;">
          <input type="number" id="coordX" class="btn" style="flex:1; padding:8px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.1);" step="0.1" placeholder="X">
          <button class="btn" id="coordXDec" style="padding:8px 12px; background:rgba(255,107,107,0.2); border:1px solid rgba(255,107,107,0.3); min-width:40px;">−</button>
          <button class="btn" id="coordXInc" style="padding:8px 12px; background:rgba(46,196,182,0.2); border:1px solid rgba(46,196,182,0.3); min-width:40px;">+</button>
        </div>
      </div>
      <div>
        <div class="muted" style="font-size:11px; margin-bottom:4px;">Y 좌표</div>
        <div style="display:flex; gap:4px; align-items:center;">
          <input type="number" id="coordY" class="btn" style="flex:1; padding:8px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.1);" step="0.1" placeholder="Y">
          <button class="btn" id="coordYDec" style="padding:8px 12px; background:rgba(255,107,107,0.2); border:1px solid rgba(255,107,107,0.3); min-width:40px;">−</button>
          <button class="btn" id="coordYInc" style="padding:8px 12px; background:rgba(46,196,182,0.2); border:1px solid rgba(46,196,182,0.3); min-width:40px;">+</button>
        </div>
      </div>
    </div>
    <button class="btn" id="coordApply" style="width:100%; background:rgba(124,156,255,0.3);">적용</button>
    <button class="btn" id="coordCancel" style="width:100%; margin-top:6px; background:rgba(255,255,255,0.05);">취소</button>
  </div>

  <div style="margin-top:12px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px;">
    <div class="muted" style="margin-bottom:6px;">현재 세션: <span id="currentSession">Before</span></div>
    
    <!-- 주요 지표 (간략 표시) -->
    <div style="margin-bottom:8px; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">
      <div class="muted" style="margin-bottom:4px;">CVA: <span id="dispCva">—</span></div>
      <div class="muted" style="margin-bottom:4px;">TRUNK: <span id="dispPel">—</span></div>
      <div class="muted" style="margin-bottom:4px;">KNEE: <span id="dispKnee">—</span></div>
    </div>
    
    <!-- 전체 분석 항목 (16가지) -->
    <div id="allMetricsPanel" style="max-height:300px; overflow-y:auto; margin-bottom:8px;">
      <div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#7c9cff;">📊 전체 분석 항목</div>
      <div id="allMetricsList" style="font-size:11px; line-height:1.6;"></div>
    </div>
    
    <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.1);">
      <div style="font-size:14px; font-weight:600; margin-bottom:8px;">📊 체형 종합 점수</div>
      <div id="totalScore" style="font-size:32px; font-weight:800; margin-bottom:8px;">—</div>
      <div id="scoreReason" class="muted" style="font-size:11px; line-height:1.4; margin-bottom:8px;"></div>
      <div id="pdsScore" class="muted" style="font-size:12px; margin-top:6px;">PDS: <span id="pdsValue">—</span></div>
    </div>
  </div>


  <!-- AI PRO 리포트 표시 영역 -->
  <div id="report-box" style="margin-top:12px; padding:12px; background:rgba(46,196,182,0.1); border-radius:10px; display:none; white-space: pre-wrap; font-size:12px; line-height:1.5; max-height:400px; overflow-y:auto; color:var(--ink); font-family: 'Noto Sans KR', sans-serif;"></div>
  
  <!-- 16개 항목 상세 설명 -->
  <div id="metricsDescPanel" style="margin-top:12px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#7c9cff;">📋 분석 항목 설명</div>
    <div style="font-size:11px; color:#7c9cff; margin-bottom:8px; padding:4px 8px; background:rgba(124,156,255,0.2); border-radius:4px; display:inline-block;">측면 항목 (옆모습)</div>
    <div style="font-size:11px; color:#2ec4b6; margin-bottom:8px; padding:4px 8px; background:rgba(46,196,182,0.2); border-radius:4px; display:inline-block; margin-left:8px;">정면 항목 (앞모습)</div>
    <div id="metricsDescContent" style="max-height:400px; overflow-y:auto; font-size:11px; line-height:1.6;">
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">CVA (Craniovertebral Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 귀 뒤 유양돌기(Tragus)와 제7경추(C7) 사이의 각도<br>
          <strong>의미:</strong> 거북목 자세의 정도를 평가하는 가장 중요한 지표입니다. 각도가 작을수록 머리가 앞으로 나온 상태입니다.<br>
          <strong>정상 범위:</strong> ≥50° (각도가 클수록 좋음)<br>
          <strong>임상적 의미:</strong> CVA &lt; 50°는 전방두부자세(FHP)를 의미하며, 경추 근육 긴장, 두통, 목 통증의 원인이 됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">HPD (Head Protrusion Distance)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 귀(Tragus)와 어깨(Acromion) 사이의 수평 거리<br>
          <strong>의미:</strong> 머리가 몸통에서 얼마나 앞으로 돌출되어 있는지를 cm 단위로 측정합니다.<br>
          <strong>정상 범위:</strong> ≤2cm<br>
          <strong>임상적 의미:</strong> 2cm 초과 시 경추 부담 증가, 상부 승모근 과긴장, 목-어깨 통증 유발 가능성이 높습니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">TIA (Trunk Inclination Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 어깨(Acromion)와 골반(Hip)을 연결한 선과 수직선 사이의 각도<br>
          <strong>의미:</strong> 몸통의 앞뒤 기울기를 평가하여 전체적인 체간 정렬을 확인합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 10° 초과 시 요추 과전만 또는 평평한 등(Flat Back) 위험이 있습니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">SAA (Scapular Alignment Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 어깨(Acromion)와 골반 후면(PSIS)을 연결한 선과 수평선 사이의 각도<br>
          <strong>의미:</strong> 어깨뼈의 정렬 상태와 상부 체간의 자세를 평가합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 이상 시 견갑골 날개뼈(Winging) 또는 어깨 전방 말림이 의심됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">PTA (Pelvic Tilt Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 후상장골극(PSIS)과 전상장골극(ASIS)을 연결한 선과 수평선 사이의 각도<br>
          <strong>의미:</strong> 골반의 전방 또는 후방 기울기를 평가하는 핵심 지표입니다.<br>
          <strong>해석 기준:</strong> PSIS 기준으로 ASIS와 같은 높이 = 0도, ASIS가 PSIS보다 위쪽에 있으면 = 골반 후방경사(음수, -1도부터), ASIS가 PSIS보다 밑쪽에 있으면 = 골반 전방경사(양수, 1도부터)<br>
          <strong>정상 범위:</strong> 0-15° (약간의 전방 경사는 정상)<br>
          <strong>임상적 의미:</strong> &gt;15° (양수)는 골반 전방 경사(요추 과전만), &lt;0° (음수)는 골반 후방 경사(요추 평평)를 의미합니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">KA (Knee Alignment Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 고관절(Hip)-무릎(Knee)-발목(Ankle) 세 점이 이루는 각도<br>
          <strong>의미:</strong> 무릎 관절의 신전(펴짐) 정도를 평가합니다.<br>
          <strong>정상 범위:</strong> 175-185°<br>
          <strong>임상적 의미:</strong> &lt;175°는 무릎 과굴곡(슬개건 부담), &gt;185°는 무릎 과신전(관절 불안정성)을 나타냅니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">Tibial Angle (경골 경사각)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 무릎(Knee)과 발목(Ankle)을 연결한 선과 수직선 사이의 각도<br>
          <strong>의미:</strong> 정강이(경골)의 앞뒤 기울기를 측정합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 과도한 경사는 발목 불안정성 및 종아리 근육 불균형을 유발할 수 있습니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">Q-Angle (대퇴사두근 각도)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> ASIS-슬개골(Patella)-경골조면(Tibial Tuberosity) 세 점이 이루는 각도<br>
          <strong>의미:</strong> 대퇴사두근의 당김 방향을 평가하여 무릎 정렬을 확인합니다.<br>
          <strong>정상 범위:</strong> 남성 10-15°, 여성 15-20°<br>
          <strong>임상적 의미:</strong> &gt;20°는 슬개골 외측 전위 및 슬개대퇴 통증 증후군의 위험 요인입니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">Knee Deviation (무릎 높이 차)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 좌우 무릎의 높이 차이를 각도로 환산<br>
          <strong>의미:</strong> 양쪽 무릎의 수평 정렬을 평가하여 골반 기울기를 간접적으로 확인합니다.<br>
          <strong>정상 범위:</strong> 0-3°<br>
          <strong>임상적 의미:</strong> 3° 초과 시 골반 회전(Pelvic Rotation) 또는 척추 측만증이 의심됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">LLD (Leg Length Discrepancy)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 좌우 다리 길이(Hip-Ankle) 차이를 cm 단위로 측정<br>
          <strong>의미:</strong> 기능적 또는 구조적 다리 길이 차이를 평가합니다.<br>
          <strong>정상 범위:</strong> ≤1cm<br>
          <strong>임상적 의미:</strong> 1cm 초과 시 골반 비대칭, 척추 측만, 보행 이상이 발생할 수 있으며 보상 자세로 인한 만성 통증의 원인이 됩니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">GSB (Global Sagittal Balance)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 귀(Tragus)와 발목(Ankle)의 수평 거리<br>
          <strong>의미:</strong> 전신의 시상면(옆에서 본) 균형을 종합적으로 평가하는 지표입니다.<br>
          <strong>정상 범위:</strong> ≤2cm<br>
          <strong>임상적 의미:</strong> 2cm 초과 시 중력 중심선 이탈로 인한 전체 근골격계 부담 증가 및 에너지 소모가 증가합니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">HPA (Head–Pelvis Angle)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 머리(Tragus)와 골반(PSIS)을 연결한 선과 수직선 사이의 각도<br>
          <strong>의미:</strong> 머리와 골반의 상대적 위치 관계를 통해 전신 자세를 종합 평가합니다.<br>
          <strong>정상 범위:</strong> 0-10°<br>
          <strong>임상적 의미:</strong> 이상 각도는 머리-골반 분절 간 협응 부족을 나타내며, 전신 자세 불균형의 지표입니다.
        </div>
      </details>
      <details style="margin-bottom:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#7c9cff; padding:4px 0;">PDS (Postural Deviation Score)</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 방법:</strong> 위 15개 항목의 비정상 정도를 점수화하여 합산<br>
          <strong>의미:</strong> 전체적인 자세 불균형의 정도를 하나의 숫자로 요약한 종합 지표입니다.<br>
          <strong>정상 범위:</strong> 0-10점<br>
          <strong>분류:</strong> 0-10 (정상), 11-20 (경미), 21-30 (중등도), 31+ (심각)<br>
          <strong>임상적 의미:</strong> 점수가 높을수록 다양한 자세 문제가 복합적으로 나타나며, 전문적인 교정 치료가 필요합니다.
        </div>
      </details>
      
      <!-- 정면 항목 (앞모습) - 색상: #2ec4b6 -->
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">STA (Shoulder Tilt Angle) - 어깨 좌우 기울기</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(L_acromion, R_acromion), horizontal)<br>
          <strong>측정 방법:</strong> ① 카메라를 가슴 중앙 높이에 고정하고 피험자는 정면으로 선 자세 유지. ② 좌·우 Acromion의 좌표를 인식. ③ Δy를 각도로 변환(atan(Δy / Δx)).<br>
          <strong>정상 범위:</strong> ≤ 3°<br>
          <strong>해석:</strong> ↑ → 어깨 좌우 불균형, 승모근·능형근 긴장 차이 가능성.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">POA (Pelvic Obliquity Angle) - 골반 좌우 기울기</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(L_ASIS, R_ASIS), horizontal)<br>
          <strong>측정 방법:</strong> ① 카메라를 골반 높이에 맞추고 정면에서 촬영. ② 좌·우 ASIS를 인식하고 Δy 계산. ③ 각도 계산: POA = atan(Δy / Δx).<br>
          <strong>정상 범위:</strong> ≤ 3°<br>
          <strong>해석:</strong> ↑ → 골반 좌우 비대칭 / 하지 길이 차 / 요추 측만 가능성.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">LLD (Leg Length Discrepancy) - 하지 길이 차</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> |distance(L_ASIS, L_ankle) - distance(R_ASIS, R_ankle)|<br>
          <strong>측정 방법:</strong> ① 전신이 보이도록 정면 촬영. ② 좌·우 ASIS 및 발목(Ankle) 좌표 인식. ③ 거리(cm) 환산(pxPerCm 보정).<br>
          <strong>정상 범위:</strong> ≤ 1 cm<br>
          <strong>해석:</strong> ↑ → 구조적 또는 기능적 하지 길이 차 존재.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">TD (Trunk Deviation) - 체간 편위</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> horizontal deviation(C7, midline(L_ankle, R_ankle))<br>
          <strong>측정 방법:</strong> ① 카메라를 정면, 양 발목이 수평에 오도록 촬영. ② L/R Ankle 좌표로 중간선(midpoint) 계산. ③ C7의 수평 거리 편차 계산.<br>
          <strong>정상 범위:</strong> ± 2°<br>
          <strong>해석:</strong> ↑ → 체간이 좌우로 기울어짐 / 체중 중심 불균형.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">HTA (Head Tilt Angle) - 머리 좌우 기울기</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(L_tragus, R_tragus), horizontal)<br>
          <strong>측정 방법:</strong> ① 정면에서 Tragus 좌우가 명확히 보이도록 촬영. ② 두 점의 y좌표 차이 계산 → 각도로 변환.<br>
          <strong>정상 범위:</strong> ≤ 3°<br>
          <strong>해석:</strong> ↑ → 경부 측굴 또는 측만성 긴장 패턴.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">SPP (Shoulder–Pelvis Parallelism) - 어깨-골반 평행도</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle_diff(line(L_acromion, R_acromion), line(L_ASIS, R_ASIS))<br>
          <strong>측정 방법:</strong> ① 정면 촬영 시 L/R 어깨와 L/R ASIS가 모두 보여야 함. ② 두 선의 각도 차 계산.<br>
          <strong>정상 범위:</strong> 0–3°<br>
          <strong>해석:</strong> ↑ → 체간 회전 / 골반 비틀림 / 척추 회전성 불균형.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">KAS (Knee Alignment Symmetry) - 무릎 정렬 대칭성</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle_diff(line(L_knee, L_ankle), line(R_knee, R_ankle))<br>
          <strong>측정 방법:</strong> ① 정면에서 무릎과 발목 모두 인식. ② 각 무릎–발목 수직선의 각도 비교.<br>
          <strong>정상 범위:</strong> 대칭(±2° 이내)<br>
          <strong>해석:</strong> ↑ → 한쪽 내반/외반 또는 하지 회전 패턴.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">LLAS (Lower Limb Axis Symmetry) - 하지 축 대칭성</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle_diff(line(L_ASIS, L_ankle), line(R_ASIS, R_ankle))<br>
          <strong>측정 방법:</strong> ① 정면에서 하지 전체 촬영. ② 각 하지축 라인 각도 비교.<br>
          <strong>정상 범위:</strong> ±2°<br>
          <strong>해석:</strong> ↑ → 한쪽 회내·회외 또는 하지 회전성 불균형.
        </div>
      </details>
      
      <details style="margin-bottom:8px; border-left:3px solid #2ec4b6; padding-left:8px;">
        <summary style="cursor:pointer; font-weight:600; color:#2ec4b6; padding:4px 0;">FBA (Foot Base Angle) - 발 정렬 각도</summary>
        <div style="padding:8px 0 0 12px; color:var(--muted); line-height:1.5;">
          <strong>측정 기준:</strong> angle(line(ankle, toe), body midline)<br>
          <strong>측정 방법:</strong> ① 피험자는 발끝까지 보이게 정면으로 선다. ② 발 중심선(ankle–toe)과 몸 중심선 간 각도 계산.<br>
          <strong>정상 범위:</strong> 0–10°<br>
          <strong>해석:</strong> ↑ → 과도한 외회전(회외) / ↓ → 회내 경향.
        </div>
      </details>
    </div>
  </div>
  
  <!-- 실시간 분석 결과 패널 -->
  <div id="liveAnalysisPanel" style="margin-top:12px; padding:12px; background:rgba(124,156,255,0.1); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#7c9cff;">📊 실시간 AI 분석 결과</div>
    <div id="livePDS" style="font-size:16px; font-weight:700; margin-bottom:8px; color:#7c9cff;">PDS: —</div>
    <div id="livePatterns" style="font-size:12px; line-height:1.6;"></div>
  </div>

  <!-- 근육 상태 분석 (먼저 표시) -->
  <div id="musclePanel" style="margin-top:12px; padding:12px; background:rgba(255,184,108,0.1); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#ffb86c; font-family: 'Noto Sans KR', sans-serif;">💪 근육 상태 분석</div>
    <div id="muscleTight" style="margin-bottom:8px;">
      <div class="muted" style="font-size:12px; margin-bottom:4px; font-family: 'Noto Sans KR', sans-serif;">🔴 긴장된 근육:</div>
      <div id="muscleTightList" style="font-size:12px; color:#ff6b6b; line-height:1.6; font-family: 'Noto Sans KR', sans-serif;"></div>
    </div>
    <div id="muscleWeak" style="margin-bottom:8px;">
      <div class="muted" style="font-size:12px; margin-bottom:4px; font-family: 'Noto Sans KR', sans-serif;">🔵 약화된 근육:</div>
      <div id="muscleWeakList" style="font-size:12px; color:#7c9cff; line-height:1.6; font-family: 'Noto Sans KR', sans-serif;"></div>
    </div>
  </div>

  <!-- AI 체형 분석 (근육 상태 분석 다음) -->
  <div id="aiCommentPanel" style="margin-top:12px; padding:12px; background:rgba(46,196,182,0.1); border-radius:10px; display:none; font-family: 'Noto Sans KR', sans-serif;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#2ec4b6; font-family: 'Noto Sans KR', sans-serif;">🤖 AI 체형 분석</div>
    <div id="aiComment" class="muted" style="font-size:12px; line-height:1.6; font-family: 'Noto Sans KR', sans-serif; color:var(--ink);"></div>
    
    <!-- 개인별 체형 분석 설명 -->
    <div id="postureTypeDesc" style="margin-top:12px; padding:10px; background:rgba(255,255,255,0.1); border-radius:8px; border-left:3px solid #2ec4b6; font-family: 'Noto Sans KR', sans-serif;">
      <div style="font-size:13px; font-weight:600; margin-bottom:6px; color:#2ec4b6; font-family: 'Noto Sans KR', sans-serif;">📌 체형 유형 분석</div>
      <div id="postureTypeContent" style="font-size:12px; line-height:1.6; color:var(--muted); font-family: 'Noto Sans KR', sans-serif;"></div>
    </div>
  </div>

  <!-- 추천 운동 -->
  <div id="exercisePanel" style="margin-top:12px; padding:12px; background:rgba(46,196,182,0.15); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#2ec4b6; font-family: 'Noto Sans KR', sans-serif;">🏋️ 추천 운동</div>
    <div id="exerciseList" style="font-size:12px; line-height:1.6; font-family: 'Noto Sans KR', sans-serif;"></div>
  </div>

  <!-- 필라테스 세션 추천 -->
  <div id="pilatesPanel" style="margin-top:12px; padding:12px; background:rgba(156,136,255,0.15); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#9c88ff; font-family: 'Noto Sans KR', sans-serif;">🧘 필라테스 세션 추천</div>
    <div id="pilatesList" style="font-size:12px; line-height:1.6; font-family: 'Noto Sans KR', sans-serif;"></div>
  </div>

  <!-- 필라테스 운동 상세 설명 모달 -->
  <div id="pilatesExerciseModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000; overflow-y:auto; padding:20px; box-sizing:border-box;">
    <div style="max-width:600px; margin:0 auto; background:#1a1a2e; border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(0,0,0,0.5);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h3 id="modalExerciseTitle" style="margin:0; color:#9c88ff; font-size:18px; font-weight:600;"></h3>
        <button id="closeModalBtn" style="background:none; border:none; color:#fff; font-size:24px; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center;">&times;</button>
      </div>
      <div id="modalExerciseContent" style="color:#e0e0e0; line-height:1.8; font-size:13px;">
        <!-- 운동 상세 설명이 여기에 표시됩니다 -->
      </div>
    </div>
  </div>


  <!-- 결론 및 향후 권장사항 (회원 이름 포함, 임상 중심) -->
  <div id="conclusionPanel" style="margin-top:12px; padding:12px; background:rgba(46,196,182,0.1); border-radius:10px; display:none;">
    <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#2ec4b6; font-family: 'Noto Sans KR', sans-serif;">✅ 결론 및 향후 권장사항</div>
    <div id="conclusionContent" style="font-size:12px; line-height:1.8; color:var(--ink); font-family: 'Noto Sans KR', sans-serif; white-space:pre-wrap; word-wrap:break-word;"></div>
  </div>

  <!-- 항목 (Before/After 비교 테이블) -->
  <div style="margin-top:12px; max-height:400px; overflow-y:auto;">
    <table class="tbl">
      <thead><tr><th>항목</th><th>Before</th><th>After</th><th>변화</th><th>정상</th></tr></thead>
      <tbody>
        <tr><td>CVA(두개경추각)</td><td id="cmpCvaB">—</td><td id="cmpCvaA">—</td><td id="cmpCvaD">—</td><td>≥50°</td></tr>
        <tr><td>HPD(두부전방이동)</td><td id="cmpHpdB">—</td><td id="cmpHpdA">—</td><td id="cmpHpdD">—</td><td>≤2cm</td></tr>
        <tr><td>TIA(체간경사각)</td><td id="cmpTiaB">—</td><td id="cmpTiaA">—</td><td id="cmpTiaD">—</td><td>0-10°</td></tr>
        <tr><td>SAA(어깨전방각)</td><td id="cmpSaaB">—</td><td id="cmpSaaA">—</td><td id="cmpSaaD">—</td><td>0-10°</td></tr>
        <tr><td>PTA(골반 전후경사각)</td><td id="cmpPtaB">—</td><td id="cmpPtaA">—</td><td id="cmpPtaD">—</td><td>0-15°</td></tr>
        <tr><td>KA(무릎각)</td><td id="cmpKaB">—</td><td id="cmpKaA">—</td><td id="cmpKaD">—</td><td>175-185°</td></tr>
        <tr><td>Tibial(경골경사각)</td><td id="cmpTibialB">—</td><td id="cmpTibialA">—</td><td id="cmpTibialD">—</td><td>0-10°</td></tr>
        <tr><td>Q-Angle(Q각)</td><td id="cmpQangleB">—</td><td id="cmpQangleA">—</td><td id="cmpQangleD">—</td><td>10-20°</td></tr>
        <tr><td>Knee Dev(무릎편위)</td><td id="cmpKneedevB">—</td><td id="cmpKneedevA">—</td><td id="cmpKneedevD">—</td><td>0-3°</td></tr>
        <tr><td>LLD(하지길이차)</td><td id="cmpLldB">—</td><td id="cmpLldA">—</td><td id="cmpLldD">—</td><td>≤1cm</td></tr>
        <tr><td>GSB(중력중심선)</td><td id="cmpGsbB">—</td><td id="cmpGsbA">—</td><td id="cmpGsbD">—</td><td>≤2cm</td></tr>
        <tr><td>HPA(고관절각)</td><td id="cmpHpaB">—</td><td id="cmpHpaA">—</td><td id="cmpHpaD">—</td><td>0-10°</td></tr>
        <tr><td>PDS(자세점수)</td><td id="cmpPdsB">—</td><td id="cmpPdsA">—</td><td id="cmpPdsD">—</td><td>0-10</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">STA(어깨기울기각)</td><td id="cmpStaB">—</td><td id="cmpStaA">—</td><td id="cmpStaD">—</td><td>≤3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">POA(골반기울기각)</td><td id="cmpPoaB">—</td><td id="cmpPoaA">—</td><td id="cmpPoaD">—</td><td>≤3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">LLD(하지길이차)</td><td id="cmpLldfB">—</td><td id="cmpLldfA">—</td><td id="cmpLldfD">—</td><td>≤1cm</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">TD(체간편위)</td><td id="cmpTdB">—</td><td id="cmpTdA">—</td><td id="cmpTdD">—</td><td>0-3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">HTA(머리기울기각)</td><td id="cmpHtaB">—</td><td id="cmpHtaA">—</td><td id="cmpHtaD">—</td><td>≤3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">SPP(어깨골반평행도)</td><td id="cmpSppB">—</td><td id="cmpSppA">—</td><td id="cmpSppD">—</td><td>0-3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">KAS(무릎정렬대칭성)</td><td id="cmpKasB">—</td><td id="cmpKasA">—</td><td id="cmpKasD">—</td><td>0-3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">LLAS(하지축대칭성)</td><td id="cmpLlasB">—</td><td id="cmpLlasA">—</td><td id="cmpLlasD">—</td><td>0-3°</td></tr>
        <tr style="background:rgba(46,196,182,0.1);"><td style="color:#2ec4b6; font-weight:600;">FBA(발정렬각)</td><td id="cmpFbaB">—</td><td id="cmpFbaA">—</td><td id="cmpFbaD">—</td><td>0-3°</td></tr>
        <tr style="background:#f0f0f0; font-weight:600;"><td>체형 점수</td><td id="cmpScoreB">—</td><td id="cmpScoreA">—</td><td id="cmpScoreD">—</td><td>0–100</td></tr>
      </tbody>
    </table>
  </div>
</aside>
<main class="panel canvasWrap" style="order: 2;">
  <canvas id="cv" width="1600" height="1000"></canvas>
</main>

<!-- ✅ 전역 충돌 방어 및 강제 등록 (최우선 실행) -->
<script>
// ---- 전역 충돌 방어 ----
// sessions는 나중에 객체로 정의되므로 여기서는 undefined 체크만
if (typeof window.sessions === 'undefined') {
  window.sessions = null; // 임시로 null, 나중에 실제 객체로 교체됨
}
window.analyzePostureAI = window.analyzePostureAI || function(before, after) {
  console.log("✅ analyzePostureAI 강제 바인딩 실행됨", { before, after });
  // 실제 함수가 나중에 정의되면 덮어씌워짐
  return { results: [], findings: [], muscles: { tight: [], weak: [] } };
};

// ---- 파일 업로드 강제 등록 ----
window.setupFileUploads = window.setupFileUploads || function() {
  console.log("📌 setupFileUploads 강제 활성화");
  
  const fileInputs = document.querySelectorAll("input[type=file]");
  fileInputs.forEach(input => {
    // 기존 이벤트 제거 후 재등록
    const newInput = input.cloneNode(true);
    input.parentNode.replaceChild(newInput, input);
    
    newInput.addEventListener("change", (e) => {
      console.log("📁 파일 선택됨:", e.target.files);
      const file = e.target.files[0];
      if (!file) return;
      
      // 실제 파일 업로드 핸들러가 있으면 호출 (약간의 지연을 두어 함수가 정의될 때까지 대기)
      setTimeout(() => {
        if (typeof window.handleFileUpload === 'function') {
          window.handleFileUpload(e);
        } else if (typeof handleFileUpload === 'function') {
          handleFileUpload(e);
        } else {
          console.warn("⚠️ handleFileUpload 함수가 아직 정의되지 않았습니다. 잠시 후 다시 시도합니다.");
          // 200ms 후 다시 시도
          setTimeout(() => {
            if (typeof window.handleFileUpload === 'function') {
              window.handleFileUpload(e);
            } else if (typeof handleFileUpload === 'function') {
              handleFileUpload(e);
            } else {
              console.error("❌ handleFileUpload 함수를 찾을 수 없습니다.");
            }
          }, 200);
        }
      }, 100);
    });
  });
};

// DOM 준비되면 즉시 실행
if (document.readyState === 'loading') {
  document.addEventListener("DOMContentLoaded", () => {
    console.log("🔥 DOM 준비됨 → 파일 첨부 기능 주입");
    if (window.setupFileUploads) {
      window.setupFileUploads();
    }
  });
} else {
  // 이미 로드 완료된 경우 즉시 실행
  console.log("🔥 DOM 이미 준비됨 → 파일 첨부 기능 주입");
  if (window.setupFileUploads) {
    window.setupFileUploads();
  }
}
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>
<!-- AI 자동 분석 모듈 통합 -->
<!-- PRO 통합 버전 (기존 + DB 기반 분석): main_pro_compatible.js -->
<!-- <script type="module" src="./js/main_pro_compatible.js"></script> -->
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>
<script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js"></script>
<script>
// 라이브러리 로드 확인 함수
function checkLibraries() {
  if (!window.jspdf || !window.jspdf.jsPDF) {
    throw new Error("jsPDF 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.");
  }
  if (typeof html2canvas === 'undefined') {
    throw new Error("html2canvas 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.");
  }
  return true;
}

// jsPDF는 함수 내에서 동적으로 가져옴 (라이브러리 로드 확인 후)
const cv = document.getElementById("cv");
const ctx = cv ? cv.getContext("2d") : null;
let DPR = window.devicePixelRatio || 1;
let dragKey = null;
let autoFollowKey = null; // 자동 추적 모드 (클릭 시 따라오는 dot)
let editMode = false;
let selectedPoint = null;
let originalCanvasSize = { width: 0, height: 0, styleWidth: 0, styleHeight: 0 };
let currentZoom = 1;
let isScrolling = false;
let scrollStartX = 0;
let scrollStartY = 0;
let touchStartTime = 0;
let scrollDistance = 0; // 스크롤 시작 후 이동 거리
let longPressTimer = null;
let longPressDetected = false;
let longPressNearPoint = null; // long press가 감지된 점

// 옆모습 키포인트
// 측면 키포인트 (Flutter와 1:1 매칭: 소문자 통일)
const keypointsSide = [
  {key:'tragus', color:'#7c9cff'},
  {key:'c7', color:'#7c9cff'},
  {key:'acromion', color:'#7c9cff'},
  {key:'hip', color:'#7c9cff'},
  {key:'knee', color:'#7c9cff'},
  {key:'ankle', color:'#7c9cff'},
  {key:'asis', color:'#ffb86c'},
  {key:'psis', color:'#ffb86c'},
];

// 정면 키포인트 (Flutter와 1:1 매칭)
const keypointsFront = [
  {key:'c7', color:'#7c9cff'},
  {key:'L_acromion', color:'#7c9cff'},
  {key:'R_acromion', color:'#7c9cff'},
  {key:'L_asis', color:'#ffb86c'},
  {key:'R_asis', color:'#ffb86c'},
  {key:'L_ankle', color:'#7c9cff'},
  {key:'R_ankle', color:'#7c9cff'},
  {key:'L_knee', color:'#7c9cff'},
  {key:'R_knee', color:'#7c9cff'},
  {key:'L_patella', color:'#ff6b6b'},  // Q-angle 측정용: 슬개골 중심
  {key:'R_patella', color:'#ff6b6b'},  // Q-angle 측정용: 슬개골 중심
  {key:'L_tibial_tub', color:'#ff6b6b'},  // Q-angle 측정용: 경골 결절
  {key:'R_tibial_tub', color:'#ff6b6b'},  // Q-angle 측정용: 경골 결절
];

// 기존 호환성을 위해 keypoints 변수 유지 (getKeypoints 함수로 동적 반환)
let keypoints = keypointsSide; // 기본값

// sessions를 전역으로 노출
const sessions = {
  Before: { 
    imgSide:null, 
    imgFront:null, 
    sidePoints:new Map(),  // 측면 키포인트 (tragus, c7, acromion, asis, psis, hip, knee, ankle)
    frontPoints:new Map(), // 정면 키포인트 (L_acromion, R_acromion, L_asis, R_asis, L_knee, R_knee, L_ankle, R_ankle)
    metrics:{}, 
    score:null, 
    analysis:null 
  },
  After: { 
    imgSide:null, 
    imgFront:null, 
    sidePoints:new Map(),
    frontPoints:new Map(),
    metrics:{}, 
    score:null, 
    analysis:null 
  }
};

// sessions를 window에 명시적으로 할당 (전역 접근 가능하도록)
if(typeof window !== 'undefined') {
  window.sessions = sessions;
}

let cur = "Before";

const clamp = (v,min,max) => Math.min(max,Math.max(min,v));
const rad2deg = r => r * 180 / Math.PI;
const deg2rad = d => d * Math.PI / 180;
const angleBetween = (a,b) => Math.atan2(b.y - a.y, b.x - a.x);

// ✅ 새로운 각도 유틸 함수들 (정규화 및 정확한 계산)
function angleFromHorizontalDeg(a, b) {
  return Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI; // -180~+180
}

// -90~+90 로 정규화(항상 예각)
function normalizeToAcuteDeg(theta) {
  let t = theta;
  if (t > 90)  t -= 180;
  if (t < -90) t += 180;
  return t;
}

// 수직 기준에서 전/후방 부호(+전방, -후방)
function angleFromVerticalSignedDeg(top, bottom) {
  const dx = top.x - bottom.x;
  const dy = bottom.y - top.y; // 위->아래
  const acute = Math.atan2(Math.abs(dx), Math.abs(dy)) * 180 / Math.PI; // 0~90
  return dx >= 0 ? +acute : -acute;
}

// 관절내부각 (B-vertex)
function jointAngleDeg(a, b, c) {
  const v1x = a.x - b.x, v1y = a.y - b.y;
  const v2x = c.x - b.x, v2y = c.y - b.y;
  const dot = v1x*v2x + v1y*v2y;
  const m1 = Math.hypot(v1x, v1y), m2 = Math.hypot(v2x, v2y);
  const cos = Math.min(1, Math.max(-1, dot/(m1*m2)));
  return Math.acos(cos) * 180/Math.PI;
}

// 좌/우 정규화 유틸
function isRightSideView(pts) {
  const t = pts["tragus"] || pts["Tragus"];
  const c7 = pts["c7"] || pts["C7"];
  if (!t || !c7) return false;
  return t.x < c7.x;
}

function mirrorToLeft(points, imageWidth) {
  const out = {};
  for (const k in points) {
    const p = points[k];
    out[k] = { x: imageWidth - p.x, y: p.y };
  }
  return out;
}

function ensureLeftSide(points, imageWidth) {
  return isRightSideView(points) ? mirrorToLeft(points, imageWidth) : points;
}

// 두 점 사이 각도(수평 기준, p1->p2), 화면 y-down 좌표계 가정 (하위 호환성)
function angleP1P2(p1, p2) {
  return angleFromHorizontalDeg(p1, p2);
}

// 두 점 사이 거리(픽셀)
function dist(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx*dx + dy*dy);
}

// 외적/내적 기반 각도(pA-vertex-pB)
function angleAt(v, a, b) {
  const ax = a.x - v.x;
  const ay = a.y - v.y;
  const bx = b.x - v.x;
  const by = b.y - v.y;
  const dot = ax*bx + ay*by;
  const na = Math.sqrt(ax*ax + ay*ay);
  const nb = Math.sqrt(bx*bx + by*by);
  if (na === 0 || nb === 0) return NaN;
  return rad2deg(Math.acos(Math.max(-1, Math.min(1, dot / (na*nb)))));
}

// 수직선(90°)과 라인 각도 차이 절대값
function angleToVertical(p1, p2) {
  const a = angleP1P2(p1, p2);
  // 180도가 완전 수직, 0도도 완전 수직 (반대 방향)
  // 사용자 요구사항: 180도 → 0도 TIA, 170도 → 10도 TIA
  // 수직(180도)에서 벗어난 각도를 계산
  return Math.abs(180 - Math.abs(a));
}

// 수평선과 라인 각도 절대값
function angleToHorizontal(p1, p2) {
  return Math.abs(angleP1P2(p1, p2));
}

// 범위 분류 함수 (normal, mild, moderate, severe)
function classifyRange({
  v,
  nMin = null, nMax = null,
  mildMin = null, mildMax = null,
  modMin = null, modMax = null,
  sevMin = null, sevMax = null,
  higherIsWorse = false
}) {
  function inRange(x, lo, hi) {
    return (lo == null || x >= lo) && (hi == null || x <= hi);
  }
  
  if (inRange(v, nMin, nMax)) return "normal";
  if (inRange(v, mildMin, mildMax)) return "mild";
  if (inRange(v, modMin, modMax)) return "moderate";
  if (inRange(v, sevMin, sevMax)) return "severe";
  
  // 방향성 힌트
  return higherIsWorse
    ? (v > (nMax ?? v) ? "worse_high" : "worse_low")
    : (v < (nMin ?? v) ? "worse_low" : "worse_high");
}

// px→cm 변환
function pxToCm(px, scalePxPerCm = 50) {
  return px / scalePxPerCm;
}

// ✅ 캘리브레이션 유틸: 두 점 간 거리로 pxPerCm 계산
function calibratePxPerCm(pointA, pointB, realLengthCm) {
  if (realLengthCm <= 0) {
    throw new Error("realLengthCm must be > 0");
  }
  const distPx = dist(pointA, pointB);
  return distPx / realLengthCm;
}

// ✅ 측면 자세 분석 (전체 지표 포함)
function analyzeFullPosture(points, pxPerCm = 50.0, imageWidth = 1080) {
  // 좌우 정규화: 오른옆 사진이면 왼옆으로 미러링
  const normalizedPoints = ensureLeftSide(points, imageWidth);
  
  function p(k) {
    const v = normalizedPoints[k];
    if (!v || v.x == null || v.y == null) return null;
    return { x: Number(v.x), y: Number(v.y) };
  }
  
  const result = {};
  
  // Flutter 1:1 매칭 키 (소문자 우선, 기존 대문자는 fallback)
  const tragus = p("tragus") || p("Tragus");
  const C7 = p("c7") || p("C7");
  const acromion = p("acromion") || p("Shoulder") || p("Acromion");
  const ASIS = p("asis") || p("ASIS");
  const PSIS = p("psis") || p("PSIS");
  const hip = p("hip") || p("Hip");
  const knee = p("knee") || p("Knee");
  const ankle = p("ankle") || p("Ankle");
  
  // 1️⃣ CVA (Craniovertebral Angle): C7 수평면 기준 각도
  // 스펙: C7 수평면을 0도 기준으로, C7->Tragus 선이 수평면과 이루는 각도
  if (tragus && C7) {
    const cv_theta = angleFromHorizontalDeg(C7, tragus);
    const cv_acute = normalizeToAcuteDeg(cv_theta);
    // C7 수평면 기준: 수평선과 이루는 각도의 절댓값 (0도 = 수평면)
    const cva = Math.abs(cv_acute);
    
    result.CVA = {
      value: cva,
      status: classifyRange({
        v: cva,
        nMin: 50, nMax: 90,
        mildMin: 45, mildMax: 49,
        modMin: 40, modMax: 44,
        sevMin: null, sevMax: 40,
        higherIsWorse: false
      }),
      unit: "°",
      desc: "Craniovertebral Angle (거북목 평가)"
    };
    // 하위 호환성
    result.CVA.value_deg = cva;
    result.CVA.meaning = result.CVA.desc;
  }
  
  // 2️⃣ HPD (Head Protrusion Distance): tragus와 acromion 거리
  if (tragus && acromion) {
    const hpd = pxToCm(dist(tragus, acromion), pxPerCm);
    result.HPD = {
      value: hpd,
      status: classifyRange({
        v: hpd,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 4,
        modMin: 4, modMax: 6,
        sevMin: 6, sevMax: null,
        higherIsWorse: true
      }),
      unit: "cm",
      desc: "Head Protrusion Distance (머리 돌출)"
    };
    // 하위 호환성
    result.HPD.value_cm = hpd;
    result.HPD.meaning = result.HPD.desc;
  }
  
  // 4️⃣ TIA (Trunk Inclination Angle): vertical signed (윗점=Acromion, +전방/-후방)
  if (acromion && hip) {
    const tia = angleFromVerticalSignedDeg(acromion, hip);
    result.TIA = {
      value: Math.abs(tia),
      value_signed: tia, // 부호 포함 값
      status: classifyRange({
        v: Math.abs(tia),
        nMin: 0, nMax: 5,
        mildMin: 5, mildMax: 10,
        modMin: 10, modMax: 15,
        sevMin: 15, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Trunk Inclination Angle"
    };
    // 하위 호환성
    result.TIA.value_deg = Math.abs(tia);
    result.TIA.meaning = result.TIA.desc;
  }
  
  // 5️⃣ SAA (Shoulder Anterior Angle): PSIS 기준 수직선과 Acromion의 각도
  // 0° = Acromion과 PSIS가 같은 x축 (수직 정렬)
  // +각: Acromion이 PSIS보다 전방(앞)으로 이동 → Rounded Shoulder
  // -각: Acromion이 PSIS보다 후방(뒤)으로 이동 → 견갑 후인 과다
  // PSIS가 축(기준점), Acromion이 전방이면 +각도 (1도부터 시작)
  if (acromion && PSIS) {
    const saa = angleFromVerticalSignedDeg(acromion, PSIS); // 수직선 기준 각도
    result.SAA = {
      value: Math.abs(saa), // 절댓값 (0~90°)
      value_signed: saa, // 부호 포함 값 (+전방/-후방)
      status: classifyRange({
        v: Math.abs(saa),
        nMin: 0, nMax: 10,
        mildMin: 10, mildMax: 15,
        modMin: 15, modMax: 20,
        sevMin: 20, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Shoulder Anterior Angle (어깨 전방각)"
    };
    // 하위 호환성
    result.SAA.value_deg = Math.abs(saa);
    result.SAA.meaning = result.SAA.desc;
  }
  
  // 6️⃣ PTA (Pelvic Tilt Angle): 임상부호 (+전방/-후방)
  // PSIS 기준: ASIS와 같은 높이 = 0도
  // ASIS가 PSIS보다 위쪽에 있으면 = 골반 후방경사 (Posterior Tilt) = 음수 (-1도부터)
  // ASIS가 PSIS보다 밑쪽에 있으면 = 골반 전방경사 (Anterior Tilt) = 양수 (1도부터)
  if (ASIS && PSIS) {
    const pta_theta = angleFromHorizontalDeg(PSIS, ASIS);
    const pta_abs = Math.abs(normalizeToAcuteDeg(pta_theta));
    // 이미지 좌표계: y축 아래로 증가
    // ASIS.y < PSIS.y → ASIS가 위쪽(높음) → 후방경사(음수, 최소 -1도)
    // ASIS.y > PSIS.y → ASIS가 밑쪽(낮음) → 전방경사(양수, 최소 1도)
    let pta;
    if (ASIS.y < PSIS.y) {
      // 후방경사: ASIS가 PSIS보다 위쪽 → 음수, 최소 -1도
      pta = -Math.max(1, pta_abs || 1);
    } else if (ASIS.y > PSIS.y) {
      // 전방경사: ASIS가 PSIS보다 밑쪽 → 양수, 최소 1도
      pta = Math.max(1, pta_abs || 1);
    } else {
      // 같은 높이: 0도
      pta = 0;
    }
    result.PTA = {
      value: Math.abs(pta),
      value_signed: pta, // 부호 포함 값
      status: classifyRange({
        v: Math.abs(pta),
        nMin: 5, nMax: 15,
        mildMin: 0, mildMax: 4,
        modMin: 16, modMax: 20,
        sevMin: null, sevMax: null,
        higherIsWorse: false
      }),
      unit: "°",
      desc: "Pelvic Tilt Angle"
    };
    // 하위 호환성
    result.PTA.value_deg = Math.abs(pta);
    result.PTA.meaning = result.PTA.desc;
  }
  
  // 7️⃣ KA (Knee Alignment Angle): ∠(Hip, Knee, Ankle)
  if (hip && knee && ankle) {
    const ka = jointAngleDeg(hip, knee, ankle);
    result.KA = {
      value: ka,
      status: classifyRange({
        v: ka,
        nMin: 175, nMax: 180,
        mildMin: 172, mildMax: 174,
        modMin: 168, modMax: 171,
        sevMin: null, sevMax: null,
        higherIsWorse: false
      }),
      unit: "°",
      desc: "Knee Alignment Angle"
    };
    // 하위 호환성
    result.KA.value_deg = ka;
    result.KA.meaning = result.KA.desc;
  }
  
  // 8️⃣ Tibial_Angle (Tibial Inclination): vertical signed (윗점=Knee)
  if (knee && ankle) {
    const tba = angleFromVerticalSignedDeg(knee, ankle);
    // 스펙: 85-90도가 정상이므로, 수직선에서 벗어난 각도를 계산
    const tbaValue = Math.abs(tba);
    result.Tibial_Angle = {
      value: tbaValue,
      status: classifyRange({
        v: tbaValue,
        nMin: 0, nMax: 5,
        mildMin: 5, mildMax: 8,
        modMin: 8, modMax: 12,
        sevMin: 12, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Tibial Inclination"
    };
    // 하위 호환성
    result.Tibial_Angle.value_deg = tbaValue;
    result.Tibial_Angle.meaning = result.Tibial_Angle.desc;
    result.Tibial_Inclination = result.Tibial_Angle;
  }
  
  // 9️⃣ GSB (Global Sagittal Balance): tragus–ankle x좌표 차이
  if (tragus && ankle) {
    const gsbPx = Math.abs(tragus.x - ankle.x);
    const gsb = pxToCm(gsbPx, pxPerCm);
    result.GSB = {
      value: gsb,
      status: classifyRange({
        v: gsb,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 4,
        modMin: 4, modMax: 6,
        sevMin: 6, sevMax: null,
        higherIsWorse: true
      }),
      unit: "cm",
      desc: "Global Sagittal Balance"
    };
    // 하위 호환성
    result.GSB.value_cm = gsb;
    result.GSB.meaning = result.GSB.desc;
  }
  
  // 1️⃣2️⃣ HPA (Head–Pelvis Angle): vertical signed (윗점=Tragus, 아랫점=PSIS)
  if (tragus && PSIS) {
    const hpa = angleFromVerticalSignedDeg(tragus, PSIS);
    result.HPA = {
      value: Math.abs(hpa),
      value_signed: hpa, // 부호 포함 값
      status: classifyRange({
        v: Math.abs(hpa),
        nMin: 0, nMax: 5,
        mildMin: 5, mildMax: 10,
        modMin: 10, modMax: 15,
        sevMin: 15, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Head–Pelvis Angle"
    };
    // 하위 호환성
    result.HPA.value_deg = hpa;
    result.HPA.meaning = result.HPA.desc;
  }
  
  // Q-Angle은 정면 분석에서만 측정 (측면 분석에서는 제거)
  
  // 1️⃣4️⃣ Knee_Deviation (무릎 높이 차이): L_knee와 R_knee 수평선 각도
  const L_knee = p("L_knee") || p("L_Knee");
  const R_knee = p("R_knee") || p("R_Knee");
  if (L_knee && R_knee) {
    const kd = angleToHorizontal(L_knee, R_knee);
    result.Knee_Deviation = {
      value: kd,
      status: classifyRange({
        v: kd,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Knee Height Difference"
    };
    // 하위 호환성
    result.Knee_Deviation.value_deg = kd;
    result.Knee_Deviation.meaning = result.Knee_Deviation.desc;
  }
  
  // 1️⃣5️⃣ LLD (Leg Length Discrepancy): 좌우 다리 길이 차이
  const L_asis = p("L_asis") || p("L_ASIS");
  const R_asis = p("R_asis") || p("R_ASIS");
  const L_ankle = p("L_ankle") || p("L_Ankle");
  const R_ankle = p("R_ankle") || p("R_Ankle");
  if (L_asis && L_ankle && R_asis && R_ankle) {
    const lLen = dist(L_asis, L_ankle);
    const rLen = dist(R_asis, R_ankle);
    const lld = pxToCm(Math.abs(lLen - rLen), pxPerCm);
    result.LLD = {
      value: lld,
      status: lld <= 1 ? "normal" : lld <= 2 ? "mild" : "severe",
      unit: "cm",
      desc: "Leg Length Discrepancy"
    };
    // 하위 호환성
    result.LLD.value_cm = lld;
    result.LLD.meaning = result.LLD.desc;
  }
  
  // 1️⃣6️⃣ PDS (Postural Deviation Score): 모든 지표 합산지수
  let pdsScore = 0;
  const statusMap = { "normal": 0, "mild": 1, "moderate": 2, "severe": 3, "abnormal": 2, "neutral": 0, "kyphotic": 2, "flat": 2 };
  Object.keys(result).forEach(key => {
    if (key !== "PDS" && result[key] && result[key].status) {
      pdsScore += statusMap[result[key].status] || 0;
    }
  });
  
  result.PDS = {
    value: pdsScore,
    status: pdsScore <= 10 ? "normal" : pdsScore <= 15 ? "mild" : "moderate",
    unit: "score",
    desc: "Postural Deviation Score (0–10: normal, 10↑: 불균형)"
  };
  // 하위 호환성
  result.PDS.meaning = result.PDS.desc;
  
  return result;
}

// ✅ 정면 자세 분석
function analyzeFrontPosture(points, pxPerCm = 50.0) {
  // 안전 접근 헬퍼
  function p(k) {
    const v = points[k];
    if (!v || v.x == null || v.y == null) return null;
    return { x: Number(v.x), y: Number(v.y) };
  }
  
  const result = {};
  
  const L_acr = p("L_acromion") || p("L_Shoulder");
  const R_acr = p("R_acromion") || p("R_Shoulder");
  const L_asis = p("L_asis") || p("L_ASIS");
  const R_asis = p("R_asis") || p("R_ASIS");
  // Flutter 1:1 매칭 키 (소문자 우선)
  const C7 = p("c7") || p("C7");
  const L_ankle = p("L_ankle");
  const R_ankle = p("R_ankle");
  
  // 스펙 기반: 정면 지표 추가 (TypeScript spec v1.0)
  
  // 1️⃣ STA_F (Shoulder Tilt Angle): 어깨 좌우 기울기
  // 0° = 수평, +각도 = 오른쪽 어깨가 높을 때, -각도 = 왼쪽 어깨가 높을 때
  if (L_acr && R_acr) {
    const verticalDiff = L_acr.y - R_acr.y; // L이 높으면 양수, R이 높으면 음수
    const horizontalDist = Math.abs(L_acr.x - R_acr.x);
    // 수평선 기준 각도: atan2(verticalDiff, horizontalDist)
    // verticalDiff > 0 (L이 높음) → 음수 각도
    // verticalDiff < 0 (R이 높음) → 양수 각도
    const sta = horizontalDist > 0 ? rad2deg(Math.atan2(-verticalDiff, horizontalDist)) : 0;
    
    result.STA_F = {
      value: Math.abs(sta), // 표시는 절대값
      value_signed: sta, // 부호 포함 값 (내부 사용)
      status: classifyRange({
        v: Math.abs(sta),
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Shoulder Tilt Angle (어깨 좌우 기울기)"
    };
    result.STA_F.value_deg = Math.abs(sta);
    result.STA_F.meaning = result.STA_F.desc;
    
    // 하위 호환성
    result.Shoulder_Tilt = result.STA_F;
  }
  
  // 2️⃣ POA_F (Pelvic Obliquity Angle): 골반 좌우 기울기
  // 0° = 수평, +각도 = 오른쪽 ASIS가 높을 때, -각도 = 왼쪽 ASIS가 높을 때
  if (L_asis && R_asis) {
    const verticalDiff = L_asis.y - R_asis.y; // L이 높으면 양수, R이 높으면 음수
    const horizontalDist = Math.abs(L_asis.x - R_asis.x);
    // 수평선 기준 각도: atan2(verticalDiff, horizontalDist)
    // verticalDiff > 0 (L이 높음) → 음수 각도
    // verticalDiff < 0 (R이 높음) → 양수 각도
    const poa = horizontalDist > 0 ? rad2deg(Math.atan2(-verticalDiff, horizontalDist)) : 0;
    
    result.POA_F = {
      value: Math.abs(poa), // 표시는 절대값
      value_signed: poa, // 부호 포함 값 (내부 사용)
      status: classifyRange({
        v: Math.abs(poa),
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Pelvic Obliquity Angle (골반 좌우 기울기)"
    };
    result.POA_F.value_deg = Math.abs(poa);
    result.POA_F.meaning = result.POA_F.desc;
    
    // 하위 호환성
    result.POA = result.POA_F;
    result.Pelvic_Obliquity = result.POA_F;
    
    // PRA (Pelvic Rotation): 좌우 ASIS 간 x좌표 차이 (스펙에는 없지만 유지)
    const pra = pxToCm(Math.abs(R_asis.x - L_asis.x), pxPerCm);
    result.PRA = {
      value: pra,
      value_cm: pra,
      status: pra <= 1 ? "normal" : pra <= 2 ? "mild" : pra <= 3 ? "moderate" : "severe",
      unit: "cm",
      meaning: "Pelvic Rotation (골반 좌우 비틀림)"
    };
  }
  
  // 3️⃣ LLD_F (Leg Length Discrepancy): 다리 길이 차이
  if (L_asis && L_ankle && R_asis && R_ankle) {
    const lLen = dist(L_asis, L_ankle);
    const rLen = dist(R_asis, R_ankle);
    const lld = pxToCm(Math.abs(lLen - rLen), pxPerCm);
    
    result.LLD_F = {
      value: lld,
      status: classifyRange({
        v: lld,
        nMin: 0, nMax: 1,
        mildMin: 1, mildMax: 2,
        modMin: 2, modMax: 3,
        sevMin: 3, sevMax: null,
        higherIsWorse: true
      }),
      unit: "cm",
      desc: "Leg Length Discrepancy (하지 길이 차)"
    };
    result.LLD_F.value_cm = lld;
    result.LLD_F.meaning = result.LLD_F.desc;
    
    // 하위 호환성
    result.LLD = result.LLD_F;
    if (L_ankle && R_ankle) {
      const diffPx = Math.abs(L_ankle.y - R_ankle.y);
      const diffCm = pxToCm(diffPx, pxPerCm);
      result.Leg_Length_Diff = {
        value_cm: diffCm,
        status: diffCm <= 1 ? "normal" : diffCm <= 2 ? "mild" : diffCm <= 3 ? "moderate" : "severe",
        meaning: "다리 길이 차이 (1cm 이하 정상)",
      };
    }
  }
  
  // 4️⃣ TD (Trunk Deviation): 체간 좌우 편위
  // 0° = C7이 midline 위에, +각도 = 오른쪽으로 이동, -각도 = 왼쪽으로 이동
  if (C7 && L_ankle && R_ankle) {
    // 중간선: 좌우 발목 중점
    const midlineX = (L_ankle.x + R_ankle.x) / 2;
    const midlineY = (L_ankle.y + R_ankle.y) / 2;
    
    // C7에서 중간선까지의 수평 거리 (오른쪽이면 양수, 왼쪽이면 음수)
    const horizontalDeviation = C7.x - midlineX;
    const verticalDist = Math.abs(C7.y - midlineY);
    // 수직선 기준 각도: atan2(horizontalDeviation, verticalDist)
    // horizontalDeviation > 0 (오른쪽) → 양수 각도
    // horizontalDeviation < 0 (왼쪽) → 음수 각도
    const td = verticalDist > 0 ? rad2deg(Math.atan2(horizontalDeviation, verticalDist)) : 0;
    
    result.TD = {
      value: Math.abs(td), // 표시는 절대값
      value_signed: td, // 부호 포함 값 (내부 사용)
      status: classifyRange({
        v: Math.abs(td),
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 5,
        modMin: 5, mildMax: 8,
        sevMin: 8, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Trunk Deviation (체간 좌우 편위)"
    };
    result.TD.value_deg = Math.abs(td);
    result.TD.meaning = result.TD.desc;
    
    // 하위 호환성
    if (L_asis && R_asis) {
    const pelvisMid = {
      x: (L_asis.x + R_asis.x) / 2,
      y: (L_asis.y + R_asis.y) / 2
    };
    const dx = C7.x - pelvisMid.x;
    const dy = C7.y - pelvisMid.y;
      const angle = rad2deg(Math.atan2(Math.abs(dx), Math.abs(dy)));
    result.Trunk_Lateral_Tilt = {
      value_deg: angle,
        status: angle <= 2 ? "normal" : angle <= 5 ? "mild" : angle <= 8 ? "moderate" : "severe",
      meaning: "체간의 좌우 기울기",
    };
    }
  }
  
  // 5️⃣ HTA (Head Tilt Angle): 머리 좌우 기울기
  // 0° = 수평, +각도 = 오른쪽 Tragus가 높을 때, -각도 = 왼쪽 Tragus가 높을 때
  const L_tragus = p("L_tragus");
  const R_tragus = p("R_tragus");
  if (L_tragus && R_tragus) {
    const verticalDiff = L_tragus.y - R_tragus.y; // L이 높으면 양수, R이 높으면 음수
    const horizontalDist = Math.abs(L_tragus.x - R_tragus.x);
    // 수평선 기준 각도: atan2(verticalDiff, horizontalDist)
    // verticalDiff > 0 (L이 높음) → 음수 각도
    // verticalDiff < 0 (R이 높음) → 양수 각도
    const hta = horizontalDist > 0 ? rad2deg(Math.atan2(-verticalDiff, horizontalDist)) : 0;
    
    result.HTA = {
      value: Math.abs(hta), // 표시는 절대값
      value_signed: hta, // 부호 포함 값 (내부 사용)
      status: classifyRange({
        v: Math.abs(hta),
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Head Tilt Angle (머리 좌우 기울기)"
    };
    result.HTA.value_deg = Math.abs(hta);
    result.HTA.meaning = result.HTA.desc;
  }
  
  // 6️⃣ SPP (Shoulder–Pelvis Parallelism): 어깨-골반 평행도
  if (L_acr && R_acr && L_asis && R_asis) {
    // 어깨선 각도
    const shoulderDx = R_acr.x - L_acr.x;
    const shoulderDy = R_acr.y - L_acr.y;
    const shoulderAngle = rad2deg(Math.atan2(shoulderDy, shoulderDx));
    
    // 골반선 각도
    const pelvisDx = R_asis.x - L_asis.x;
    const pelvisDy = R_asis.y - L_asis.y;
    const pelvisAngle = rad2deg(Math.atan2(pelvisDy, pelvisDx));
    
    // 각도 차이
    let angleDiff = Math.abs(shoulderAngle - pelvisAngle);
    if (angleDiff > 90) angleDiff = 180 - angleDiff; // 0-90도 범위로 정규화
    
    result.SPP = {
      value: angleDiff,
      status: classifyRange({
        v: angleDiff,
        nMin: 0, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Shoulder–Pelvis Parallelism (어깨-골반 평행도)"
    };
    result.SPP.value_deg = angleDiff;
    result.SPP.meaning = result.SPP.desc;
  }
  
  // 7️⃣ FBA (Foot Base Angle): 발 정렬 각도
  // 0° = 발이 중심선과 일직선일 때, +각도 = 발끝이 바깥쪽(외회전), -각도 = 발끝이 안쪽(내회전)
  // 발가락 좌표가 없으면 계산하지 않음
  const L_toe = p("L_toe");
  const R_toe = p("R_toe");
  if (L_ankle && L_toe && R_ankle && R_toe) {
    // 신체 중심선 (midline)
    const midlineX = (L_ankle.x + R_ankle.x) / 2;
    
    // 좌측 발 정렬: ankle-toe 라인과 중심선의 각도
    const L_dx = L_toe.x - L_ankle.x;
    const L_dy = L_toe.y - L_ankle.y;
    // 중심선 기준 각도: atan2(dy, dx) - 중심선이 수직이므로 x 방향 기준
    // 발끝이 오른쪽(바깥쪽)이면 양수, 왼쪽(안쪽)이면 음수
    const L_angle = rad2deg(Math.atan2(L_dy, L_dx - midlineX));
    
    // 우측 발 정렬
    const R_dx = R_toe.x - R_ankle.x;
    const R_dy = R_toe.y - R_ankle.y;
    const R_angle = rad2deg(Math.atan2(R_dy, R_dx - midlineX));
    
    // 평균 각도 (외회전 각도)
    const avgAngle = (L_angle + R_angle) / 2;
    // 0° = 중심선과 일직선, 양수 = 외회전, 음수 = 내회전
    const fba = Math.abs(avgAngle); // 표시는 절대값
    
    result.FBA = {
      value: fba,
      value_signed: avgAngle, // 부호 포함 값 (내부 사용)
      status: classifyRange({
        v: fba,
        nMin: 0, nMax: 10,
        mildMin: 10, mildMax: 20,
        modMin: 20, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Foot Base Angle (발 정렬 각도)"
    };
    result.FBA.value_deg = fba;
    result.FBA.meaning = result.FBA.desc;
  }
  
  
  // 6️⃣ Knee Deviation (Front): 좌우 knee 높이 차이
  const L_knee = p("L_knee") || p("L_Knee");
  const R_knee = p("R_knee") || p("R_Knee");
  if (L_knee && R_knee) {
    const diffPx = Math.abs(L_knee.y - R_knee.y);
    const diffCm = pxToCm(diffPx, pxPerCm);
    const angle = rad2deg(Math.atan2(diffPx, Math.abs(L_knee.x - R_knee.x) || 1));
    result.Knee_Deviation = {
      value_deg: angle,
      status: classifyRange({
        v: angle,
        nMin: null, nMax: 3,
        mildMin: 3, mildMax: 6,
        modMin: 6, modMax: 10,
        sevMin: 10, sevMax: null,
        higherIsWorse: true
      }),
      meaning: "무릎 높이 차이 (≤3° 정상)"
    };
  }
  
  // 7️⃣ Q-Angle: ASIS → patella 중심 → tibial tuberosity
  // (정면에서만 측정 가능)
  const L_patella = p("L_patella") || p("L_Patella");
  const R_patella = p("R_patella") || p("R_Patella");
  const L_tibial_tub = p("L_tibial_tub") || p("L_Tibial_Tub");
  const R_tibial_tub = p("R_tibial_tub") || p("R_Tibial_Tub");
  
  // 좌측 Q-Angle 계산
  if (L_asis && L_patella && L_tibial_tub) {
    // Q-Angle: ASIS → patella 중심 → tibial tuberosity 각도
    const qAngleL = angleAt(L_patella, L_asis, L_tibial_tub);
    result.Q_Angle_L = {
      value: qAngleL,
      value_deg: qAngleL,
      status: classifyRange({
        v: qAngleL,
        nMin: 10, nMax: 20, // 일반적으로 여성이 더 큼
        mildMin: 20, mildMax: 25,
        modMin: 25, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Q-Angle Left (좌측 대퇴사두근 각도)",
      meaning: "좌측 Q-Angle (10–20° 정상, 여성이 더 큼)"
    };
  }
  
  // 우측 Q-Angle 계산
  if (R_asis && R_patella && R_tibial_tub) {
    const qAngleR = angleAt(R_patella, R_asis, R_tibial_tub);
    result.Q_Angle_R = {
      value: qAngleR,
      value_deg: qAngleR,
      status: classifyRange({
        v: qAngleR,
        nMin: 10, nMax: 20,
        mildMin: 20, mildMax: 25,
        modMin: 25, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Q-Angle Right (우측 대퇴사두근 각도)",
      meaning: "우측 Q-Angle (10–20° 정상, 여성이 더 큼)"
    };
  }
  
  // 평균 Q-Angle (좌우 모두 있을 때)
  if (result.Q_Angle_L && result.Q_Angle_R) {
    const avgQAngle = (result.Q_Angle_L.value + result.Q_Angle_R.value) / 2;
    result.Q_Angle = {
      value: avgQAngle,
      value_deg: avgQAngle,
      status: classifyRange({
        v: avgQAngle,
        nMin: 10, nMax: 20,
        mildMin: 20, mildMax: 25,
        modMin: 25, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Q-Angle (대퇴사두근 각도)",
      meaning: "Q-Angle 평균 (10–20° 정상, 여성이 더 큼)"
    };
  } else if (result.Q_Angle_L) {
    // 좌측만 있을 때
    result.Q_Angle = result.Q_Angle_L;
    result.Q_Angle.desc = "Q-Angle (대퇴사두근 각도)";
    result.Q_Angle.meaning = "Q-Angle (10–20° 정상, 여성이 더 큼)";
  } else if (result.Q_Angle_R) {
    // 우측만 있을 때
    result.Q_Angle = result.Q_Angle_R;
    result.Q_Angle.desc = "Q-Angle (대퇴사두근 각도)";
    result.Q_Angle.meaning = "Q-Angle (10–20° 정상, 여성이 더 큼)";
  }
  
  // 하위 호환성: patella나 tibial_tub가 없을 때 무릎 중심 사용 (기존 방식)
  if (!result.Q_Angle && L_asis && L_knee && L_ankle) {
    const qAngle = angleAt(L_knee, L_asis, L_ankle);
    result.Q_Angle = {
      value: qAngle,
      value_deg: qAngle,
      status: classifyRange({
        v: qAngle,
        nMin: 10, nMax: 20,
        mildMin: 20, mildMax: 25,
        modMin: 25, modMax: 30,
        sevMin: 30, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Q-Angle (대퇴사두근 각도)",
      meaning: "Q-Angle (10–20° 정상, 여성이 더 큼)"
    };
  }
  
  // 8️⃣ KAS (Knee Alignment Symmetry): 무릎 정렬 대칭성
  if (L_knee && L_ankle && R_knee && R_ankle) {
    // 좌측 무릎-발목 선의 각도
    const L_dx = L_ankle.x - L_knee.x;
    const L_dy = L_ankle.y - L_knee.y;
    const L_angle = rad2deg(Math.atan2(L_dy, L_dx));
    
    // 우측 무릎-발목 선의 각도
    const R_dx = R_ankle.x - R_knee.x;
    const R_dy = R_ankle.y - R_knee.y;
    const R_angle = rad2deg(Math.atan2(R_dy, R_dx));
    
    // 각도 차이
    let angleDiff = Math.abs(L_angle - R_angle);
    if (angleDiff > 90) angleDiff = 180 - angleDiff; // 0-90도 범위로 정규화
    
    result.KAS = {
      value: angleDiff,
      value_deg: angleDiff,
      status: classifyRange({
        v: angleDiff,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 5,
        modMin: 5, modMax: 8,
        sevMin: 8, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Knee Alignment Symmetry (무릎 정렬 대칭성)",
      meaning: "무릎 정렬 대칭성 (대칭 ±2° 이내)"
    };
  }
  
  // 9️⃣ LLAS (Lower Limb Axis Symmetry): 하지 축 대칭성
  if (L_asis && L_ankle && R_asis && R_ankle) {
    // 좌측 ASIS-발목 선의 각도
    const L_dx = L_ankle.x - L_asis.x;
    const L_dy = L_ankle.y - L_asis.y;
    const L_angle = rad2deg(Math.atan2(L_dy, L_dx));
    
    // 우측 ASIS-발목 선의 각도
    const R_dx = R_ankle.x - R_asis.x;
    const R_dy = R_ankle.y - R_asis.y;
    const R_angle = rad2deg(Math.atan2(R_dy, R_dx));
    
    // 각도 차이
    let angleDiff = Math.abs(L_angle - R_angle);
    if (angleDiff > 90) angleDiff = 180 - angleDiff; // 0-90도 범위로 정규화
    
    result.LLAS = {
      value: angleDiff,
      value_deg: angleDiff,
      status: classifyRange({
        v: angleDiff,
        nMin: 0, nMax: 2,
        mildMin: 2, mildMax: 5,
        modMin: 5, modMax: 8,
        sevMin: 8, sevMax: null,
        higherIsWorse: true
      }),
      unit: "°",
      desc: "Lower Limb Axis Symmetry (하지 축 대칭성)",
      meaning: "하지 축 대칭성 (±2° 이내)"
    };
  }
  
  return result;
}

// ✅ 분석 결과 요약 HTML 생성 (개선 버전: Before-After 비교 지원)
function buildAnalysisSummaryHtml(analysisResult, metrics = null, rules = null) {
  // Before-After 비교가 가능한 경우 (metrics와 rules 제공 시)
  if(metrics && rules) {
    const chunks = [];
    Object.keys(metrics).forEach(k => {
      const m = metrics[k];
      const rule = rules[k];
      if (!rule || m.before == null || m.after == null) return;
      const delta = m.after - m.before;
      const res = rule.analyze ? rule.analyze(m.before, m.after, delta) : null;
      if (!res) return;
      const icon = res.status === 'improved' ? '✅' : res.status === 'worsened' ? '⚠️' : '➖';
      chunks.push(
        `<div style="margin-bottom:8px; padding:8px; background:#f9f9f9; border-radius:4px;">` +
        `<strong>${icon} ${rule.name}</strong>: ${m.before}${rule.unit} → ${m.after}${rule.unit} (Δ ${delta.toFixed(1)}${rule.unit})<br>` +
        `<span style="font-size:10px; color:#666;">${res.comment}</span></div>`
      );
    });
    return chunks.length > 0 ? chunks.join('') : '<div>비교 데이터가 없습니다.</div>';
  }
  
  // 기존 방식 (analysisResult 사용)
  const side = analysisResult?.side || {};
  const front = analysisResult?.front || {};
  const summary = analysisResult?.summary || {};
  
  let html = '<div style="margin-bottom:20px; padding:15px; background:#f5f5f5; border-radius:8px; box-sizing:border-box; overflow:hidden; word-wrap:break-word;">';
  
  // 측면 분석 결과
  if(side.status !== "not_available") {
    html += '<div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#0b0f14;">측면 분석 결과</div>';
    for(const [key, value] of Object.entries(side)) {
      if(value && typeof value === 'object' && value.value != null && key !== 'status') {
        const unit = value.value_cm != null ? 'cm' : '°';
        const val = value.value_deg != null ? value.value_deg : (value.value_cm != null ? value.value_cm : value.value);
        const status = value.status || 'unknown';
        if(val != null && typeof val === 'number') {
          html += `<div style="font-size:12px; margin-bottom:4px; line-height:1.5; word-wrap:break-word;">${key}: ${val.toFixed(2)}${unit} (${status})</div>`;
        }
      }
    }
    html += '<div style="margin-bottom:12px;"></div>';
  }
  
  // 정면 분석 결과
  if(front.status !== "not_available") {
    html += '<div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#0b0f14;">정면 분석 결과</div>';
    for(const [key, value] of Object.entries(front)) {
      if(value && typeof value === 'object' && value.value != null && key !== 'status') {
        const unit = value.value_cm != null ? 'cm' : '°';
        const val = value.value_deg != null ? value.value_deg : (value.value_cm != null ? value.value_cm : value.value);
        const status = value.status || 'unknown';
        if(val != null && typeof val === 'number') {
          html += `<div style="font-size:12px; margin-bottom:4px; line-height:1.5; word-wrap:break-word;">${key}: ${val.toFixed(2)}${unit} (${status})</div>`;
        }
      }
    }
    html += '<div style="margin-bottom:12px;"></div>';
  }
  
  // 종합 점수
  html += '<div style="border-top:1px solid #ddd; padding-top:12px; margin-top:12px;"></div>';
  if(summary.PDS_total != null) {
    html += `<div style="font-size:12px; font-weight:600; color:#6b46c1; word-wrap:break-word;">PDS 종합점수: ${summary.PDS_total} (${summary.risk_level})</div>`;
  } else {
    html += '<div style="font-size:12px; color:#666; word-wrap:break-word;">종합분석: 해당없음</div>';
  }
  
  html += '</div>';
  return html;
}

// 이미지 base64 변환기 (CORS 안전)
async function toDataUrl(url) {
  try {
    // 이미 base64인 경우 그대로 반환
    if(url.startsWith('data:')) {
      return url;
    }
    
    // Blob URL인 경우
    if(url.startsWith('blob:')) {
      const res = await fetch(url);
      const blob = await res.blob();
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    }
    
    // 일반 URL인 경우 (CORS 허용 필요)
    const res = await fetch(url, { mode: 'cors' });
    const blob = await res.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch(err) {
    console.warn('이미지 변환 실패, 원본 URL 반환:', err);
    return url; // 실패 시 원본 반환
  }
}

// ✅ 운동 추천 HTML 생성 함수
function buildExerciseRecommendationHtml(analysisResult) {
  const analysis = analysisResult.analysis || {};
  let html = '';
  
  // 필라테스 추천 HTML 생성
  let pilatesHTML = '';
  if(analysis.pilates && Array.isArray(analysis.pilates) && analysis.pilates.length > 0) {
    pilatesHTML = analysis.pilates.map((item, idx) => renderPilatesItemCard(item, { context:'ui', index: idx })).join('');
  }
  
  // 운동 추천 HTML 생성
  let exercisesHTML = '';
  if(analysis.exercises && Array.isArray(analysis.exercises) && analysis.exercises.length > 0) {
    exercisesHTML = analysis.exercises.filter(ex => ex != null).map(ex => `<div style="margin-bottom:8px; font-size:12px;">${ex}</div>`).join("");
  }
  
  // 전체 HTML 조합
  if(pilatesHTML) {
    html += `<div style="margin-top:20px; padding:18px; background:#f3e5f5; border-radius:10px; border-left:4px solid #9c88ff; box-sizing:border-box; overflow:hidden;">
      <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#9c88ff; line-height:1.4; word-wrap:break-word;">🧘 필라테스 세션 추천</div>
      ${pilatesHTML}
    </div>`;
  }
  
  if(exercisesHTML) {
    html += `<div style="margin-top:20px; padding:18px; background:#e0f2f1; border-radius:10px; border-left:4px solid #2ec4b6; box-sizing:border-box; overflow:hidden;">
      <div style="font-size:14px; font-weight:700; margin-bottom:12px; color:#2ec4b6; line-height:1.4; word-wrap:break-word;">🏋️ 추천 운동</div>
      <div style="font-size:12px; line-height:1.8; word-wrap:break-word; overflow-wrap:break-word;">${exercisesHTML}</div>
    </div>`;
  }
  
  return html;
}

// ✅ Before-After 비교 분석 함수
function analyzeBeforeAfterComparison() {
  const B = sessions.Before;
  const A = sessions.After;
  
  if(!B || !A || !B.metrics || !A.metrics) {
    return null;
  }
  
  const bMetrics = B.metrics?.fullMetrics || {};
  const aMetrics = A.metrics?.fullMetrics || {};
  
  // 헬퍼 함수: 메트릭 값 가져오기
  const getMetricValue = (metrics, key) => {
    const metric = metrics[key];
    if(!metric) return null;
    return metric.value !== undefined ? metric.value : 
           (metric.value_deg !== undefined ? metric.value_deg : 
           (metric.value_cm !== undefined ? metric.value_cm : null));
  };
  
  // 지표별 분석 규칙
  const metricRules = {
    'CVA': {
      name: 'CVA(두개경추각)',
      unit: '°',
      normal: '≥50°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        if(delta > 5) return { status: 'improved', comment: `CVA가 ${delta.toFixed(1)}° 증가하여 거북목 자세가 정상 범위로 개선되었습니다.` };
        if(delta < -5) return { status: 'worsened', comment: `CVA가 ${Math.abs(delta).toFixed(1)}° 감소하여 거북목 자세가 악화되었습니다.` };
        return { status: 'stable', comment: `CVA는 ${after.toFixed(1)}°로 안정적으로 유지되고 있습니다.` };
      }
    },
    'HPD': {
      name: 'HPD(두부전방이동)',
      unit: 'cm',
      normal: '≤2cm',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        if(delta < -0.5) return { status: 'improved', comment: `두부 전방이동이 ${Math.abs(delta).toFixed(1)}cm 감소하여 두부 정렬이 개선되었습니다.` };
        if(delta > 0.5) return { status: 'worsened', comment: `두부 전방이동이 ${delta.toFixed(1)}cm 증가하여 거북목 패턴이 악화되었습니다.` };
        return { status: 'stable', comment: `두부 전방이동은 변화가 미미하여 안정된 두부 정렬을 유지하고 있습니다.` };
      }
    },
    'TIA': {
      name: 'TIA(체간경사각)',
      unit: '°',
      normal: '0-10°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        const inRange = after >= 0 && after <= 10;
        if(inRange && Math.abs(delta) < 2) return { status: 'stable', comment: `체간 전방기울기가 약간 변화했으나 여전히 정상범위 내에 있습니다.` };
        if(delta > 2) return { status: 'worsened', comment: `체간 전방기울기가 ${delta.toFixed(1)}° 증가하여 전방 기울기가 악화되었습니다.` };
        if(delta < -2) return { status: 'improved', comment: `체간 전방기울기가 ${Math.abs(delta).toFixed(1)}° 감소하여 체간 정렬이 개선되었습니다.` };
        return { status: 'stable', comment: `체간 경사각은 안정적으로 유지되고 있습니다.` };
      }
    },
    'SAA': {
      name: 'SAA(어깨전방각)',
      unit: '°',
      normal: '0-10°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        if(delta < -2) return { status: 'improved', comment: `어깨 전방각이 ${Math.abs(delta).toFixed(1)}° 감소하여 둥근어깨 패턴이 완화되었습니다.` };
        if(delta > 2) return { status: 'worsened', comment: `어깨 전방각이 ${delta.toFixed(1)}° 증가하여 둥근어깨 패턴이 악화되었습니다.` };
        return { status: 'stable', comment: `어깨 전방각은 안정적으로 유지되고 있습니다.` };
      }
    },
    'PTA': {
      name: 'PTA(골반 전후경사각)',
      unit: '°',
      normal: '0-15°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        const inRange = after >= 0 && after <= 15;
        if(inRange && Math.abs(delta) < 2) return { status: 'stable', comment: `골반 전방경사가 약간 변화했으나 정상범위로 유지됩니다.` };
        if(delta > 2) return { status: 'worsened', comment: `골반 전방경사가 ${delta.toFixed(1)}° 증가하여 골반 기울기가 악화되었습니다.` };
        if(delta < -2) return { status: 'improved', comment: `골반 전방경사가 ${Math.abs(delta).toFixed(1)}° 감소하여 골반 정렬이 개선되었습니다.` };
        return { status: 'stable', comment: `골반 전후경사각은 안정적으로 유지되고 있습니다.` };
      }
    },
    'KA': {
      name: 'KA(무릎각)',
      unit: '°',
      normal: '175-185°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        const inRange = after >= 175 && after <= 185;
        const closerTo180 = Math.abs(after - 180) < Math.abs(before - 180);
        if(inRange && closerTo180) return { status: 'improved', comment: `하지 정렬이 보다 직선화되어 균형적인 정렬을 보입니다.` };
        if(inRange && Math.abs(delta) < 3) return { status: 'stable', comment: `무릎각은 정상범위 내에서 안정적으로 유지되고 있습니다.` };
        if(!inRange && delta > 0 && after < 180) return { status: 'worsened', comment: `무릎각이 ${delta.toFixed(1)}° 증가하여 과신전 패턴이 악화되었습니다.` };
        if(!inRange && delta < 0 && after > 185) return { status: 'worsened', comment: `무릎각이 ${Math.abs(delta).toFixed(1)}° 감소하여 굴곡 패턴이 악화되었습니다.` };
        return { status: 'stable', comment: `무릎각은 안정적으로 유지되고 있습니다.` };
      }
    },
    'Tibial_Angle': {
      name: 'Tibial(경골경사각)',
      unit: '°',
      normal: '0-10°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        const inRange = after >= 0 && after <= 10;
        if(inRange && Math.abs(delta) < 2) return { status: 'stable', comment: `하퇴의 전방기울기가 변화했으나 기능적으로 안정적인 범위입니다.` };
        if(delta > 2) return { status: 'worsened', comment: `경골경사각이 ${delta.toFixed(1)}° 증가하여 하퇴 정렬이 악화되었습니다.` };
        if(delta < -2) return { status: 'improved', comment: `경골경사각이 ${Math.abs(delta).toFixed(1)}° 감소하여 하퇴 정렬이 개선되었습니다.` };
        return { status: 'stable', comment: `경골경사각은 안정적으로 유지되고 있습니다.` };
      }
    },
    'GSB': {
      name: 'GSB(중력중심선)',
      unit: 'cm',
      normal: '≤2cm',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        if(delta < -0.5) return { status: 'improved', comment: `체중 중심선 편차가 ${Math.abs(delta).toFixed(1)}cm 줄어들어 자세 안정성이 향상되었습니다.` };
        if(delta > 0.5) return { status: 'worsened', comment: `체중 중심선 편차가 ${delta.toFixed(1)}cm 증가하여 자세 불안정성이 증가했습니다.` };
        return { status: 'stable', comment: `체중 중심선은 안정적으로 유지되고 있습니다.` };
      }
    },
    'HPA': {
      name: 'HPA(고관절각)',
      unit: '°',
      normal: '0-10°',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        if(delta < -2) return { status: 'improved', comment: `머리-골반 정렬이 개선되어 체간 협응이 향상되었습니다.` };
        if(delta > 2) return { status: 'worsened', comment: `머리-골반 정렬이 악화되어 체간 협응이 저하되었습니다.` };
        return { status: 'stable', comment: `머리-골반 정렬은 안정적으로 유지되고 있습니다.` };
      }
    },
    'PDS': {
      name: 'PDS(자세점수)',
      unit: '점',
      normal: '정상',
      analyze: (before, after, delta) => {
        if(before == null || after == null) return null;
        // PDS는 낮을수록 좋음
        if(delta < -2) return { status: 'improved', comment: `전반적인 자세 점수가 ${Math.abs(delta).toFixed(1)}점 개선되어 자세 품질이 향상되었습니다.` };
        if(delta > 2) return { status: 'worsened', comment: `전반적인 자세 점수가 ${delta.toFixed(1)}점 악화되었습니다.` };
        return { status: 'stable', comment: `전반적인 자세 점수는 일정하며, 안정적인 자세 패턴을 유지하고 있습니다.` };
      }
    }
  };
  
  const results = [];
  let improvedCount = 0;
  let worsenedCount = 0;
  let stableCount = 0;
  let highlightItem = null;
  let maxImprovement = 0;
  
  // 각 지표 분석
  Object.keys(metricRules).forEach(key => {
    const rule = metricRules[key];
    const before = getMetricValue(bMetrics, key);
    const after = getMetricValue(aMetrics, key);
    
    if(before == null || after == null) return;
    
    const delta = after - before;
    const analysis = rule.analyze(before, after, delta);
    
    if(analysis) {
      results.push({
        key,
        name: rule.name,
        unit: rule.unit,
        normal: rule.normal,
        before,
        after,
        delta,
        ...analysis
      });
      
      if(analysis.status === 'improved') {
        improvedCount++;
        if(Math.abs(delta) > maxImprovement) {
          maxImprovement = Math.abs(delta);
          highlightItem = rule.name;
        }
      } else if(analysis.status === 'worsened') {
        worsenedCount++;
      } else {
        stableCount++;
      }
    }
  });
  
  // 전체 요약 코멘트 생성
  const focusRegion = improvedCount > worsenedCount ? '상부 체간' : worsenedCount > 0 ? '전신 정렬' : '안정화';
  const overallComment = `📊 전반적인 분석 결과, ${improvedCount}개 항목에서 자세가 개선되었으며 ${stableCount}개 항목은 안정적으로 유지되었습니다.${worsenedCount > 0 ? ` ${worsenedCount}개 항목에서 악화가 관찰되었습니다.` : ''}${highlightItem ? ` 특히 ${highlightItem} 지표에서 두드러진 향상이 관찰되며,` : ''} 전신의 수직정렬과 체간-골반 협응이 ${improvedCount > worsenedCount ? '향상' : improvedCount === worsenedCount ? '유지' : '개선 필요'}되었습니다. 필라테스 프로그램에서는 ${focusRegion} 부위의 근긴장 조절 및 안정화 운동을 중심으로 진행하는 것이 효과적입니다.`;
  
  return {
    results,
    summary: {
      improvedCount,
      worsenedCount,
      stableCount,
      highlightItem,
      overallComment
    }
  };
}

// ✅ 운동 추천 엔진 - 분석 결과를 받아서 패턴별 근육과 운동 추천 생성
function generatePostureRecommendations(analysis) {
  const patterns = [];
  
  function addPattern({pattern, condition, tight, weak, exercises}) {
    patterns.push({
      pattern: pattern,
      condition: condition,
      tight_muscles: tight,
      weak_muscles: weak,
      recommended_exercises: exercises
    });
  }
  
  // 측면 분석 결과에서 값 추출
  const side = analysis.side || {};
  const front = analysis.front || {};
  
  // 측면 지표
  const cva = side.CVA?.value_deg;
  const hpd = side.HPD?.value_cm;
  const saa = side.SAA?.value_deg;
  const pta = side.PTA?.value_deg;
  const ka = side.KA?.value_deg;
  const gsb = side.GSB?.value_cm;
  
  // 정면 지표
  const frontKA = front.KA?.value_deg;
  
  // 거북목 (FHP)
  if (cva != null && cva < 50) {
    addPattern({
      pattern: "거북목(FHP)",
      condition: "CVA↓ / HPD↑",
      tight: ["SCM", "상부승모", "견갑거근", "소흉근"],
      weak: ["심부경부굴근", "하부승모", "전거근"],
      exercises: {
        "매트": ["Chin Tuck & Axial Elongation (턱당기기 + 축신장)", "Swan Prep"],
        "리포머": ["Pulling Straps"],
        "캐딜락": ["Tower Swan"],
        "체어": ["Press Down Front"],
        "바렐": ["Swan on Ladder Barrel"]
      }
    });
  }
  
  // 라운드숄더 (RSP)
  if (saa != null && saa > 10) {
    addPattern({
      pattern: "라운드숄더(RSP)",
      condition: "SAA↑",
      tight: ["대흉근", "소흉근", "상부승모"],
      weak: ["하부승모", "능형근", "전거근"],
      exercises: {
        "매트": ["Prone Scapular Retraction"],
        "리포머": ["Rowing Back", "Pulling Straps"],
        "캐딜락": ["Arm Springs - Extension"],
        "체어": ["Spine Stretch Forward (Chair Ver.)"],
        "바렐": ["Shoulder Extension on Barrel"]
      }
    });
  }
  
  // 과전경사 골반 (Anterior Tilt) - ASIS가 PSIS보다 낮음 (양수 값)
  if (pta != null && pta > 15) {
    addPattern({
      pattern: "과전경사 골반 (Anterior Tilt)",
      condition: "PTA↑ (양수), ASIS가 PSIS보다 낮음",
      tight: ["장요근", "대퇴직근", "척추기립근"],
      weak: ["복직근", "복횡근", "둔근"],
      exercises: {
        "매트": ["Pelvic Curl", "Dead Bug / Toe Tap"],
        "리포머": ["Bridge on Reformer"],
        "캐딜락": ["Roll Down with Push Through Bar"],
        "체어": ["Standing Hip Extension"],
        "바렐": ["Short Box Round Back"]
      }
    });
  }
  
  // 후경사 골반 (Posterior Tilt) - ASIS가 PSIS보다 높음 (음수 값)
  if (pta != null && (pta < 0 || pta < 5)) {
    addPattern({
      pattern: "후경사 골반 (Posterior Tilt)",
      condition: "PTA↓ (음수 또는 작은 값), ASIS가 PSIS보다 높음",
      tight: ["햄스트링", "복직근"],
      weak: ["장요근", "대퇴직근", "척추기립근"],
      exercises: {
        "매트": ["Leg Pull Front"],
        "리포머": ["Footwork - Parallel Heels"],
        "캐딜락": ["Leg Springs - Supine"],
        "체어": ["Swan Press"],
        "바렐": ["Swan on Barrel"]
      }
    });
  }
  
  // X자 다리 (Genu Valgum) - 측면 또는 정면 KA 사용
  const kaValue = ka || frontKA;
  if (kaValue != null && kaValue < 175) {
    addPattern({
      pattern: "X자 다리 (Genu Valgum)",
      condition: "KA↓, Q-Angle↑",
      tight: ["내전근", "내측광근"],
      weak: ["중둔근", "외회전근", "외측광근"],
      exercises: {
        "매트": ["Side-Lying Leg Lift"],
        "리포머": ["Side Splits"],
        "캐딜락": ["Standing Hip Abduction"],
        "체어": ["Step Up Lateral"],
        "바렐": ["Side Bend Stretch"]
      }
    });
  }
  
  // O자 다리 (Genu Varum)
  if (kaValue != null && kaValue > 180) {
    addPattern({
      pattern: "O자 다리 (Genu Varum)",
      condition: "KA↑",
      tight: ["외측광근", "비복근", "대퇴이두"],
      weak: ["내전근", "내측광근"],
      exercises: {
        "매트": ["Ball Squeeze Bridge"],
        "리포머": ["Footwork - Small V Position"],
        "캐딜락": ["Standing Leg Press - Adduction"],
        "체어": ["Seated Adduction"],
        "바렐": ["Adductor Stretch on Barrel"]
      }
    });
  }
  
  // 전방 체중 중심 (Forward Center)
  if (gsb != null && gsb > 2) {
    addPattern({
      pattern: "체중 중심 전방 (Forward Center)",
      condition: "GSB↑",
      tight: ["대퇴직근", "요추기립근", "종아리근"],
      weak: ["둔근", "햄스트링", "복부"],
      exercises: {
        "매트": ["Pelvic Curl"],
        "리포머": ["Scooter"],
        "캐딜락": ["Tower Roll Up"],
        "체어": ["Standing Leg Press"],
        "바렐": ["Swan"]
      }
    });
  }
  
  // 후방 체중 중심 (Backward Center)
  if (gsb != null && gsb < -2) {
    addPattern({
      pattern: "체중 중심 후방 (Backward Center)",
      condition: "GSB↓",
      tight: ["햄스트링", "둔근"],
      weak: ["장요근", "대퇴직근"],
      exercises: {
        "매트": ["Hip Flexor Stretch"],
        "리포머": ["Standing Lunge"],
        "캐딜락": ["Leg Springs - Supine"],
        "체어": ["Step Up Front"],
        "바렐": ["Lunge on Barrel"]
      }
    });
  }
  
  return { patterns: patterns };
}

// ✅ 통합 분석 함수 - 측면/정면 자동 감지
function analyzePostureAuto(options = {}) {
  const {
    sidePts = null,
    frontPts = null,
    pxPerCm = 50.0,
    imageWidth = cv ? (cv.width / DPR) : 1080 // 캔버스 너비 또는 기본값
  } = options;
  
  const result = {
    side: {},
    front: {},
    summary: {}
  };
  
  // 측면 분석
  if (sidePts != null && Object.keys(sidePts).length > 0) {
    result.side = analyzeFullPosture(sidePts, pxPerCm, imageWidth);
  } else {
    result.side.status = "not_available";
  }
  
  // 정면 분석
  if (frontPts != null && Object.keys(frontPts).length > 0) {
    result.front = analyzeFrontPosture(frontPts, pxPerCm);
  } else {
    result.front.status = "not_available";
  }
  
  // 통합 점수 계산
  const sidePDS = result.side.PDS?.value || 0;
  const frontPDS = result.front.PDS?.value || 0;
  
  const availableCount = [
    result.side.status !== "not_available",
    result.front.status !== "not_available"
  ].filter(e => e).length;
  
  if (availableCount > 0) {
    const avg = (sidePDS + frontPDS) / (availableCount === 2 ? 2 : 1);
    result.summary = {
      PDS_total: avg.toFixed(1),
      risk_level: avg < 10 
        ? "정상" 
        : avg < 15 
          ? "경미한 불균형" 
          : "중등도 이상 불균형"
    };
  } else {
    result.summary.status = "not_available";
  }
  
  return result;
}

// ✅ 통합 분석 + 운동 추천 결합
function analyzePostureAutoWithRecommendation(options = {}) {
  const {
    sidePts = null,
    frontPts = null,
    pxPerCm = 50.0
  } = options;
  
  // 기본 통합 분석 실행
  const imageWidth = cv ? (cv.width / DPR) : 1080; // 캔버스 너비 또는 기본값
  const result = analyzePostureAuto({
    sidePts: sidePts,
    frontPts: frontPts,
    pxPerCm: pxPerCm,
    imageWidth: imageWidth
  });
  
  // 분석 결과를 통합하여 운동 추천 생성
  const analysis = {
    side: result.side,
    front: result.front,
    summary: result.summary
  };
  
  // 운동 추천 생성
  const recommendation = generatePostureRecommendations(analysis);
  result.recommendations = recommendation;
  
  return result;
}

// ✅ 실시간 분석 엔진 (Stream 기반)
class LivePostureAnalyzer {
  constructor() {
    this.listeners = [];
    this.isAnalyzing = false;
    this.lastResult = null;
  }
  
  // 리스너 추가 (실시간 결과 수신)
  addListener(callback) {
    this.listeners.push(callback);
  }
  
  // 리스너 제거
  removeListener(callback) {
    const index = this.listeners.indexOf(callback);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }
  
  // 결과 브로드캐스트
  _broadcast(result) {
    this.lastResult = result;
    this.listeners.forEach(callback => {
      try {
        callback(result);
      } catch (error) {
        console.error('Listener error:', error);
      }
    });
  }
  
  // 실시간 분석 실행 (매 프레임/좌표 변경 시)
  analyzeFrame(options = {}) {
    if (this.isAnalyzing) {
      return this.lastResult; // 이미 분석 중이면 마지막 결과 반환
    }
    
    this.isAnalyzing = true;
    
    try {
      const {
        sidePts = null,
        frontPts = null,
        pxPerCm = 50.0
      } = options;
      
      // 통합 분석 실행
      const analysisResult = analyzePostureAutoWithRecommendation({
        sidePts: sidePts,
        frontPts: frontPts,
        pxPerCm: pxPerCm
      });
      
      // 실시간 결과 포맷 (JSON 출력 예시 구조)
      const result = {
        timestamp: new Date().toISOString(),
        analysis: {
          side: analysisResult.side,
          front: analysisResult.front,
          summary: analysisResult.summary
        },
        recommendations: analysisResult.recommendations || { patterns: [] }
      };
      
      // 주요 지표 추출 (실시간 표시용)
      const sideMetrics = analysisResult.side || {};
      const frontMetrics = analysisResult.front || {};
      const summary = analysisResult.summary || {};
      
      result.liveMetrics = {
        CVA: sideMetrics.CVA ? { value: sideMetrics.CVA.value_deg, status: sideMetrics.CVA.status } : null,
        PTA: sideMetrics.PTA ? { value: sideMetrics.PTA.value_deg, status: sideMetrics.PTA.status } : null,
        KA: sideMetrics.KA ? { value: sideMetrics.KA.value_deg, status: sideMetrics.KA.status } : (frontMetrics.KA ? { value: frontMetrics.KA.value_deg, status: frontMetrics.KA.status } : null),
        PDS: summary.PDS_total ? parseFloat(summary.PDS_total) : 0,
        risk_level: summary.risk_level || 'unknown'
      };
      
      // 브로드캐스트
      this._broadcast(result);
      
      return result;
    } finally {
      this.isAnalyzing = false;
    }
  }
  
  // 현재 세션의 키포인트로 실시간 분석
  analyzeCurrentSession() {
    const S = sessions[cur];
    const pxPerCm = S.pxPerCm || 50.0;
    
    // 측면 및 정면 키포인트 변환
    const sidePoints = {};
    const frontPoints = {};
    
    for(const [key, value] of S.sidePoints.entries()) {
      if(value && value.x != null && value.y != null) {
        sidePoints[key] = { x: value.x, y: value.y };
      }
    }
    
    for(const [key, value] of S.frontPoints.entries()) {
      if(value && value.x != null && value.y != null) {
        frontPoints[key] = { x: value.x, y: value.y };
      }
    }
    
    return this.analyzeFrame({
      sidePts: Object.keys(sidePoints).length > 0 ? sidePoints : null,
      frontPts: Object.keys(frontPoints).length > 0 ? frontPoints : null,
      pxPerCm: pxPerCm
    });
  }
}

// 전역 실시간 분석기 인스턴스
const liveAnalyzer = new LivePostureAnalyzer();

// 🏋️‍♀️ 패턴 기반 필라테스 추천 시스템 (BASI/Polestar/STOTT 기준)
const pilatesPatterns = {
  // 1️⃣ 거북목(FHP): CVA↓, HPD↑
  'FHP': {
    name: '거북목 (Forward Head Posture)',
    condition: 'CVA↓ / HPD↑',
    tight: ['SCM', '상부승모', '견갑거근', '소흉근'],
    weak: ['심부경부굴근', '하부승모', '전거근'],
    interpretation: '머리 전방 돌출, 경추 전만 감소',
    exercises: {
      매트: [
        { en: 'Chin Tuck & Axial Elongation', ko: '턱당기기 + 축신장', purpose: '경추 안정화' },
        { en: 'Swan Prep', ko: '스완 준비', purpose: '흉추 신전, 승모근 하부 강화' }
      ],
      리포머: [
        { en: 'Pulling Straps', ko: '풀링 스트랩', purpose: '견갑 후방 안정화' }
      ],
      캐딜락: [
        { en: 'Tower Swan', ko: '타워 스완', purpose: '흉추 신전 + 견갑 후방운동' }
      ],
      체어: [
        { en: 'Press Down Front', ko: '프레스 다운 프론트', purpose: '경추 정렬 + 전거근 활성화' }
      ],
      바렐: [
        { en: 'Swan on Ladder Barrel', ko: '래더 배럴 스완', purpose: '흉추 가동성, 승모하부 강화' }
      ]
    }
  },
  
  // 2️⃣ 라운드숄더(RSP): SAA↑
  'RSP': {
    name: '라운드숄더 (Rounded Shoulder Posture)',
    condition: 'SAA↑',
    tight: ['대흉근', '소흉근', '상부승모'],
    weak: ['하부승모', '능형근', '전거근'],
    interpretation: '견갑 전인·상방회전',
    exercises: {
      매트: [
        { en: 'Prone Scapular Retraction', ko: '프론 사투라 견갑골 후인', purpose: '견갑골 후인 강화' }
      ],
      리포머: [
        { en: 'Rowing Back / Pulling Straps', ko: '로잉 백 / 풀링 스트랩', purpose: '견갑 안정화' }
      ],
      캐딜락: [
        { en: 'Arm Springs - Extension', ko: '암 스프링 - 익스텐션', purpose: '어깨 후방근 강화' }
      ],
      체어: [
        { en: 'Spine Stretch Forward (Chair Ver.)', ko: '스파인 스트레치 포워드 (체어 버전)', purpose: '견갑 안정화 및 흉추 신전' }
      ],
      바렐: [
        { en: 'Shoulder Extension on Barrel', ko: '배럴 어깨 익스텐션', purpose: '흉추 가동성 + 어깨 후인근 강화' }
      ]
    }
  },
  
  // 3️⃣ 과전경사 골반: PTA↑ (양수 값, ASIS가 PSIS보다 낮음)
  'AnteriorTilt': {
    name: '과전경사 골반 (Anterior Pelvic Tilt)',
    condition: 'PTA↑ (양수), ASIS가 PSIS보다 낮음',
    tight: ['장요근', '대퇴직근', '척추기립근'],
    weak: ['복직근', '복횡근', '둔근'],
    interpretation: '골반 전방경사 / 요추 전만 증가',
    exercises: {
      매트: [
        { en: 'Pelvic Curl', ko: '펠빅 컬', purpose: '골반 후경사 유도' },
        { en: 'Dead Bug / Toe Tap', ko: '데드 버그 / 토 탭', purpose: '복횡근 활성화' }
      ],
      리포머: [
        { en: 'Bridge on Reformer', ko: '리포머 브릿지', purpose: '후방 사슬 강화' }
      ],
      캐딜락: [
        { en: 'Roll Down with Push Through Bar', ko: '롤 다운 (푸시 스루 바)', purpose: '복부 코어 조절' }
      ],
      체어: [
        { en: 'Standing Hip Extension', ko: '스탠딩 힙 익스텐션', purpose: '둔근 강화' }
      ],
      바렐: [
        { en: 'Short Box Round Back', ko: '숏 박스 라운드 백', purpose: '코어 + 후방 사슬 강화' }
      ]
    }
  },
  
  // 4️⃣ 후경사 골반: PTA↓ (음수 값, ASIS가 PSIS보다 높음)
  'PosteriorTilt': {
    name: '후경사 골반 (Posterior Pelvic Tilt)',
    condition: 'PTA↓ (음수 또는 작은 값), ASIS가 PSIS보다 높음',
    tight: ['햄스트링', '복직근'],
    weak: ['장요근', '대퇴직근', '척추기립근'],
    interpretation: '골반 후방경사 / 요추 편평',
    exercises: {
      매트: [
        { en: 'Leg Pull Front', ko: '레그 풀 프론트', purpose: '전방 사슬 강화' }
      ],
      리포머: [
        { en: 'Footwork - Parallel Heels', ko: '풋워크 - 패럴렐 힐즈', purpose: '고관절 신전 활성화' }
      ],
      캐딜락: [
        { en: 'Leg Springs - Supine', ko: '레그 스프링 - 슈파인', purpose: '장요근 기능적 수축' }
      ],
      체어: [
        { en: 'Swan Press', ko: '스완 프레스', purpose: '요추 신전 강화' }
      ],
      바렐: [
        { en: 'Swan on Barrel', ko: '배럴 스완', purpose: '요추 가동성 향상' }
      ]
    }
  },
  
  // 5️⃣ X자 다리: KA↓, Q-Angle↑
  'GenuValgum': {
    name: 'X자 다리 (Genu Valgum)',
    condition: 'KA↓, Q-Angle↑',
    tight: ['내전근', '내측광근'],
    weak: ['중둔근', '외회전근', '외측광근'],
    interpretation: '슬개골 외측 압박 패턴',
    exercises: {
      매트: [
        { en: 'Side-Lying Leg Lift', ko: '사이드 라잉 레그 리프트', purpose: '중둔근 강화' }
      ],
      리포머: [
        { en: 'Side Splits', ko: '사이드 스플릿', purpose: '외측 안정화' }
      ],
      캐딜락: [
        { en: 'Standing Hip Abduction', ko: '스탠딩 힙 외전', purpose: '고관절 외전 강화' }
      ],
      체어: [
        { en: 'Step Up Lateral', ko: '스텝 업 레터럴', purpose: '하지 외측 안정성' }
      ],
      바렐: [
        { en: 'Side Bend Stretch', ko: '사이드 벤드 스트레치', purpose: '고관절 정렬 및 안정성 개선' }
      ]
    }
  },
  
  // 6️⃣ O자 다리: KA↑
  'GenuVarum': {
    name: 'O자 다리 (Genu Varum)',
    condition: 'KA↑',
    tight: ['외측광근', '비복근', '대퇴이두'],
    weak: ['내전근', '내측광근'],
    interpretation: '외측 과부하',
    exercises: {
      매트: [
        { en: 'Ball Squeeze Bridge', ko: '볼 스퀴즈 브릿지', purpose: '내전근 활성화' }
      ],
      리포머: [
        { en: 'Footwork - Small V Position', ko: '풋워크 - 스몰 V 포지션', purpose: '내측광근 강화' }
      ],
      캐딜락: [
        { en: 'Standing Leg Press - Adduction', ko: '스탠딩 레그 프레스 - 내전', purpose: '내전근 강화' }
      ],
      체어: [
        { en: 'Seated Adduction', ko: '시티드 내전', purpose: '내측 근육 조절' }
      ],
      바렐: [
        { en: 'Adductor Stretch on Barrel', ko: '배럴 내전근 스트레치', purpose: '내전근 가동성 향상' }
      ]
    }
  },
  
  // 7️⃣ 체중 중심 전방: GSB↑
  'ForwardCenter': {
    name: '체중 중심 전방 (Forward Center)',
    condition: 'GSB↑',
    tight: ['대퇴직근', '요추기립근', '종아리근'],
    weak: ['둔근', '햄스트링', '복부'],
    interpretation: '체간 전방기울임',
    exercises: {
      매트: [
        { en: 'Pelvic Curl', ko: '펠빅 컬', purpose: '둔근/햄스트링 강화' }
      ],
      리포머: [
        { en: 'Scooter', ko: '스쿠터', purpose: '둔근 신전 조절' }
      ],
      캐딜락: [
        { en: 'Tower Roll Up', ko: '타워 롤 업', purpose: '코어 활성화' }
      ],
      체어: [
        { en: 'Standing Leg Press', ko: '스탠딩 레그 프레스', purpose: '후방 체중 이동 훈련' }
      ],
      바렐: [
        { en: 'Swan', ko: '스완', purpose: '흉추 안정화' }
      ]
    }
  },
  
  // 8️⃣ 체중 중심 후방: GSB↓
  'BackwardCenter': {
    name: '체중 중심 후방 (Backward Center)',
    condition: 'GSB↓',
    tight: ['햄스트링', '둔근'],
    weak: ['장요근', '대퇴직근'],
    interpretation: '체간 후방기울임',
    exercises: {
      매트: [
        { en: 'Hip Flexor Stretch', ko: '힙 플렉서 스트레치', purpose: '전방 사슬 활성화' }
      ],
      리포머: [
        { en: 'Standing Lunge', ko: '스탠딩 런지', purpose: '고관절 신전/굴곡 밸런스' }
      ],
      캐딜락: [
        { en: 'Leg Springs - Supine', ko: '레그 스프링 - 슈파인', purpose: '장요근 강화' }
      ],
      체어: [
        { en: 'Step Up Front', ko: '스텝 업 프론트', purpose: '하지 전방 안정화' }
      ],
      바렐: [
        { en: 'Lunge on Barrel', ko: '배럴 런지', purpose: '고관절 전방이동 훈련' }
      ]
    }
  }
};

// 필라테스 운동 상세 설명 데이터베이스
const pilatesExerciseDescriptions = {
  // 거북목(FHP) 관련 운동
  'Chin Tuck & Axial Elongation': {
    ko: '턱당기기 + 축신장',
    description: '목과 척추를 정렬하면서 경추를 안정화하는 기본 동작입니다. 벽에 등을 대고 서서 턱을 뒤로 당기며 머리 꼭대기를 천장 방향으로 늘립니다. 상부 승모근의 긴장을 완화하고 심부 경부 굴근을 활성화합니다.',
    instructions: '1) 벽에 등을 대고 서서 뒤통수가 벽에 닿도록 합니다. 2) 턱을 뒤로 당기며 목 앞쪽 근육을 수축합니다. 3) 머리 꼭대기를 천장 방향으로 늘리며 10초 유지합니다. 4) 천천히 원래 자세로 돌아옵니다. 5회 반복합니다.',
    benefits: '경추 정렬 개선, 상부 승모근 긴장 완화, 심부 경부 굴근 강화, 거북목 자세 교정',
    precautions: '목 통증이 있으면 즉시 중단하고, 과도한 힘을 주지 않습니다.'
  },
  'Swan Prep': {
    ko: '스완 준비',
    description: '흉추 신전을 유도하면서 하부 승모근을 강화하는 동작입니다. 복부와 둔근을 활성화하여 척추를 안정적으로 지지하면서 상체를 들어올립니다.',
    instructions: '1) 엎드린 자세에서 손바닥을 어깨 옆에 둡니다. 2) 복부와 둔근을 수축하여 척추를 안정화합니다. 3) 상체를 천천히 들어올리며 어깨뼈를 아래로 눌러 모읍니다. 4) 목은 자연스럽게 연장하여 턱이 앞으로 나가지 않도록 합니다. 5) 5-10초 유지 후 천천히 내려옵니다. 5회 반복합니다.',
    benefits: '흉추 신전 개선, 하부 승모근 강화, 어깨뼈 안정화, 거북목 자세 보조 교정',
    precautions: '요통이 있으면 높이를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  'Pulling Straps': {
    ko: '풀링 스트랩',
    description: '리포머를 사용한 견갑 후방 안정화 운동입니다. 어깨뼈를 후인시키고 하부 승모근을 활성화하여 라운드 숄더와 거북목 자세를 교정합니다.',
    instructions: '1) 리포머에 앉아 스트랩을 잡습니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 팔을 앞으로 뻗은 상태에서 시작합니다. 4) 어깨뼈를 모으며 팔꿈치를 뒤로 당깁니다. 5) 어깨뼈가 아래로 눌러지도록 의식하며 10회 반복합니다.',
    benefits: '견갑 후인 강화, 하부 승모근 활성화, 라운드 숄더 교정, 어깨 안정성 향상',
    precautions: '목을 앞으로 내밀지 않고, 어깨를 올리지 않도록 주의합니다.'
  },
  'Tower Swan': {
    ko: '타워 스완',
    description: '캐딜락 타워를 사용한 흉추 신전 및 견갑 후방 운동입니다. 상체를 들어올리면서 어깨뼈를 안정적으로 위치시키고 흉추 가동성을 개선합니다.',
    instructions: '1) 캐딜락 타워 앞에 엎드립니다. 2) 팔을 타워 바에 올려놓고 복부를 수축합니다. 3) 상체를 들어올리며 어깨뼈를 아래로 눌러 모읍니다. 4) 흉추를 차례로 신전시키며 척추를 연장합니다. 5) 5-10초 유지 후 천천히 내려옵니다. 5회 반복합니다.',
    benefits: '흉추 신전 개선, 어깨뼈 안정화, 하부 승모근 강화, 거북목 자세 교정',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  'Press Down Front': {
    ko: '프레스 다운 프론트',
    description: '필라테스 체어를 사용한 경추 정렬 및 전거근 활성화 운동입니다. 팔을 아래로 누르면서 어깨뼈를 안정화하고 경추를 중립 위치로 유지합니다.',
    instructions: '1) 체어에 앉아 손바닥을 팔걸이에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 팔을 아래로 누르면서 어깨뼈를 안정화합니다. 4) 목을 자연스럽게 연장하여 턱이 앞으로 나가지 않도록 합니다. 5) 5-10회 반복합니다.',
    benefits: '경추 정렬 개선, 전거근 활성화, 어깨뼈 안정화, 거북목 자세 교정',
    precautions: '어깨를 올리지 않고, 목에 과도한 긴장을 주지 않습니다.'
  },
  'Swan on Ladder Barrel': {
    ko: '래더 배럴 스완',
    description: '래더 배럴을 사용한 흉추 가동성 및 승모근 하부 강화 운동입니다. 상체를 뒤로 젖히면서 흉추를 신전시키고 어깨뼈를 안정화합니다.',
    instructions: '1) 래더 배럴에 등을 대고 앉습니다. 2) 복부를 수축하여 척추를 안정화합니다. 3) 상체를 뒤로 젖히면서 흉추를 차례로 신전시킵니다. 4) 어깨뼈를 아래로 눌러 모으며 하부 승모근을 활성화합니다. 5) 5-10초 유지 후 천천히 돌아옵니다. 5회 반복합니다.',
    benefits: '흉추 가동성 향상, 승모근 하부 강화, 어깨뼈 안정화, 거북목 자세 보조 교정',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  
  // 라운드 숄더(RSP) 관련 운동
  'Prone Scapular Retraction': {
    ko: '프론 사투라 견갑골 후인',
    description: '엎드린 자세에서 어깨뼈를 후인시키는 운동입니다. 능형근과 중부 승모근을 활성화하여 라운드 숄더를 교정합니다.',
    instructions: '1) 엎드린 자세에서 팔을 옆으로 뻗습니다. 2) 복부를 수축하여 척추를 안정화합니다. 3) 어깨뼈를 모으며 팔을 약간 들어올립니다. 4) 어깨뼈가 아래로 눌러지도록 의식하며 10초 유지합니다. 5) 천천히 내려옵니다. 10회 반복합니다.',
    benefits: '견갑 후인 강화, 능형근 활성화, 라운드 숄더 교정, 어깨 안정성 향상',
    precautions: '어깨를 올리지 않고, 목에 긴장을 주지 않습니다.'
  },
  'Rowing Back / Pulling Straps': {
    ko: '로잉 백 / 풀링 스트랩',
    description: '리포머를 사용한 견갑 안정화 운동입니다. 팔을 뒤로 당기면서 어깨뼈를 후인시키고 하부 승모근을 강화합니다.',
    instructions: '1) 리포머에 앉아 스트랩을 잡습니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 팔을 앞으로 뻗은 상태에서 시작합니다. 4) 어깨뼈를 모으며 팔꿈치를 뒤로 당깁니다. 5) 어깨뼈가 아래로 눌러지도록 의식하며 10회 반복합니다.',
    benefits: '견갑 안정화, 하부 승모근 강화, 라운드 숄더 교정, 어깨 후방근 활성화',
    precautions: '목을 앞으로 내밀지 않고, 어깨를 올리지 않도록 주의합니다.'
  },
  'Arm Springs - Extension': {
    ko: '암 스프링 - 익스텐션',
    description: '캐딜락 암 스프링을 사용한 어깨 후방근 강화 운동입니다. 팔을 뒤로 뻗으면서 어깨뼈를 안정화하고 후방 근육을 활성화합니다.',
    instructions: '1) 캐딜락에 앉아 암 스프링을 잡습니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 팔을 앞으로 뻗은 상태에서 시작합니다. 4) 어깨뼈를 모으며 팔을 뒤로 뻗습니다. 5) 어깨뼈가 아래로 눌러지도록 의식하며 10회 반복합니다.',
    benefits: '어깨 후방근 강화, 견갑 안정화, 라운드 숄더 교정, 어깨 가동성 향상',
    precautions: '어깨를 올리지 않고, 목에 긴장을 주지 않습니다.'
  },
  'Spine Stretch Forward (Chair Ver.)': {
    ko: '스파인 스트레치 포워드 (체어 버전)',
    description: '필라테스 체어를 사용한 견갑 안정화 및 흉추 신전 운동입니다. 상체를 앞으로 숙이면서 척추를 연장시키고 어깨뼈를 안정화합니다.',
    instructions: '1) 체어에 앉아 복부를 수축합니다. 2) 척추를 하나씩 앞으로 굽히면서 상체를 숙입니다. 3) 어깨뼈를 아래로 눌러 모으며 안정화합니다. 4) 천천히 척추를 하나씩 펴면서 돌아옵니다. 5) 5-10회 반복합니다.',
    benefits: '견갑 안정화, 흉추 가동성 향상, 척추 연장, 라운드 숄더 보조 교정',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  'Shoulder Extension on Barrel': {
    ko: '배럴 어깨 익스텐션',
    description: '배럴을 사용한 흉추 가동성 및 어깨 후인근 강화 운동입니다. 상체를 뒤로 젖히면서 흉추를 신전시키고 어깨뼈를 안정화합니다.',
    instructions: '1) 배럴에 등을 대고 앉습니다. 2) 복부를 수축하여 척추를 안정화합니다. 3) 상체를 뒤로 젖히면서 흉추를 차례로 신전시킵니다. 4) 어깨뼈를 아래로 눌러 모으며 후인근을 활성화합니다. 5) 5-10초 유지 후 천천히 돌아옵니다. 5회 반복합니다.',
    benefits: '흉추 가동성 향상, 어깨 후인근 강화, 어깨뼈 안정화, 라운드 숄더 교정',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  
  // 과전경사 골반 관련 운동
  'Pelvic Curl': {
    ko: '펠빅 컬',
    description: '골반 후경사를 유도하는 기본 동작입니다. 복부와 둔근을 활성화하여 골반을 뒤로 기울이고 요추 전만을 감소시킵니다.',
    instructions: '1) 누워서 무릎을 구부리고 발을 바닥에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 골반을 뒤로 기울이며 엉덩이를 천천히 들어올립니다. 4) 척추를 하나씩 바닥에서 떼어냅니다. 5) 최고점에서 5-10초 유지 후 천천히 내려옵니다. 10회 반복합니다.',
    benefits: '골반 후경사 유도, 둔근 강화, 요추 전만 감소, 골반 안정화',
    precautions: '목 통증이 있으면 베개를 사용하고, 요통이 있으면 범위를 줄입니다.'
  },
  'Dead Bug / Toe Tap': {
    ko: '데드 버그 / 토 탭',
    description: '복횡근을 활성화하는 코어 안정화 운동입니다. 팔과 다리를 움직이면서 복부를 안정적으로 유지하여 골반 전방경사를 교정합니다.',
    instructions: '1) 누워서 무릎을 90도로 구부리고 팔을 위로 올립니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 반대편 팔과 다리를 천천히 내립니다. 4) 복부가 튀어나오지 않도록 유지하며 원래 자세로 돌아옵니다. 5) 좌우 교대로 10회 반복합니다.',
    benefits: '복횡근 활성화, 코어 안정화, 골반 전방경사 교정, 요추 안정성 향상',
    precautions: '요통이 있으면 범위를 줄이고, 복부가 튀어나오면 즉시 중단합니다.'
  },
  'Bridge on Reformer': {
    ko: '리포머 브릿지',
    description: '리포머를 사용한 후방 사슬 강화 운동입니다. 둔근과 햄스트링을 활성화하여 골반을 안정화하고 요추 전만을 감소시킵니다.',
    instructions: '1) 리포머에 누워 발을 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 골반을 뒤로 기울이며 엉덩이를 천천히 들어올립니다. 4) 둔근과 햄스트링을 활성화하며 10회 반복합니다.',
    benefits: '후방 사슬 강화, 둔근 활성화, 골반 안정화, 요추 전만 감소',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 베개를 사용합니다.'
  },
  'Roll Down with Push Through Bar': {
    ko: '롤 다운 (푸시 스루 바)',
    description: '캐딜락 푸시 스루 바를 사용한 복부 코어 조절 운동입니다. 상체를 굽히면서 복횡근을 활성화하여 골반 전방경사를 교정합니다.',
    instructions: '1) 캐딜락에 앉아 푸시 스루 바를 잡습니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 척추를 하나씩 굽히면서 상체를 앞으로 숙입니다. 4) 복부가 튀어나오지 않도록 유지하며 천천히 돌아옵니다. 5) 10회 반복합니다.',
    benefits: '복부 코어 조절, 복횡근 활성화, 골반 전방경사 교정, 척추 가동성 향상',
    precautions: '요통이 있으면 범위를 줄이고, 복부가 튀어나오면 즉시 중단합니다.'
  },
  'Standing Hip Extension': {
    ko: '스탠딩 힙 익스텐션',
    description: '서서 하는 둔근 강화 운동입니다. 한쪽 다리를 뒤로 뻗으면서 둔근을 활성화하여 골반을 안정화합니다.',
    instructions: '1) 서서 한쪽 손을 벽에 대고 균형을 유지합니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 한쪽 다리를 뒤로 뻗으며 둔근을 활성화합니다. 4) 골반이 기울어지지 않도록 유지하며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '둔근 강화, 골반 안정화, 요추 전만 감소, 하지 후방 사슬 활성화',
    precautions: '요통이 있으면 범위를 줄이고, 균형 문제가 있으면 벽을 잡습니다.'
  },
  'Short Box Round Back': {
    ko: '숏 박스 라운드 백',
    description: '숏 박스를 사용한 코어 및 후방 사슬 강화 운동입니다. 상체를 굽히면서 복부를 활성화하고 둔근을 강화합니다.',
    instructions: '1) 숏 박스에 앉아 복부를 수축합니다. 2) 척추를 하나씩 굽히면서 상체를 앞으로 숙입니다. 3) 복부가 튀어나오지 않도록 유지하며 천천히 돌아옵니다. 4) 10회 반복합니다.',
    benefits: '코어 강화, 후방 사슬 활성화, 골반 전방경사 교정, 척추 안정성 향상',
    precautions: '요통이 있으면 범위를 줄이고, 복부가 튀어나오면 즉시 중단합니다.'
  },
  
  // 후경사 골반 관련 운동
  'Leg Pull Front': {
    ko: '레그 풀 프론트',
    description: '전방 사슬 강화 운동입니다. 플랭크 자세에서 한쪽 다리를 들어올리면서 복부와 대퇴직근을 활성화합니다.',
    instructions: '1) 플랭크 자세에서 시작합니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 한쪽 다리를 들어올리며 대퇴직근을 활성화합니다. 4) 골반이 기울어지지 않도록 유지하며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '전방 사슬 강화, 복부 활성화, 대퇴직근 강화, 골반 후경사 교정',
    precautions: '요통이 있으면 즉시 중단하고, 어깨 통증이 있으면 무릎을 내립니다.'
  },
  'Footwork - Parallel Heels': {
    ko: '풋워크 - 패럴렐 힐즈',
    description: '리포머를 사용한 고관절 신전 활성화 운동입니다. 발뒤꿈치를 풋바에 대고 다리를 밀면서 고관절 신전근을 활성화합니다.',
    instructions: '1) 리포머에 누워 발뒤꿈치를 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 밀면서 고관절을 신전시킵니다. 4) 천천히 돌아오며 10회 반복합니다.',
    benefits: '고관절 신전 활성화, 장요근 기능적 수축, 골반 후경사 교정, 하지 전방 사슬 강화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Leg Springs - Supine': {
    ko: '레그 스프링 - 슈파인',
    description: '캐딜락 레그 스프링을 사용한 장요근 기능적 수축 운동입니다. 누운 자세에서 다리를 들어올리면서 장요근을 활성화합니다.',
    instructions: '1) 캐딜락에 누워 레그 스프링에 다리를 연결합니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 들어올리며 장요근을 활성화합니다. 4) 천천히 내리며 10회 반복합니다.',
    benefits: '장요근 기능적 수축, 고관절 굴곡 활성화, 골반 후경사 교정, 하지 전방 사슬 강화',
    precautions: '요통이 있으면 범위를 줄이고, 복부가 튀어나오면 즉시 중단합니다.'
  },
  'Swan Press': {
    ko: '스완 프레스',
    description: '필라테스 체어를 사용한 요추 신전 강화 운동입니다. 상체를 뒤로 젖히면서 척추기립근을 활성화합니다.',
    instructions: '1) 체어에 앉아 복부를 수축합니다. 2) 척추를 하나씩 뒤로 젖히면서 상체를 연장합니다. 3) 척추기립근을 활성화하며 5-10초 유지합니다. 4) 천천히 돌아오며 10회 반복합니다.',
    benefits: '요추 신전 강화, 척추기립근 활성화, 골반 후경사 교정, 척추 가동성 향상',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  'Swan on Barrel': {
    ko: '배럴 스완',
    description: '배럴을 사용한 요추 가동성 향상 운동입니다. 상체를 뒤로 젖히면서 척추를 신전시키고 가동성을 개선합니다.',
    instructions: '1) 배럴에 등을 대고 앉습니다. 2) 복부를 수축하여 척추를 안정화합니다. 3) 상체를 뒤로 젖히면서 척추를 차례로 신전시킵니다. 4) 5-10초 유지 후 천천히 돌아옵니다. 5) 5회 반복합니다.',
    benefits: '요추 가동성 향상, 척추기립근 활성화, 골반 후경사 교정, 척추 연장',
    precautions: '요통이 있으면 범위를 줄이고, 목 통증이 있으면 즉시 중단합니다.'
  },
  
  // X자 다리 관련 운동
  'Side-Lying Leg Lift': {
    ko: '사이드 라잉 레그 리프트',
    description: '옆으로 누워서 하는 중둔근 강화 운동입니다. 다리를 옆으로 들어올리면서 고관절 외전근을 활성화하여 X자 다리를 교정합니다.',
    instructions: '1) 옆으로 누워서 아래쪽 팔로 머리를 지지합니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 위쪽 다리를 들어올리며 중둔근을 활성화합니다. 4) 골반이 앞뒤로 기울어지지 않도록 유지하며 15회 반복합니다. 5) 반대편으로 돌아서 반복합니다.',
    benefits: '중둔근 강화, 고관절 외전 활성화, X자 다리 교정, 골반 안정화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Side Splits': {
    ko: '사이드 스플릿',
    description: '리포머를 사용한 외측 안정화 운동입니다. 다리를 옆으로 벌리면서 고관절 외전근을 활성화합니다.',
    instructions: '1) 리포머에 앉아 다리를 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 옆으로 벌리며 고관절 외전근을 활성화합니다. 4) 천천히 모으며 10회 반복합니다.',
    benefits: '외측 안정화, 고관절 외전 강화, X자 다리 교정, 골반 안정성 향상',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Standing Hip Abduction': {
    ko: '스탠딩 힙 외전',
    description: '서서 하는 고관절 외전 강화 운동입니다. 한쪽 다리를 옆으로 뻗으면서 중둔근을 활성화합니다.',
    instructions: '1) 서서 한쪽 손을 벽에 대고 균형을 유지합니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 한쪽 다리를 옆으로 뻗으며 중둔근을 활성화합니다. 4) 골반이 기울어지지 않도록 유지하며 15회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '고관절 외전 강화, 중둔근 활성화, X자 다리 교정, 골반 안정화',
    precautions: '요통이 있으면 범위를 줄이고, 균형 문제가 있으면 벽을 잡습니다.'
  },
  'Step Up Lateral': {
    ko: '스텝 업 레터럴',
    description: '옆으로 올라가는 하지 외측 안정성 운동입니다. 박스를 옆으로 올라가면서 고관절 외전근을 활성화합니다.',
    instructions: '1) 박스 옆에 서서 복부를 수축합니다. 2) 한쪽 다리로 박스에 올라가며 중둔근을 활성화합니다. 3) 골반이 기울어지지 않도록 유지하며 10회 반복합니다. 4) 반대편 다리로 교대합니다.',
    benefits: '하지 외측 안정성, 고관절 외전 강화, X자 다리 교정, 기능적 움직임 개선',
    precautions: '무릎 통증이 있으면 즉시 중단하고, 균형 문제가 있으면 벽을 잡습니다.'
  },
  'Side Bend Stretch': {
    ko: '사이드 벤드 스트레치',
    description: '배럴을 사용한 고관절 정렬 및 안정성 개선 운동입니다. 옆으로 기울면서 고관절 외전근을 스트레칭하고 안정화합니다.',
    instructions: '1) 배럴 옆에 서서 한쪽 다리를 배럴에 올립니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 옆으로 기울면서 고관절 외전근을 스트레칭합니다. 4) 30초 유지 후 천천히 돌아옵니다. 5) 반대편으로 교대합니다.',
    benefits: '고관절 정렬 개선, 외전근 스트레칭, 안정성 향상, X자 다리 보조 교정',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  
  // O자 다리 관련 운동
  'Ball Squeeze Bridge': {
    ko: '볼 스퀴즈 브릿지',
    description: '볼을 무릎 사이에 끼우고 하는 내전근 활성화 운동입니다. 엉덩이를 들어올리면서 내전근을 수축하여 O자 다리를 교정합니다.',
    instructions: '1) 누워서 무릎을 구부리고 발을 바닥에 둡니다. 2) 무릎 사이에 볼을 끼웁니다. 3) 복부를 수축하여 척추를 중립으로 유지합니다. 4) 볼을 쥐어짜며 엉덩이를 들어올립니다. 5) 10초 유지 후 천천히 내려옵니다. 10회 반복합니다.',
    benefits: '내전근 활성화, 둔근 강화, O자 다리 교정, 골반 안정화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Footwork - Small V Position': {
    ko: '풋워크 - 스몰 V 포지션',
    description: '리포머를 사용한 내측광근 강화 운동입니다. 발을 작은 V자 형태로 두고 다리를 밀면서 내측 근육을 활성화합니다.',
    instructions: '1) 리포머에 누워 발을 작은 V자 형태로 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 밀면서 내측광근을 활성화합니다. 4) 천천히 돌아오며 10회 반복합니다.',
    benefits: '내측광근 강화, 내전근 활성화, O자 다리 교정, 무릎 정렬 개선',
    precautions: '무릎 통증이 있으면 즉시 중단하고, 요통이 있으면 범위를 줄입니다.'
  },
  'Standing Leg Press - Adduction': {
    ko: '스탠딩 레그 프레스 - 내전',
    description: '캐딜락을 사용한 내전근 강화 운동입니다. 서서 다리를 안쪽으로 당기면서 내전근을 활성화합니다.',
    instructions: '1) 캐딜락 옆에 서서 한쪽 다리를 스프링에 연결합니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 안쪽으로 당기며 내전근을 활성화합니다. 4) 천천히 돌아오며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '내전근 강화, 내측 근육 활성화, O자 다리 교정, 골반 안정화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Seated Adduction': {
    ko: '시티드 내전',
    description: '필라테스 체어를 사용한 내측 근육 조절 운동입니다. 앉아서 다리를 모으면서 내전근을 활성화합니다.',
    instructions: '1) 체어에 앉아 복부를 수축합니다. 2) 다리를 모으며 내전근을 활성화합니다. 3) 골반이 기울어지지 않도록 유지하며 10회 반복합니다.',
    benefits: '내측 근육 조절, 내전근 활성화, O자 다리 교정, 골반 안정화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Adductor Stretch on Barrel': {
    ko: '배럴 내전근 스트레치',
    description: '배럴을 사용한 내전근 가동성 향상 운동입니다. 다리를 벌리면서 내전근을 스트레칭하고 가동성을 개선합니다.',
    instructions: '1) 배럴에 등을 대고 앉아 다리를 벌립니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 내전근을 스트레칭하며 30초 유지합니다. 4) 천천히 돌아옵니다.',
    benefits: '내전근 가동성 향상, 스트레칭, O자 다리 보조 교정, 고관절 가동성 개선',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  
  // 체중 중심 전방 관련 운동
  'Scooter': {
    ko: '스쿠터',
    description: '리포머를 사용한 둔근 신전 조절 운동입니다. 한쪽 다리를 밀면서 둔근을 활성화하여 체중 중심을 후방으로 이동시킵니다.',
    instructions: '1) 리포머에 앉아 한쪽 다리를 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 밀면서 둔근을 활성화합니다. 4) 천천히 돌아오며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '둔근 신전 조절, 체중 중심 후방 이동, 골반 안정화, 하지 후방 사슬 활성화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Tower Roll Up': {
    ko: '타워 롤 업',
    description: '캐딜락 타워를 사용한 코어 활성화 운동입니다. 상체를 굽히면서 복부를 활성화하여 체중 중심을 조절합니다.',
    instructions: '1) 캐딜락 타워 앞에 앉아 복부를 수축합니다. 2) 척추를 하나씩 굽히면서 상체를 앞으로 숙입니다. 3) 복부가 튀어나오지 않도록 유지하며 천천히 돌아옵니다. 4) 10회 반복합니다.',
    benefits: '코어 활성화, 복부 강화, 체중 중심 조절, 척추 안정성 향상',
    precautions: '요통이 있으면 범위를 줄이고, 복부가 튀어나오면 즉시 중단합니다.'
  },
  'Standing Leg Press': {
    ko: '스탠딩 레그 프레스',
    description: '필라테스 체어를 사용한 후방 체중 이동 훈련입니다. 서서 다리를 밀면서 체중 중심을 후방으로 이동시킵니다.',
    instructions: '1) 체어 옆에 서서 한쪽 다리를 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 다리를 밀면서 체중을 후방으로 이동시킵니다. 4) 천천히 돌아오며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '후방 체중 이동 훈련, 둔근 활성화, 체중 중심 조절, 기능적 움직임 개선',
    precautions: '요통이 있으면 범위를 줄이고, 균형 문제가 있으면 벽을 잡습니다.'
  },
  
  // 체중 중심 후방 관련 운동
  'Standing Lunge': {
    ko: '스탠딩 런지',
    description: '서서 하는 고관절 신전/굴곡 밸런스 운동입니다. 앞다리를 밀면서 장요근을 활성화하여 체중 중심을 전방으로 이동시킵니다.',
    instructions: '1) 리포머 옆에 서서 한쪽 다리를 풋바에 둡니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 앞다리를 밀면서 장요근을 활성화합니다. 4) 천천히 돌아오며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '고관절 신전/굴곡 밸런스, 장요근 활성화, 체중 중심 전방 이동, 하지 전방 사슬 강화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  },
  'Step Up Front': {
    ko: '스텝 업 프론트',
    description: '앞으로 올라가는 하지 전방 안정화 운동입니다. 박스를 앞으로 올라가면서 장요근을 활성화합니다.',
    instructions: '1) 박스 앞에 서서 복부를 수축합니다. 2) 한쪽 다리로 박스에 올라가며 장요근을 활성화합니다. 3) 골반이 기울어지지 않도록 유지하며 10회 반복합니다. 4) 반대편 다리로 교대합니다.',
    benefits: '하지 전방 안정화, 장요근 활성화, 체중 중심 전방 이동, 기능적 움직임 개선',
    precautions: '무릎 통증이 있으면 즉시 중단하고, 균형 문제가 있으면 벽을 잡습니다.'
  },
  'Lunge on Barrel': {
    ko: '배럴 런지',
    description: '배럴을 사용한 고관절 전방이동 훈련입니다. 한쪽 다리를 앞으로 내밀면서 장요근을 활성화합니다.',
    instructions: '1) 배럴 앞에 서서 한쪽 다리를 배럴에 올립니다. 2) 복부를 수축하여 척추를 중립으로 유지합니다. 3) 앞다리를 밀면서 장요근을 활성화합니다. 4) 천천히 돌아오며 10회 반복합니다. 5) 반대편 다리로 교대합니다.',
    benefits: '고관절 전방이동 훈련, 장요근 활성화, 체중 중심 전방 이동, 하지 전방 사슬 강화',
    precautions: '요통이 있으면 범위를 줄이고, 무릎 통증이 있으면 즉시 중단합니다.'
  }
};

// 하위 호환성을 위한 기존 pilatesData 유지
const pilatesData = {
  '목 신전근 긴장': {
    매트: ['Roll-Up', 'Spine Stretch Forward'],
    리포머: ['Neck Stretch on Box'],
    캐딜락: ['Tower - Arm Springs'],
    체어: ['Tricep Dips'],
    바렐: ['Chest Stretch']
  },
  '상부승모근 과긴장': {
    매트: ['Arm Circles', 'Swimming Prep'],
    리포머: ['Rowing - From Chest'],
    캐딜락: ['Arm Springs - Chest Expansion'],
    체어: ['Tricep Press'],
    바렐: ['Side Stretch Over']
  },
  '전방어깨자세': {
    매트: ['Swan Dive', 'T-Raise'],
    리포머: ['Backstroke', 'Pulling Straps'],
    캐딜락: ['Push Through Bar'],
    체어: ['Push Down - Front'],
    바렐: ['Chest Expansion']
  },
  '어깨안정근 약화': {
    매트: ['Plank to Pike', 'Side Plank'],
    리포머: ['Long Stretch Series'],
    캐딜락: ['Arm Springs - Bug'],
    체어: ['Mountain Climber'],
    바렐: ['Side Arm Work']
  },
  '회전근개 불균형': {
    매트: ['Side Lying Arm Series'],
    리포머: ['Arm Work - Salute'],
    캐딜락: ['Tower - Rotation'],
    체어: ['Seated Rotation'],
    바렐: ['Spiral Stretch']
  },
  '복직근 약화': {
    매트: ['The Hundred', 'Teaser'],
    리포머: ['Stomach Series - Hundred'],
    캐딜락: ['Roll Down Bar'],
    체어: ['Teaser Prep'],
    바렐: ['Sit Up Series']
  },
  '복사근 불균형': {
    매트: ['Criss Cross', 'Saw'],
    리포머: ['Short Box - Twist'],
    캐딜락: ['Twist & Reach'],
    체어: ['Side Bend'],
    바렐: ['Twist on Barrel']
  },
  '깊은코어 약화': {
    매트: ['Dead Bug', 'Modified Hundred'],
    리포머: ['Footwork - Parallel'],
    캐딜락: ['Breathing with Springs'],
    체어: ['Seated Balance'],
    바렐: ['Core Integration']
  },
  '흉추 과후만': {
    매트: ['Swan', 'Extension Series'],
    리포머: ['Short Box - Arch'],
    캐딜락: ['Monkey Stretch'],
    체어: ['Back Extension'],
    바렐: ['Chest Opening']
  },
  '요추 과전만': {
    매트: ['Pelvic Curl', 'Imprint & Release'],
    리포머: ['Pelvic Press', 'Knee Stretches'],
    캐딜락: ['Tower - Hip Work'],
    체어: ['Hip Flexor Stretch'],
    바렐: ['Hip Opening']
  },
  '척추기립근 약화': {
    매트: ['Swimming', 'Rocking'],
    리포머: ['Long Back Stretch'],
    캐딜락: ['Back Extension Springs'],
    체어: ['Swan on Chair'],
    바렐: ['Round Back']
  },
  '고관절 굴곡근 단축': {
    매트: ['Hip Flexor Stretch', 'Lunge'],
    리포머: ['Lunge Series', 'Runner Stretch'],
    캐딜락: ['Tower - Hip Stretch'],
    체어: ['Standing Lunge'],
    바렐: ['Hip Flexor Series']
  },
  '둔근 약화': {
    매트: ['Bridge Series', 'Clam'],
    리포머: ['Footwork - Relevé', 'Leg Press'],
    캐딜락: ['Leg Springs - Circles'],
    체어: ['Glute Press Back'],
    바렐: ['Hip Extension']
  },
  '골반 불안정': {
    매트: ['Single Leg Bridge', 'Single Leg Stretch'],
    리포머: ['Single Leg Work'],
    캐딜락: ['Leg Springs - Adduction'],
    체어: ['Standing Balance'],
    바렐: ['Stability Challenge']
  },
  '대퇴사두근 약화': {
    매트: ['Wall Squat', 'Single Leg Squat'],
    리포머: ['Footwork - Heels', 'Squats'],
    캐딜락: ['Leg Press Springs'],
    체어: ['Standing Press Down'],
    바렐: ['Leg Strengthening']
  },
  '햄스트링 단축': {
    매트: ['Leg Pull Front', 'Roll Over'],
    리포머: ['Hamstring Stretch', 'Tendon Stretch'],
    캐딜락: ['Tower - Leg Stretch'],
    체어: ['Leg Pull Back'],
    바렐: ['Hip Flexor Stretch']
  },
  '종아리 근육 긴장': {
    매트: ['Calf Stretch', 'Ankle Circles'],
    리포머: ['Calf Raises', 'Tendon Stretch'],
    캐딜락: ['Foot Corrector Work'],
    체어: ['Heel Raises'],
    바렐: ['Ankle Mobility']
  }
};

// 근육 이름을 필라테스 문제로 매핑
function mapMuscleToPilatesIssue(muscleName) {
  const mapping = {
    '상부승모근': '상부승모근 과긴장',
    '견갑거근': '상부승모근 과긴장',
    'SCM': '상부승모근 과긴장',
    '흉쇄유돌근': '상부승모근 과긴장',
    '심부경부굴근': '목 굴곡근 약화',
    '전거근': '목 굴곡근 약화',
    '하부승모근': '전방어깨자세',
    '장요근': '고관절 굴곡근 단축',
    '요추기립근': '요추 과전만',
    '대퇴직근': '고관절 굴곡근 단축',
    '흉요근막': '요추 과전만',
    '복횡근': '깊은코어 약화',
    '둔근': '둔근 약화',
    '대둔근': '둔근 약화',
    '중둔근': '둔근 약화',
    '하둔근': '둔근 약화',
    '복직근': '복직근 약화',
    '대퇴사두근': '대퇴사두근 약화',
    '햄스트링': '햄스트링 단축',
    '비복근': '종아리 근육 긴장',
    '가자미근': '종아리 근육 긴장',
    '슬와근': '햄스트링 단축'
  };
  return mapping[muscleName] || null;
}

// 필라테스 동작 추천 함수
function recommendPilates(tight, weak) {
  const pilatesIssues = new Map();
  
  // 긴장된 근육에 대한 필라테스
  tight.forEach(muscle => {
    const issue = mapMuscleToPilatesIssue(muscle);
    if(issue && pilatesData[issue]) {
      if(!pilatesIssues.has(issue)) {
        pilatesIssues.set(issue, { type: '긴장', muscles: [], pilates: pilatesData[issue] });
      }
      pilatesIssues.get(issue).muscles.push(muscle);
    }
  });
  
  // 약화된 근육에 대한 필라테스
  weak.forEach(muscle => {
    const issue = mapMuscleToPilatesIssue(muscle);
    if(issue && pilatesData[issue]) {
      if(!pilatesIssues.has(issue)) {
        pilatesIssues.set(issue, { type: '약화', muscles: [], pilates: pilatesData[issue] });
      }
      pilatesIssues.get(issue).muscles.push(muscle);
    }
  });
  
  return Array.from(pilatesIssues.entries()).map(([issue, data]) => ({
    issue,
    type: data.type,
    muscles: [...new Set(data.muscles)],
    pilates: data.pilates
  }));
}
const internalAngle = (a,b,c) => {
  const ab = Math.atan2(a.y - b.y, a.x - b.x);
  const cb = Math.atan2(c.y - b.y, c.x - b.x);
  let d = Math.abs(ab - cb);
  if(d > Math.PI) d = 2 * Math.PI - d;
  return d;
};

// 모바일 터치 이벤트 헬퍼 함수
function addMobileTouchSupport(element, handler) {
  if(!element) return;
  
  // 클릭 이벤트
  element.addEventListener('click', handler, { passive: true });
  
  // 터치 이벤트 (모바일 대응)
  let touchStartTime = 0;
  let touchMoved = false;
  
  element.addEventListener('touchstart', (e) => {
    touchStartTime = Date.now();
    touchMoved = false;
  }, { passive: true });
  
  element.addEventListener('touchmove', () => {
    touchMoved = true;
  }, { passive: true });
  
  element.addEventListener('touchend', (e) => {
    // 터치가 이동했거나 너무 길면 클릭으로 간주하지 않음
    if(touchMoved || (Date.now() - touchStartTime) > 500) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    handler(e);
  }, { passive: false });
}

// Before/After 세션 전환 버튼 (DOM 로드 후 안전하게 연결)
function initSessionButtons() {
  console.log("initSessionButtons 호출됨, readyState:", document.readyState);
  const btnBefore = document.getElementById("btnBefore");
  const btnAfter = document.getElementById("btnAfter");
  const btnOrientationSide = document.getElementById("btnOrientationSide");
  const btnOrientationFront = document.getElementById("btnOrientationFront");
  
  console.log("버튼 요소:", {btnBefore, btnAfter, btnOrientationSide, btnOrientationFront});
  
  if(btnBefore) {
    addMobileTouchSupport(btnBefore, () => {
      console.log("Before 버튼 클릭됨");
      switchSession("Before");
    });
  } else {
    console.error("btnBefore를 찾을 수 없습니다");
  }
  
  if(btnAfter) {
    addMobileTouchSupport(btnAfter, () => {
      console.log("After 버튼 클릭됨");
      switchSession("After");
    });
  } else {
    console.error("btnAfter를 찾을 수 없습니다");
  }
  
  if(btnOrientationSide) {
    addMobileTouchSupport(btnOrientationSide, () => {
      console.log("옆모습 버튼 클릭됨");
      setOrientation("side", { manual: true });
    });
  } else {
    console.error("btnOrientationSide를 찾을 수 없습니다");
  }
  
  if(btnOrientationFront) {
    addMobileTouchSupport(btnOrientationFront, () => {
      console.log("정면 버튼 클릭됨");
      setOrientation("front", { manual: true });
    });
  } else {
    console.error("btnOrientationFront를 찾을 수 없습니다");
  }
  
  console.log("initSessionButtons 완료");
}

// DOM 로드 후 버튼 이벤트 초기화 (주석 처리 - 아래 두 번째 스크립트 태그에서 통합 처리)
// if(document.readyState === 'loading') {
//   console.log("DOM이 아직 로딩 중, DOMContentLoaded 이벤트 대기");
//   document.addEventListener('DOMContentLoaded', () => {
//     console.log("DOMContentLoaded 이벤트 발생");
//     initSessionButtons();
//   });
// } else {
//   console.log("DOM이 이미 로드됨, 즉시 initSessionButtons 호출");
//   initSessionButtons();
// }

// 추가 안전 장치: window.onload에서도 한 번 더 호출 (주석 처리)
// window.addEventListener('load', () => {
//   console.log("window.onload 이벤트 발생, initSessionButtons 재호출");
//   initSessionButtons();
// });

function updateCoordSelectOptions() {
  const selectEl = document.getElementById("coordSelectPoint");
  if(!selectEl) return;
  
  const orientation = sessions[cur].poseData?.orientation || "side";
  const currentKeypoints = orientation === "front" ? keypointsFront : keypointsSide;
  const currentValue = selectEl.value;
  
  // 기존 옵션 제거 (첫 번째 옵션인 "점 선택..." 제외)
  while(selectEl.options.length > 1) {
    selectEl.remove(1);
  }
  
  // 현재 orientation에 맞는 키포인트 추가
  currentKeypoints.forEach(kp => {
    const option = document.createElement('option');
    option.value = kp.key;
    option.textContent = kp.key;
    selectEl.appendChild(option);
  });
  
  // 이전에 선택된 점이 현재 키포인트 목록에 있으면 유지
  if(currentValue && currentKeypoints.some(kp => kp.key === currentValue)) {
    selectEl.value = currentValue;
  } else {
    selectEl.value = "";
    selectedPoint = null;
  }
}

function setOrientation(orientation, options = {}) {
  const sessionName = options.sessionName || cur;
  const manual = !!options.manual;
  const unlock = !!options.unlock;
  const session = sessions[sessionName];
  if(!session) return;
  
  if(!session.poseData) {
    session.poseData = { 
      orientation, 
      landmarks: null,
      orientationMode: manual ? "manual" : "auto"
    };
  } else {
    session.poseData.orientation = orientation;
    if(manual) {
      session.poseData.orientationMode = "manual";
    } else if(unlock) {
      session.poseData.orientationMode = "auto";
    } else if(!session.poseData.orientationMode) {
      session.poseData.orientationMode = "auto";
    }
  }
  
  const isCurrent = sessionName === cur;
  if(!isCurrent) {
    return;
  }
  
  const btnSide = document.getElementById("btnOrientationSide");
  const btnFront = document.getElementById("btnOrientationFront");
  if(btnSide) btnSide.classList.toggle("active", orientation === "side");
  if(btnFront) btnFront.classList.toggle("active", orientation === "front");
  
  console.log(`${sessionName} 세션의 방향을 ${orientation === "side" ? "옆모습" : "정면"}으로 설정`);
  
  // 좌표 선택 드롭다운 업데이트
  updateCoordSelectOptions();
  
  // 원본 크기 초기화 (orientation마다 다른 이미지 크기를 가질 수 있음)
  originalCanvasSize.width = 0;
  originalCanvasSize.height = 0;
  originalCanvasSize.styleWidth = 0;
  originalCanvasSize.styleHeight = 0;
  
  // orientation 변경 시 캔버스 다시 그리기
  const currentImg = orientation === "front" ? session.imgFront : session.imgSide;
  if(currentImg && currentImg.complete && currentImg.naturalWidth > 0) {
    resizeCanvasFor(currentImg);
    draw();
  } else {
    // 이미지가 없거나 로드 중이면 기본 크기로 설정하고 그리기
    resizeCanvasFor(null);
    draw();
  }
}

function switchSession(s) {
  cur = s;
  
  const btnBefore = document.getElementById("btnBefore");
  const btnAfter = document.getElementById("btnAfter");
  const currentSessionEl = document.getElementById("currentSession");
  
  if(btnBefore) btnBefore.classList.toggle("active", s === "Before");
  if(btnAfter) btnAfter.classList.toggle("active", s === "After");
  if(currentSessionEl) currentSessionEl.textContent = s;
  
  // 세션 전환 시 orientation 버튼 업데이트
  const orientation = sessions[s].poseData?.orientation || "side";
  const btnSide = document.getElementById("btnOrientationSide");
  const btnFront = document.getElementById("btnOrientationFront");
  if(btnSide) btnSide.classList.toggle("active", orientation === "side");
  if(btnFront) btnFront.classList.toggle("active", orientation === "front");
  
  // 좌표 선택 드롭다운 업데이트
  updateCoordSelectOptions();
  
  // 원본 크기 초기화 (세션마다 다른 이미지 크기를 가질 수 있음)
  originalCanvasSize.width = 0;
  originalCanvasSize.height = 0;
  originalCanvasSize.styleWidth = 0;
  originalCanvasSize.styleHeight = 0;
  
  // 세션의 이미지로 캔버스 크기 조정
  const img = orientation === "front" ? sessions[s].imgFront : sessions[s].imgSide;
  if(img && img.complete && img.naturalWidth > 0) {
    resizeCanvasFor(img);
  draw();
  } else {
    // 이미지가 없거나 로드 중이면 기본 크기로 설정하고 그리기
    resizeCanvasFor(null);
    draw();
  }
  
  // 세션 전환 시에는 기존 분석이 있으면 유지, 없으면 metrics만 계산
  if(sessions[s].analysis) {
    // 기존 분석이 있으면 전체 업데이트
    const score = sessions[s].score;
    const metrics = sessions[s].metrics;
    const analysis = sessions[s].analysis;
    updateScoreAndAnalysis(score, metrics.cva, metrics.pelvic, metrics.knee, analysis);
  } else {
    computeMetricsOnly(); // 분석이 없으면 metrics만 계산
  }
  updateCompare();
}

function resizeCanvasFor(img) {
  const canvasWrap = cv.parentElement;
  if(!canvasWrap) {
    console.error("canvasWrap를 찾을 수 없습니다");
    return;
  }
  
  const maxW = Math.max(canvasWrap.clientWidth - 24, 600);
  const maxH = Math.max(canvasWrap.clientHeight - 24, 400);
  
  // 원본 크기 계산 (처음 한 번만 또는 editMode가 아닐 때)
  let baseW, baseH;
  if(!editMode || originalCanvasSize.width === 0 || originalCanvasSize.height === 0) {
    if(img && img.naturalWidth > 0 && img.naturalHeight > 0) {
    // 컨테이너에 맞게 원본 비율 유지하며 크기 계산
    const r = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight);
    baseW = Math.round(img.naturalWidth * r);
    baseH = Math.round(img.naturalHeight * r);
      console.log("이미지 기반 캔버스 크기:", {baseW, baseH, naturalW: img.naturalWidth, naturalH: img.naturalHeight});
  } else {
      baseW = Math.min(maxW, 1200);
      baseH = Math.min(maxH, 800);
      console.log("기본 캔버스 크기:", {baseW, baseH});
  }
  
    // 원본 크기 저장
    originalCanvasSize.width = baseW;
    originalCanvasSize.height = baseH;
    originalCanvasSize.styleWidth = baseW;
    originalCanvasSize.styleHeight = baseH;
  } else {
    // 이미 저장된 원본 크기 사용 (editMode에서 확대 시)
    baseW = originalCanvasSize.width;
    baseH = originalCanvasSize.height;
  }
  
  // 확대 배율 적용 (비율 유지)
  const zoomMultiplier = editMode ? currentZoom : 1;
  const finalW = baseW * zoomMultiplier;
  const finalH = baseH * zoomMultiplier;
  
  // 캔버스 크기 설정
  cv.width = finalW * DPR;
  cv.height = finalH * DPR;
  cv.style.width = finalW + "px";
  cv.style.height = finalH + "px";
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  
  // 확대된 경우 스크롤 가능하도록 설정
  if(editMode && currentZoom > 1) {
    canvasWrap.classList.add("zoomed");
    canvasWrap.style.overflow = "auto";
    canvasWrap.style.overflowX = "auto";
    canvasWrap.style.overflowY = "auto";
  } else {
    canvasWrap.classList.remove("zoomed");
    canvasWrap.style.overflow = "auto";
    canvasWrap.style.overflowX = "hidden";
    canvasWrap.style.overflowY = "hidden";
  }
  
  // 다시 그리기
  draw();
}

function ensureDefaultPoints(session) {
  const S = sessions[session];
  // 원본 크기 기준으로 좌표 계산
  const W = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
  const H = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
  
  const orientation = S.poseData?.orientation || "side";
  const currentImg = orientation === "front" ? S.imgFront : S.imgSide;
  const currentKeypoints = orientation === "front" ? keypointsFront : keypointsSide;
  const currentPoints = orientation === "front" ? S.frontPoints : S.sidePoints;
  
  if(currentPoints.size === 0 && currentImg) {
    // Flutter 1:1 매칭 키로 기본값 설정
    const defaults = orientation === "front" ? {
      c7: {x:W*0.5, y:H*0.2},
      L_acromion: {x:W*0.3, y:H*0.3},
      R_acromion: {x:W*0.7, y:H*0.3},
      L_asis: {x:W*0.35, y:H*0.5},
      R_asis: {x:W*0.65, y:H*0.5},
      L_knee: {x:W*0.4, y:H*0.75},
      R_knee: {x:W*0.6, y:H*0.75},
      L_ankle: {x:W*0.4, y:H*0.95},
      R_ankle: {x:W*0.6, y:H*0.95},
      // Q-angle 측정용 dot (무릎 중심 근처)
      L_patella: {x:W*0.4, y:H*0.75},  // 좌측 슬개골 중심
      R_patella: {x:W*0.6, y:H*0.75},  // 우측 슬개골 중심
      L_tibial_tub: {x:W*0.4, y:H*0.78},  // 좌측 경골 결절 (슬개골 아래 약간)
      R_tibial_tub: {x:W*0.6, y:H*0.78},  // 우측 경골 결절 (슬개골 아래 약간)
    } : {
      tragus: {x:W*0.35, y:H*0.3},
      c7: {x:W*0.3, y:H*0.35},
      acromion: {x:W*0.35, y:H*0.4},
      hip: {x:W*0.38, y:H*0.6},
      knee: {x:W*0.42, y:H*0.8},
      ankle: {x:W*0.44, y:H*0.95},
      asis: {x:W*0.40, y:H*0.58},
      psis: {x:W*0.35, y:H*0.6},
    };
    for(const kp of currentKeypoints) {
      if(defaults[kp.key]) currentPoints.set(kp.key, {...defaults[kp.key]});
    }
  }
}

function getPts(session) {
  const orientation = sessions[session].poseData?.orientation || "side";
  const map = orientation === "front" ? sessions[session].frontPoints : sessions[session].sidePoints;
  const currentKeypoints = orientation === "front" ? keypointsFront : keypointsSide;
  const out = {};
  
  // 새로운 소문자 키로 저장된 값 가져오기
  for(const k of currentKeypoints) {
    out[k.key] = map.get(k.key);
  }
  
  // 기존 대문자 키 호환성 레이어 (draw, computeMetricsOnly 등에서 사용)
  if(orientation === "side") {
    out['Tragus'] = out['tragus'];
    out['C7'] = out['c7'];
    out['Shoulder'] = out['acromion'];  // 기존 Shoulder 키 지원
    out['Acromion'] = out['acromion'];
    out['Hip'] = out['hip'];
    out['Knee'] = out['knee'];
    out['Ankle'] = out['ankle'];
    out['ASIS'] = out['asis'];
    out['PSIS'] = out['psis'];
  }
  // 정면은 이미 일치하므로 추가 매핑 불필요 (c7만 처리)
  if(orientation === "front") {
    out['C7'] = out['c7'];
  }
  
  return out;
}

// 현재 orientation에 맞는 키포인트 반환
function getKeypoints() {
  const orientation = sessions[cur].poseData?.orientation || "side";
  return orientation === "front" ? keypointsFront : keypointsSide;
}

function draw() {
  // 캔버스와 컨텍스트 확인
  if(!cv || !ctx) {
    console.error("draw() 호출 시 캔버스 또는 컨텍스트가 없습니다.");
    return;
  }
  
  const S = sessions[cur];
  if(!S) {
    console.error("draw() 호출 시 세션이 없습니다.");
    return;
  }
  
  const W = cv.width / DPR, H = cv.height / DPR;
  ctx.clearRect(0, 0, cv.width, cv.height);
  ctx.fillStyle = "#0a0e13";
  ctx.fillRect(0, 0, W, H);

  // orientation에 따라 적절한 이미지 선택
  const orientation = S.poseData?.orientation || "side";
  const currentImg = orientation === "front" ? S.imgFront : S.imgSide;

  if(currentImg && currentImg.complete && currentImg.naturalWidth > 0 && currentImg.naturalHeight > 0) {
    // 원본 크기 저장 (처음 한 번만)
    if(originalCanvasSize.width === 0) {
      const maxW = cv.parentElement.clientWidth - 24;
      const maxH = cv.parentElement.clientHeight - 24;
      const r = Math.min(maxW / currentImg.naturalWidth, maxH / currentImg.naturalHeight);
      originalCanvasSize.width = Math.round(currentImg.naturalWidth * r);
      originalCanvasSize.height = Math.round(currentImg.naturalHeight * r);
      originalCanvasSize.styleWidth = originalCanvasSize.width;
      originalCanvasSize.styleHeight = originalCanvasSize.height;
    }
    // 이미지 그리기 (비율 유지하며 확대된 크기로)
    try {
    ctx.drawImage(currentImg, 0, 0, W, H);
    } catch(err) {
      console.error("이미지 그리기 실패:", err);
    }
  } else if(currentImg && !currentImg.complete) {
    // 이미지가 아직 로드 중이면 다시 시도
    currentImg.onload = () => {
      resizeCanvasFor(currentImg);
      draw();
    };
  }

  ensureDefaultPoints(cur);
  const P = getPts(cur);
  const currentKeypoints = getKeypoints();

  // 디버깅: P와 currentKeypoints 확인
  if(editMode && Object.keys(P).length === 0) {
    console.warn("⚠️ draw(): P 객체가 비어있습니다. ensureDefaultPoints가 제대로 작동하지 않았을 수 있습니다.");
  }
  if(editMode && currentKeypoints.length === 0) {
    console.warn("⚠️ draw(): currentKeypoints가 비어있습니다.");
  }

  // 확대 배율 적용
  const scaleX = editMode ? currentZoom : 1;
  const scaleY = editMode ? currentZoom : 1;

  // 보조선 그리기
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.strokeStyle = 'rgba(124,156,255,0.85)';

  if(P.C7 && P.Tragus) {
    ctx.beginPath();
    ctx.moveTo(0, P.C7.y * scaleY);
    ctx.lineTo(W, P.C7.y * scaleY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(P.C7.x * scaleX, P.C7.y * scaleY);
    ctx.lineTo(P.Tragus.x * scaleX, P.Tragus.y * scaleY);
    ctx.stroke();
  }

  if(P.Shoulder && P.Hip) {
    ctx.beginPath();
    ctx.moveTo(P.Shoulder.x * scaleX, P.Shoulder.y * scaleY);
    ctx.lineTo(P.Hip.x * scaleX, P.Hip.y * scaleY);
    ctx.stroke();
  }
  if(P.Hip && P.Knee) {
    ctx.beginPath();
    ctx.moveTo(P.Hip.x * scaleX, P.Hip.y * scaleY);
    ctx.lineTo(P.Knee.x * scaleX, P.Knee.y * scaleY);
    ctx.stroke();
  }
  if(P.Knee && P.Ankle) {
    ctx.beginPath();
    ctx.moveTo(P.Knee.x * scaleX, P.Knee.y * scaleY);
    ctx.lineTo(P.Ankle.x * scaleX, P.Ankle.y * scaleY);
    ctx.stroke();
  }

  if(P.ASIS && P.PSIS) {
    ctx.strokeStyle = 'rgba(255,184,108,0.95)';
    ctx.beginPath();
    ctx.moveTo(P.ASIS.x * scaleX, P.ASIS.y * scaleY);
    ctx.lineTo(P.PSIS.x * scaleX, P.PSIS.y * scaleY);
    ctx.stroke();
    ctx.strokeStyle = 'rgba(255,184,108,0.35)';
    const midy = (P.ASIS.y + P.PSIS.y) / 2;
    ctx.beginPath();
    ctx.moveTo(0, midy * scaleY);
    ctx.lineTo(W, midy * scaleY);
    ctx.stroke();
  }

  ctx.setLineDash([]);

  // 모든 dot들을 연결하는 점선 그리기
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.strokeStyle = 'rgba(100,100,100,0.4)';
  ctx.beginPath();
  let firstPoint = true;
  let hasPoints = false;
  for(const kp of currentKeypoints) {
    const pt = P[kp.key];
    if(!pt) continue;
    hasPoints = true;
    const x = pt.x * scaleX;
    const y = pt.y * scaleY;
    if(firstPoint) {
      ctx.moveTo(x, y);
      firstPoint = false;
    } else {
      ctx.lineTo(x, y);
    }
  }
  // 점이 하나라도 있으면 점선 그리기 (에러 방지)
  if(hasPoints) {
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // 점 그리기 (orientation에 맞는 키포인트 사용)
  // 좌표 수정 모드에서도 모든 점이 그려지도록 보장
  for(const kp of currentKeypoints) {
    const pt = P[kp.key];
    if(!pt) {
      // 좌표 수정 모드에서 점이 없으면 경고만 출력하고 계속 진행
      if(editMode) {
        console.debug(`점 ${kp.key}이(가) 없습니다.`);
      }
      continue;
    }
    const isSelected = editMode && selectedPoint === kp.key;
    try {
      drawHandle(pt.x * scaleX, pt.y * scaleY, kp.key, kp.color, isSelected);
    } catch(err) {
      console.error(`점 ${kp.key} 그리기 실패:`, err);
    }
  }
  
  // 좌표 수정 모드에서 선택된 점이 있고 아직 생성되지 않았다면 안내 표시
  if(editMode && selectedPoint && !P[selectedPoint]) {
    const W = cv.width / DPR, H = cv.height / DPR;
    ctx.fillStyle = 'rgba(124,156,255,0.7)';
    ctx.font = 'bold 16px "Noto Sans KR"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('좌표를 입력하고 "적용" 버튼을 클릭하세요', W / 2, H / 2);
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
  }
  
  // 캘리브레이션 점 표시 (캘리브레이션 모드일 때)
  if(calibrationMode && S.calibrationPoint1) {
    ctx.fillStyle = '#ffb86c';
    ctx.strokeStyle = '#ffb86c';
    ctx.lineWidth = 2;
    
    // 점 1 표시
    const p1 = S.calibrationPoint1;
    ctx.beginPath();
    ctx.arc(p1.x * scaleX, p1.y * scaleY, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // 점 2가 있으면 표시하고 선 그리기
    if(S.calibrationPoint2) {
      const p2 = S.calibrationPoint2;
      ctx.beginPath();
      ctx.arc(p2.x * scaleX, p2.y * scaleY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // 두 점 사이 선 그리기
      ctx.beginPath();
      ctx.moveTo(p1.x * scaleX, p1.y * scaleY);
      ctx.lineTo(p2.x * scaleX, p2.y * scaleY);
      ctx.stroke();
    }
  }
}

function drawHandle(x, y, label, color, isSelected = false) {
  // 선택된 점은 더 크고 강조 표시
  const radius = isSelected ? 12 : 8;
  const strokeWidth = isSelected ? 3 : 2;
  
  // 선택된 점은 외곽 링 표시
  if(isSelected) {
    ctx.fillStyle = 'rgba(124,156,255,0.3)';
    ctx.beginPath();
    ctx.arc(x, y, radius + 4, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // 점을 더 크게 그리고 드래그 영역을 넓게
  ctx.fillStyle = color;
  ctx.strokeStyle = isSelected ? 'rgba(124,156,255,1)' : 'rgba(0,0,0,0.8)';
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.lineWidth = strokeWidth;
  ctx.stroke();
  ctx.font = '12px "Noto Sans KR"';
  const pad = 4;
  const tw = ctx.measureText(label).width;
  const th = 16;
  ctx.fillStyle = isSelected ? 'rgba(124,156,255,0.8)' : 'rgba(0,0,0,0.6)';
  ctx.fillRect(x + 10, y - 12, tw + pad * 2, th);
  ctx.fillStyle = '#e7eef7';
  ctx.fillText(label, x + 10 + pad, y + 1);
}

// 각도와 점수만 계산 (실시간 표시용, AI 분석 없음)
function computeMetricsOnly() {
  const S = sessions[cur];
  const P = getPts(cur);
  let cva = null, pelvic = null, knee = null;

  if(P.C7 && P.Tragus) {
    // CVA: C7 수평면 기준 각도 (0도 = C7 수평면)
    const cv_theta = angleFromHorizontalDeg(P.C7, P.Tragus);
    const cv_acute = normalizeToAcuteDeg(cv_theta);
    cva = Math.abs(cv_acute); // C7 수평면 기준 각도
  }
  if(P.ASIS && P.PSIS) {
    // TRUNK 각도: 수평선과 ASIS-PSIS 선 사이의 각도
    // ASIS에서 PSIS로 가는 벡터의 각도를 계산
    const dx = P.PSIS.x - P.ASIS.x;
    const dy = P.PSIS.y - P.ASIS.y;
    const angle = Math.atan2(dy, dx);
    let pelvicDeg = rad2deg(angle);
    
    // 수평선 기준으로 각도 정규화 (-90~90도 범위)
    // -176.4도는 180 + (-176.4) = 3.6도로 변환되어야 함
    // 각도를 -180~180 범위에서 -90~90 범위로 변환
    if(pelvicDeg < -90) {
      // -176.4도 같은 경우: 180 + (-176.4) = 3.6도
      pelvicDeg = 180 + pelvicDeg;
    } else if(pelvicDeg > 90) {
      // 176.4도 같은 경우: 176.4 - 180 = -3.6도
      pelvicDeg = pelvicDeg - 180;
    }
    
    pelvic = pelvicDeg;
  }
  if(P.Hip && P.Knee && P.Ankle) {
    knee = rad2deg(internalAngle(P.Hip, P.Knee, P.Ankle));
  }

  S.metrics = { cva, pelvic, knee };
  const score = computeScore(cva, pelvic, knee);
  S.score = score;
  
  // AI 분석은 하지 않음 (저장 버튼 클릭 시에만)
  
  updateDisplay();
  updateCompare();
  // 점수만 업데이트 (AI 분석 없음)
  const scoreEl = document.getElementById("totalScore");
  const reasonEl = document.getElementById("scoreReason");
  if(scoreEl && score) {
    scoreEl.textContent = score.score;
    if(score >= 85) {
      scoreEl.style.color = "#2ec4b6";
    } else if(score >= 70) {
      scoreEl.style.color = "#ffd166";
    } else {
      scoreEl.style.color = "#ff6b6b";
    }
  }
  if(reasonEl && score) {
    if(score.reasons && score.reasons.length > 0) {
      reasonEl.textContent = "감점 근거: " + score.reasons.join(", ");
    } else {
      reasonEl.textContent = "모든 측정값이 정상 범위 내에 있습니다.";
    }
  }
}

// 전체 계산 (AI 분석 포함) - 저장 버튼 클릭 시에만 호출
function computeAll() {
  const S = sessions[cur];
  const pxPerCm = S.pxPerCm || 50.0;
  
  // 측면 및 정면 키포인트를 Map 형태로 변환
  const sidePoints = {};
  const frontPoints = {};
  
  // 측면 키포인트
  for(const [key, value] of S.sidePoints.entries()) {
    if(value && value.x != null && value.y != null) {
      sidePoints[key] = { x: value.x, y: value.y };
    }
  }
  
  // 정면 키포인트
  for(const [key, value] of S.frontPoints.entries()) {
    if(value && value.x != null && value.y != null) {
      frontPoints[key] = { x: value.x, y: value.y };
    }
  }
  
  // 통합 분석 실행 (운동 추천 포함)
  const analysisResult = analyzePostureAutoWithRecommendation({
    sidePts: Object.keys(sidePoints).length > 0 ? sidePoints : null,
    frontPts: Object.keys(frontPoints).length > 0 ? frontPoints : null,
    pxPerCm: pxPerCm
  });
  
  // 통합 분석 결과 저장
  S.analysisResult = analysisResult;
  
  // 기존 호환성을 위한 처리
  const sideMetrics = analysisResult.side;
  const frontMetrics = analysisResult.front;
  
  // 측면 및 정면 분석 결과를 통합하여 fullMetrics에 저장
  const mergedMetrics = {};
  
  // 측면 분석 결과 통합
  if(sideMetrics.status !== "not_available") {
    Object.assign(mergedMetrics, sideMetrics);
  }
  
  // 정면 분석 결과 통합 (측면 결과와 병합)
  if(frontMetrics.status !== "not_available") {
    Object.assign(mergedMetrics, frontMetrics);
  }
  
  // 측면 분석 결과가 있으면 기존 방식으로도 저장
  if(sideMetrics.status !== "not_available") {
    const cva = sideMetrics.CVA?.value_deg || null;
    const pelvic = sideMetrics.PTA?.value_deg || null;
    const knee = sideMetrics.KA?.value_deg || null;
    
    S.metrics = { 
      cva, 
      pelvic, 
      knee,
      fullMetrics: mergedMetrics,  // 측면 + 정면 통합 결과
      orientation: "side",
      frontMetrics: frontMetrics.status !== "not_available" ? frontMetrics : null  // 정면 분석 결과 별도 저장
    };
    
    window.fullMetrics = mergedMetrics;
    
    const score = computeScore(cva, pelvic, knee);
    S.score = score;
    
    // AI 분석 실행 (통합된 fullMetrics 사용) - 데이터베이스 기반
    analyzeMusclesWithDB(mergedMetrics).then(analysis => {
      S.analysis = analysis;
      updateDisplay();
      updateCompare();
      updateScoreAndAnalysis(score, cva, pelvic, knee, analysis);
    }).catch(err => {
      console.warn('DB 기반 분석 실패, 기존 방식 사용:', err);
      const analysis = analyzeMuscles(cva, pelvic, knee, mergedMetrics);
      S.analysis = analysis;
      updateDisplay();
      updateCompare();
      updateScoreAndAnalysis(score, cva, pelvic, knee, analysis);
    });
    
    // 골반 분석 자동 실행
    analyzePelvicTiltAuto();
    
  } else if(frontMetrics.status !== "not_available") {
    // 정면 분석만 있는 경우
    S.metrics = { 
      fullMetrics: mergedMetrics,  // 정면 분석 결과
      orientation: "front",
      frontMetrics: frontMetrics
    };
    window.fullMetrics = mergedMetrics;
    S.score = null;
    S.analysis = { 
      fullMetrics: mergedMetrics,
      orientation: "front",
      comments: [],
      details: [],
      exercises: []
    };
    updateDisplay();
    updateCompare();
    displayFrontAnalysis(frontMetrics);
    // 전체 항목 표시를 위해 updateScoreAndAnalysis 호출
    updateScoreAndAnalysis(null, null, null, null, S.analysis);
    
    // 골반 분석 자동 실행 (정면 분석만 있는 경우에도 시도)
    analyzePelvicTiltAuto();
  } else {
    // 분석 결과가 없는 경우
    S.metrics = {};
    S.score = null;
    S.analysis = null;
    updateDisplay();
    updateCompare();
    // 빈 데이터로 UI 초기화
    updateScoreAndAnalysis(null, null, null, null, null);
    
    // 골반 분석 영역 숨기기
    const pelvicDescEl = document.getElementById("pelvicDesc");
    if (pelvicDescEl) {
      pelvicDescEl.style.display = "none";
    }
  }
}

// 정면 분석 결과 표시
function displayFrontAnalysis(fullMetrics) {
  const commentEl = document.getElementById("aiComment");
  const commentPanel = document.getElementById("aiCommentPanel");
  
  if(!fullMetrics || Object.keys(fullMetrics).length === 0) {
    commentPanel.style.display = "none";
    return;
  }
  
  let commentText = "📷 정면 자세 분석 결과:\n\n";
  const details = [];
  
  for(const [key, value] of Object.entries(fullMetrics)) {
    if(value && value.value_deg != null) {
      const statusText = {
        "normal": "✅ 정상",
        "mild": "⚠️ 경미",
        "moderate": "⚠️ 중등도",
        "severe": "🔴 심각"
      }[value.status] || value.status;
      
      commentText += `${key}: ${value.value_deg.toFixed(1)}° (${statusText})\n`;
      details.push(`• ${value.meaning || key}`);
    } else if(value && value.value_cm != null) {
      const statusText = {
        "normal": "✅ 정상",
        "mild": "⚠️ 경미",
        "moderate": "⚠️ 중등도",
        "severe": "🔴 심각"
      }[value.status] || value.status;
      
      commentText += `${key}: ${value.value_cm.toFixed(2)}cm (${statusText})\n`;
      details.push(`• ${value.meaning || key}`);
    }
  }
  
  if(details.length > 0) {
    commentText += "\n" + details.join("\n");
  }
  
  commentEl.innerHTML = commentText.replace(/\n/g, '<br>');
  commentPanel.style.display = "block";
  
}


// 전체 분석 항목 기준으로 체형 종합 점수 계산
function computeScoreFromFullMetrics(fullMetrics) {
  if(!fullMetrics || Object.keys(fullMetrics).length === 0) {
    return { score: null, reasons: [], penalties: 0 };
  }
  
  let penalties = 0;
  let reasons = [];
  
  // 1. CVA (Craniovertebral Angle) - 정상 ≥50°
  const cva = fullMetrics.CVA?.value;
  if(cva != null) {
    if(cva < 50) {
      const delta = 50 - cva;
      const penalty = Math.min(40, delta * 1.6);
      penalties += penalty;
      reasons.push(`CVA ${cva.toFixed(1)}° (정상 ≥50°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 2. HPD (Head Protrusion Distance) - 정상 ≤2cm
  const hpd = fullMetrics.HPD?.value;
  if(hpd != null && hpd > 2) {
    const delta = hpd - 2;
    const penalty = Math.min(20, delta * 5);
    penalties += penalty;
    reasons.push(`HPD ${hpd.toFixed(1)}cm (정상 ≤2cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  
  // 4. TIA (Trunk Inclination Angle) - 정상 0-10°
  const tia = fullMetrics.TIA?.value;
  if(tia != null && tia > 10) {
    const delta = tia - 10;
    const penalty = Math.min(20, delta * 2);
    penalties += penalty;
    reasons.push(`TIA ${tia.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 5. SAA (Scapular Alignment Angle) - 정상 0-10°
  const saa = fullMetrics.SAA?.value;
  if(saa != null && saa > 10) {
    const delta = saa - 10;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`SAA ${saa.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 6. PTA (Pelvic Tilt Angle) - 정상 0-15° (부호 포함: +전방/-후방)
  const ptaSigned = fullMetrics.PTA?.value_signed; // 부호 포함 값 사용
  const pta = fullMetrics.PTA?.value; // 절댓값
  if(ptaSigned != null && pta != null) {
    // 목표는 0° (중립)
    const absPta = Math.abs(ptaSigned);
    if(absPta > 15) {
      const delta = absPta - 15;
      const penalty = Math.min(30, delta * 2);
      penalties += penalty;
      // 부호 포함 값으로 표시: 양수=전방경사, 음수=후방경사
      const sign = ptaSigned > 0 ? '+' : '';
      reasons.push(`골반 기울기 ${sign}${ptaSigned.toFixed(1)}° (목표 0°) - ${penalty.toFixed(0)}점 감점`);
    } else if(absPta > 0) {
      // 0-15도 범위 내에서도 목표 0도에서 벗어나면 감점
      const penalty = Math.min(30, absPta * 2.0);
      penalties += penalty;
      const sign = ptaSigned > 0 ? '+' : '';
      reasons.push(`골반 기울기 ${sign}${ptaSigned.toFixed(1)}° (목표 0°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 7. KA (Knee Alignment Angle) - 정상 175-185°
  const ka = fullMetrics.KA?.value;
  if(ka != null) {
    if(ka < 175) {
      const delta = 175 - ka;
      const penalty = Math.min(25, delta * 2.5);
      penalties += penalty;
      reasons.push(`KA ${ka.toFixed(1)}° (정상 175-185°) - ${penalty.toFixed(0)}점 감점`);
    } else if(ka > 185) {
      const delta = ka - 185;
      const penalty = Math.min(25, delta * 2.5);
      penalties += penalty;
      reasons.push(`KA ${ka.toFixed(1)}° (정상 175-185°, 과신전) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 8. Tibial Angle - 정상 0-10°
  const tibial = fullMetrics.Tibial_Angle?.value;
  if(tibial != null && tibial > 10) {
    const delta = tibial - 10;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`Tibial ${tibial.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 9. Q-Angle - 정상 10-20° (남성 10-15°, 여성 15-20°)
  const qAngle = fullMetrics.Q_Angle?.value;
  if(qAngle != null) {
    if(qAngle < 10) {
      const delta = 10 - qAngle;
      const penalty = Math.min(15, delta * 1.5);
      penalties += penalty;
      reasons.push(`Q-Angle ${qAngle.toFixed(1)}° (정상 10-20°) - ${penalty.toFixed(0)}점 감점`);
    } else if(qAngle > 20) {
      const delta = qAngle - 20;
      const penalty = Math.min(20, delta * 2);
      penalties += penalty;
      reasons.push(`Q-Angle ${qAngle.toFixed(1)}° (정상 10-20°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 10. Knee Deviation - 정상 0-3°
  const kneeDev = fullMetrics.Knee_Deviation?.value;
  if(kneeDev != null && kneeDev > 3) {
    const delta = kneeDev - 3;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`Knee Dev ${kneeDev.toFixed(1)}° (정상 0-3°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 11. LLD (Leg Length Discrepancy) - 정상 ≤1cm
  const lld = fullMetrics.LLD?.value;
  if(lld != null && lld > 1) {
    const delta = lld - 1;
    const penalty = Math.min(25, delta * 10);
    penalties += penalty;
    reasons.push(`LLD ${lld.toFixed(1)}cm (정상 ≤1cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 12. GSB (Global Sagittal Balance) - 정상 ≤2cm
  const gsb = fullMetrics.GSB?.value;
  if(gsb != null && gsb > 2) {
    const delta = gsb - 2;
    const penalty = Math.min(20, delta * 5);
    penalties += penalty;
    reasons.push(`GSB ${gsb.toFixed(1)}cm (정상 ≤2cm) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 15. HPA (Head–Pelvis Angle) - 정상 0-10°
  const hpa = fullMetrics.HPA?.value;
  if(hpa != null && hpa > 10) {
    const delta = hpa - 10;
    const penalty = Math.min(15, delta * 1.5);
    penalties += penalty;
    reasons.push(`HPA ${hpa.toFixed(1)}° (정상 0-10°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 정면 항목 (청록색으로 표시되는 항목들)
  
  // 16. STA (Shoulder Tilt Angle) - 정상 ≤3°
  const sta = fullMetrics.STA_F?.value || fullMetrics.STA?.value;
  if(sta != null && sta > 3) {
    const delta = sta - 3;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`STA ${sta.toFixed(1)}° (정상 ≤3°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 17. POA (Pelvic Obliquity Angle) - 정상 ≤3°
  const poa = fullMetrics.POA_F?.value || fullMetrics.POA?.value;
  if(poa != null && poa > 3) {
    const delta = poa - 3;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`POA ${poa.toFixed(1)}° (정상 ≤3°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 18. LLD_F (Leg Length Discrepancy) - 정상 ≤1cm (측면 LLD와 중복될 수 있으므로 둘 중 하나만 계산)
  const lld_f = fullMetrics.LLD_F?.value;
  if(lld_f != null && lld_f > 1) {
    // 측면 LLD가 이미 계산되지 않았을 때만 계산
    if(!fullMetrics.LLD || fullMetrics.LLD.value === lld_f) {
      const delta = lld_f - 1;
      const penalty = Math.min(25, delta * 10);
      penalties += penalty;
      reasons.push(`LLD_F ${lld_f.toFixed(1)}cm (정상 ≤1cm) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // 19. TD (Trunk Deviation) - 정상 ±2°
  const td = fullMetrics.TD?.value;
  if(td != null && td > 2) {
    const delta = td - 2;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`TD ${td.toFixed(1)}° (정상 ±2°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 20. HTA (Head Tilt Angle) - 정상 ≤3°
  const hta = fullMetrics.HTA?.value;
  if(hta != null && hta > 3) {
    const delta = hta - 3;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`HTA ${hta.toFixed(1)}° (정상 ≤3°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 21. SPP (Shoulder–Pelvis Parallelism) - 정상 0-3°
  const spp = fullMetrics.SPP?.value;
  if(spp != null && spp > 3) {
    const delta = spp - 3;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`SPP ${spp.toFixed(1)}° (정상 0-3°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 22. KAS (Knee Alignment Symmetry) - 정상 ±2°
  const kas = fullMetrics.KAS?.value;
  if(kas != null && kas > 2) {
    const delta = kas - 2;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`KAS ${kas.toFixed(1)}° (정상 ±2°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 23. LLAS (Lower Limb Axis Symmetry) - 정상 ±2°
  const llas = fullMetrics.LLAS?.value;
  if(llas != null && llas > 2) {
    const delta = llas - 2;
    const penalty = Math.min(15, delta * 3);
    penalties += penalty;
    reasons.push(`LLAS ${llas.toFixed(1)}° (정상 ±2°) - ${penalty.toFixed(0)}점 감점`);
  }
  
  // 24. FBA (Foot Base Angle) - 정상 0-10°
  const fba = fullMetrics.FBA?.value;
  if(fba != null) {
    if(fba > 10) {
      const delta = fba - 10;
      const penalty = Math.min(15, delta * 1.5);
      penalties += penalty;
      reasons.push(`FBA ${fba.toFixed(1)}° (정상 0-10°, 과도한 외회전) - ${penalty.toFixed(0)}점 감점`);
    } else if(fba < 0) {
      const delta = Math.abs(fba);
      const penalty = Math.min(10, delta * 2);
      penalties += penalty;
      reasons.push(`FBA ${fba.toFixed(1)}° (정상 0-10°, 회내 경향) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  // PDS는 별도로 계산되므로 여기서는 제외
  
  const score = Math.round(clamp(100 - penalties, 0, 100));
  return { score, reasons, penalties };
}

// 기존 호환성을 위한 함수 (하위 호환)
function computeScore(cva, pelvic, knee) {
  // fullMetrics가 없으면 기존 방식 사용
  const S = sessions[cur];
  const fullMetrics = S.metrics?.fullMetrics;
  if(fullMetrics && Object.keys(fullMetrics).length > 0) {
    return computeScoreFromFullMetrics(fullMetrics);
  }
  
  // 기존 방식 (fallback)
  let penalties = 0;
  let reasons = [];
  
  if(cva != null) {
    const target = 50;
    const delta = Math.max(0, target - cva);
    const penalty = Math.min(40, delta * 1.6);
    penalties += penalty;
    if(penalty > 0) {
      reasons.push(`CVA ${cva.toFixed(1)}° (목표 ${target}°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  if(pelvic != null) {
    const abs = Math.abs(pelvic);
    const target = 0;
    const penalty = Math.min(30, abs * 2.0);
    penalties += penalty;
    if(penalty > 0) {
      reasons.push(`골반 기울기 ${pelvic.toFixed(1)}° (목표 ${target}°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  if(knee != null) {
    const target = 180;
    const delta = Math.max(0, target - knee);
    const penalty = Math.min(30, delta * 1.0);
    penalties += penalty;
    if(penalty > 0) {
      reasons.push(`무릎 각 ${knee.toFixed(1)}° (목표 ${target}°) - ${penalty.toFixed(0)}점 감점`);
    }
  }
  
  const score = Math.round(clamp(100 - penalties, 0, 100));
  return { score, reasons, penalties };
}

// 데이터베이스 기반 근육 분석 함수
async function analyzeMusclesWithDB(fullMetrics = null) {
  if (!fullMetrics) {
    return analyzeMuscles(null, null, null, null);
  }
  
  try {
    // 데이터베이스 로드
    await loadPostureDB();
    
    // fullMetrics를 평탄화하여 analyzeWithDB에 전달
    const flatMetrics = flattenFullMetrics(fullMetrics);
    if (flatMetrics.PTA == null && fullMetrics.PTA) {
      const ptaSigned = fullMetrics.PTA.value_signed;
      if (typeof ptaSigned === 'number' && !Number.isNaN(ptaSigned)) {
        flatMetrics.PTA = ptaSigned;
      } else {
        const ptaVal = extractMetricValue(fullMetrics.PTA);
        if (ptaVal != null) flatMetrics.PTA = ptaVal;
      }
    }
    if (flatMetrics.PDS == null && fullMetrics.PDS) {
      const pdsVal = extractMetricValue(fullMetrics.PDS);
      if (pdsVal != null) flatMetrics.PDS = pdsVal;
    }
    if (flatMetrics.PDS == null) {
      const sessionScore = sessions?.[cur]?.score?.score;
      if (typeof sessionScore === 'number' && !Number.isNaN(sessionScore)) {
        flatMetrics.PDS = sessionScore;
      }
    }
    if (Object.keys(flatMetrics).length === 0) {
      return analyzeMuscles(null, null, null, fullMetrics);
    }
    
    // DB 기반 분석 실행
    // ✅ index.html 내부의 analyzeWithDB 함수 사용 (muscles, topRecommendations 반환)
    const dbAnalysis = await analyzeWithDB(flatMetrics);
    
    // 기존 analyzeMuscles 형식으로 변환
    // ✅ 안전 가드: muscles 객체가 없을 경우 빈 배열 사용
    const muscles = dbAnalysis?.muscles || {};
    const tightSet = new Set();
    const weakSet = new Set();
    const comments = [];
    const details = [];
    const exercises = [];
    const patterns = [];
    
    // DB 분석 결과를 패턴으로 변환
    // ✅ 안전 가드: topRecommendations가 없을 경우 빈 배열 처리
    const recommendations = dbAnalysis?.topRecommendations || dbAnalysis?.matches || [];
    recommendations.forEach((rec, idx) => {
      // ✅ 안전 가드: rec 객체 속성 안전하게 접근
      patterns.push({
        name: rec?.name || rec?.code || '알 수 없음',
        description: `${rec?.code || ''} ${rec?.abnormal || ''}`,
        meaning: rec?.note || '',
        priority: idx < 3 ? 'high' : idx < 6 ? 'medium' : 'low'
      });
      
      // ✅ 근육 정보 추출 및 Set에 추가 (문자열을 배열로 변환)
      const recTight = rec?.tight || '';
      const recWeak = rec?.weak || '';
      
      // 문자열을 배열로 변환하여 Set에 추가
      if (recTight) {
        const tightArray = typeof recTight === 'string' 
          ? recTight.split(/[,\s]+/).filter(Boolean)
          : (Array.isArray(recTight) ? recTight : []);
        tightArray.forEach(m => tightSet.add(m.trim()));
      }
      
      if (recWeak) {
        const weakArray = typeof recWeak === 'string'
          ? recWeak.split(/[,\s]+/).filter(Boolean)
          : (Array.isArray(recWeak) ? recWeak : []);
        weakArray.forEach(m => weakSet.add(m.trim()));
      }
      
      // muscles 객체에서도 추가 (이중화 방지)
      if (muscles.tight && Array.isArray(muscles.tight)) {
        muscles.tight.forEach(m => tightSet.add(m));
      }
      if (muscles.weak && Array.isArray(muscles.weak)) {
        muscles.weak.forEach(m => weakSet.add(m));
      }
      
      // 코멘트 추가
      if (recTight || recWeak) {
        comments.push(`${rec?.name || rec?.code || '알 수 없음'}: ${rec?.abnormal || ''}`);
        const tightList = typeof recTight === 'string' ? recTight : (Array.isArray(recTight) ? recTight.join(', ') : '—');
        const weakList = typeof recWeak === 'string' ? recWeak : (Array.isArray(recWeak) ? recWeak.join(', ') : '—');
        details.push(`• 긴장 근육: ${tightList || '—'}`);
        details.push(`• 약화 근육: ${weakList || '—'}`);
      }
      
      // 필라테스 운동 추가
      // ✅ 안전 가드: rec 객체의 속성 안전하게 접근
      const pilatesExercises = [];
      if (rec?.mat) pilatesExercises.push({ equipment: '매트', name: rec.mat });
      if (rec?.reformer) pilatesExercises.push({ equipment: '리포머', name: rec.reformer });
      if (rec?.cadillac) pilatesExercises.push({ equipment: '캐딜락', name: rec.cadillac });
      if (rec?.chair) pilatesExercises.push({ equipment: '체어', name: rec.chair });
      if (rec?.barrel) pilatesExercises.push({ equipment: '바렐', name: rec.barrel });
      
      if (pilatesExercises.length > 0) {
        exercises.push({
          pattern: rec?.name || rec?.code || '알 수 없음',
          equipment: pilatesExercises
        });
      }
    });
    
    // ✅ 필라테스 운동 배열 생성 (updateScoreAndAnalysis에서 사용)
    const pilatesArray = recommendations.map((rec, idx) => {
      // ✅ pilatesExercises 객체가 있으면 우선 사용 (Pilates_Exercise_DB_1000_v2.json에서 로드된 상세 정보)
      const itemExercises = rec?.pilatesExercises || {};
      
      // 기존 문자열 필드도 확인 (하위 호환성)
      if (!itemExercises['매트'] || itemExercises['매트'].length === 0) {
        if (rec?.mat) {
          if (!itemExercises['매트']) itemExercises['매트'] = [];
          // 문자열인 경우 객체로 변환
          const matStr = typeof rec.mat === 'string' ? rec.mat : '';
          if (matStr) {
            itemExercises['매트'].push({ name: matStr, ko: matStr });
          }
        }
      }
      if (!itemExercises['리포머'] || itemExercises['리포머'].length === 0) {
        if (rec?.reformer) {
          if (!itemExercises['리포머']) itemExercises['리포머'] = [];
          const reformerStr = typeof rec.reformer === 'string' ? rec.reformer : '';
          if (reformerStr) {
            itemExercises['리포머'].push({ name: reformerStr, ko: reformerStr });
          }
        }
      }
      if (!itemExercises['캐딜락'] || itemExercises['캐딜락'].length === 0) {
        if (rec?.cadillac) {
          if (!itemExercises['캐딜락']) itemExercises['캐딜락'] = [];
          const cadillacStr = typeof rec.cadillac === 'string' ? rec.cadillac : '';
          if (cadillacStr) {
            itemExercises['캐딜락'].push({ name: cadillacStr, ko: cadillacStr });
          }
        }
      }
      if (!itemExercises['체어'] || itemExercises['체어'].length === 0) {
        if (rec?.chair) {
          if (!itemExercises['체어']) itemExercises['체어'] = [];
          const chairStr = typeof rec.chair === 'string' ? rec.chair : '';
          if (chairStr) {
            itemExercises['체어'].push({ name: chairStr, ko: chairStr });
          }
        }
      }
      if (!itemExercises['바렐'] || itemExercises['바렐'].length === 0) {
        if (rec?.barrel) {
          if (!itemExercises['바렐']) itemExercises['바렐'] = [];
          const barrelStr = typeof rec.barrel === 'string' ? rec.barrel : '';
          if (barrelStr) {
            itemExercises['바렐'].push({ name: barrelStr, ko: barrelStr });
          }
        }
      }
      
      return {
        name: rec?.name || rec?.code || `패턴 ${idx + 1}`,
        issue: rec?.abnormal || '',
        condition: `${rec?.code || ''} ${rec?.abnormal || ''}`,
        interpretation: rec?.note || '',
        tight: rec?.tight ? (typeof rec.tight === 'string' ? rec.tight.split(/[,\s]+/).filter(Boolean) : rec.tight) : [],
        weak: rec?.weak ? (typeof rec.weak === 'string' ? rec.weak.split(/[,\s]+/).filter(Boolean) : rec.weak) : [],
        muscles: rec?.tight ? (typeof rec.tight === 'string' ? rec.tight.split(/[,\s]+/).filter(Boolean) : rec.tight) : [],
        pilates: itemExercises
      };
    }).filter(item => Object.keys(item.pilates).length > 0); // 필라테스 운동이 있는 것만 필터링
    
    // ✅ 최종 근육 배열 생성 (Set에서 배열로 변환)
    const tight = Array.from(tightSet).filter(Boolean);
    const weak = Array.from(weakSet).filter(Boolean);
    
    return {
      tight: tight.length > 0 ? tight : (Array.isArray(muscles.tight) ? muscles.tight : []),
      weak: weak.length > 0 ? weak : (Array.isArray(muscles.weak) ? muscles.weak : []),
      comments: comments.length > 0 ? comments : ['데이터베이스 기반 분석 완료'],
      details: details.length > 0 ? details : [],
      exercises: exercises,
      patterns: patterns,
      pilates: pilatesArray, // ✅ 필라테스 운동 배열 추가
      fullMetrics: fullMetrics
    };
  } catch (err) {
    console.error('DB 기반 분석 실패:', err);
    // 폴백: 기존 방식 사용
    return analyzeMuscles(null, null, null, fullMetrics);
  }
}

// 기존 함수 (하위 호환성 유지)
function analyzeMuscles(cva, pelvic, knee, fullMetrics = null) {
  const tight = [];
  const weak = [];
  const comments = [];
  const details = [];
  const exercises = [];
  
  // ⚙️ 해석 요약 패턴 분석
  const patterns = [];
  
  // 패턴 1: 거북목(FHP): CVA↓, HPD↑
  if(fullMetrics) {
    const cvaVal = fullMetrics.CVA?.value_deg;
    const hpdVal = fullMetrics.HPD?.value_cm;
    
    if(cvaVal != null && cvaVal < 50 && hpdVal != null && hpdVal > 2) {
      patterns.push({
        name: "거북목(FHP)",
        description: `CVA↓(${cvaVal.toFixed(1)}°), HPD↑(${hpdVal.toFixed(1)}cm)`,
        meaning: "경추 신전, 심부 굴근 약화",
        priority: "high"
      });
      tight.push('상부승모근', '견갑거근', 'SCM', '흉쇄유돌근');
      weak.push('심부경부굴근', '전거근');
    }
    
    // 패턴 2: 라운드 숄더(RSP): acromion 전방 이동, SAA↑
    const saaVal = fullMetrics.SAA?.value_deg;
    if(saaVal != null && saaVal > 10) {
      patterns.push({
        name: "라운드 숄더(RSP)",
        description: `SAA↑(${saaVal.toFixed(1)}°)`,
        meaning: "흉근 단축, 하부승모 약화",
        priority: "high"
      });
      tight.push('흉근', '소흉근');
      weak.push('하부승모', '전거근', '중부승모');
    }
    
    // 패턴 3: 과전경사 골반: PTA↑ (>15°, 양수 값), ASIS가 PSIS보다 낮음
    const ptaVal = fullMetrics.PTA?.value_deg;
    const ptaSigned = fullMetrics.PTA?.value_signed;
    if(ptaVal != null && ptaSigned != null && ptaSigned > 15) {
      patterns.push({
        name: "과전경사 골반(Anterior Tilt)",
        description: `PTA↑(${ptaSigned.toFixed(1)}°, 양수) - ASIS가 PSIS보다 낮음`,
        meaning: "요추 전만 증가, hip flexor 단축",
        priority: "high"
      });
      tight.push('장요근', '요추기립근', '대퇴직근', '흉요근막');
      weak.push('복횡근', '둔근', '대둔근', '중둔근', '하둔근');
    }
    
    // 패턴 4: 후경사 골반: PTA↓ (음수 또는 <5°), ASIS가 PSIS보다 높음
    if(ptaVal != null && ptaSigned != null && (ptaSigned < 0 || ptaSigned < 5)) {
      patterns.push({
        name: "후경사 골반(Posterior Tilt)",
        description: `PTA↓(${ptaSigned.toFixed(1)}°, 음수 또는 작은 값) - ASIS가 PSIS보다 높음`,
        meaning: "햄스트링/복근 단축",
        priority: "medium"
      });
      tight.push('햄스트링', '복직근', '복횡근');
      weak.push('장요근', '요추기립근');
    }
    
    // 패턴 5: X자 다리(Valgus): KA↓ (<175°), Q-angle↑
    const kaVal = fullMetrics.KA?.value_deg;
    const qAngleVal = fullMetrics.Q_Angle?.value_deg;
    if(kaVal != null && kaVal < 175) {
      patterns.push({
        name: "X자 다리(Valgus)",
        description: `KA↓(${kaVal.toFixed(1)}°)${qAngleVal != null ? `, Q-angle↑(${qAngleVal.toFixed(1)}°)` : ''}`,
        meaning: "내측 무릎 부하 증가",
        priority: "high"
      });
      tight.push('대퇴내전근', '비복근');
      weak.push('대둔근', '중둔근', '대퇴외전근');
    }
    
    // 패턴 6: O자 다리(Varus): KA↑ (>180°)
    if(kaVal != null && kaVal > 180) {
      patterns.push({
        name: "O자 다리(Varus)",
        description: `KA↑(${kaVal.toFixed(1)}°)`,
        meaning: "외측 무릎 부하 증가",
        priority: "high"
      });
      tight.push('대퇴외전근', '비복근');
      weak.push('대둔근', '중둔근', '대퇴내전근');
    }
    
    // 패턴 7: 체중 중심 전방 이동: GSB↑
    const gsbVal = fullMetrics.GSB?.value_cm;
    if(gsbVal != null && gsbVal > 2) {
      patterns.push({
        name: "체중 중심 전방 이동",
        description: `GSB↑(${gsbVal.toFixed(1)}cm)`,
        meaning: "요추 전만, 종골 스트레스",
        priority: "medium"
      });
      tight.push('장요근', '요추기립근');
      weak.push('복횡근', '둔근');
    }
    
    // 패턴 8: 체중 중심 후방 이동: GSB↓
    if(gsbVal != null && gsbVal < -2) {
      patterns.push({
        name: "체중 중심 후방 이동",
        description: `GSB↓(${gsbVal.toFixed(1)}cm)`,
        meaning: "둔근 긴장, 햄스트링 단축",
        priority: "medium"
      });
      tight.push('둔근', '햄스트링');
      weak.push('대퇴사두근', '장요근');
    }
    
    // 패턴 정보를 comments에 추가
    if(patterns.length > 0) {
      comments.push(`\n📊 자세 패턴 분석:`);
      patterns.forEach((p, idx) => {
        comments.push(`${idx + 1}. ${p.name}: ${p.description} → ${p.meaning}`);
      });
    }
  }
  
  // CVA 분석 (상세)
  // CVA >= 50도는 정상 범위
  if(cva != null) {
    if(cva >= 50) {
      // 50도 이상이면 정상 범위
      if(cva <= 55) {
        comments.push(`경추 정렬 양호: CVA ${cva.toFixed(1)}° (정상 범위)`);
        details.push(`• 경추 정렬이 양호한 상태입니다.`);
        details.push(`• 현재 상태를 유지하기 위한 정기적인 스트레칭을 권장합니다.`);
      } else {
        // 55도 초과는 후방 경사 (과도한 경우)
        comments.push(`경추 후방 경사: CVA ${cva.toFixed(1)}°로 정상 범위를 초과합니다.`);
        details.push(`• 경추가 과도하게 후방으로 기울어져 있습니다.`);
        exercises.push('1. 경추 전방 굴곡 운동: 천천히 턱을 가슴 방향으로 내리기 (10회×2세트)');
      }
    } else {
      // 50도 미만은 전방두 자세
      if(cva < 45) {
        tight.push('상부승모근', '견갑거근', 'SCM', '흉쇄유돌근');
        weak.push('심부경부굴근', '하부승모근', '전거근');
        comments.push(`전방두 자세 심각: CVA ${cva.toFixed(1)}°로 정상 범위(≥50°)보다 ${(50-cva).toFixed(1)}° 낮습니다.`);
        details.push(`• 상부승모근과 견갑거근이 지속적으로 수축되어 목과 어깨 통증을 유발할 수 있습니다.`);
        details.push(`• 심부경부굴근이 약화되어 머리 무게를 지지하지 못해 전방 이동이 가속화됩니다.`);
        details.push(`• 장기적으로 경추 디스크 압력 증가 및 두통, 어깨 뻣뻣함이 발생할 수 있습니다.`);
        exercises.push('1. 턱 당기기 운동: 벽에 등을 대고 턱을 뒤로 당기며 10초 유지 (3세트)');
        exercises.push('2. 심부경부굴근 활성화: 누워서 턱을 가슴에 가깝게 당기며 머리만 살짝 들어올리기 (10회×3세트)');
        exercises.push('3. 하부승모근 강화: 팔을 30도 각도로 올리며 어깨뼈를 아래로 눌러 모으기 (15회×3세트)');
        exercises.push('4. 상부승모근 스트레칭: 머리를 옆으로 기울여 반대편 어깨 방향으로 스트레칭 (좌우 각 30초)');
      } else {
        tight.push('상부승모근', '견갑거근');
        weak.push('심부경부굴근');
        comments.push(`전방두 자세 경미: CVA ${cva.toFixed(1)}°로 정상 범위(≥50°)에 근접합니다.`);
        details.push(`• 상부승모근과 견갑거근에 약간의 긴장이 있습니다.`);
        details.push(`• 심부경부굴근 활성화가 필요합니다.`);
        exercises.push('1. 턱 당기기 운동: 벽에 등을 대고 턱을 뒤로 당기기 (10초×3세트)');
        exercises.push('2. 심부경부굴근 강화: 누워서 머리만 살짝 들어올리기 (10회×2세트)');
        exercises.push('3. 상부승모근 스트레칭: 좌우 각 30초씩 스트레칭');
      }
    }
  }
  
  // 골반 기울기 분석 (상세)
  if(pelvic != null) {
    const abs = Math.abs(pelvic);
    if(abs > 5) {
      if(pelvic > 0) {
        tight.push('장요근', '요추기립근', '대퇴직근', '흉요근막');
        weak.push('복횡근', '둔근', '대둔근', '중둔근', '하둔근');
        comments.push(`골반 전방경사 심각: ${pelvic.toFixed(1)}°로 목표 0°보다 ${pelvic.toFixed(1)}° 큽니다.`);
        details.push(`• 장요근이 단축되어 골반을 앞으로 당기고 있습니다.`);
        details.push(`• 요추 전만이 증가하여 허리 통증 위험이 높습니다.`);
        details.push(`• 복횡근과 둔근이 약화되어 골반 안정성이 떨어집니다.`);
        exercises.push('1. 장요근 스트레칭: 한쪽 무릎을 앞으로 내밀고 반대편 다리를 뒤로 뻗어 스트레칭 (좌우 각 30초×3회)');
        exercises.push('2. 둔근 강화: 누워서 엉덩이를 들어올리며 둔근 수축 (15회×3세트)');
        exercises.push('3. 복횡근 활성화: 네 발로 엎드려서 복부를 안으로 당기며 호흡 (10회×3세트)');
        exercises.push('4. 힙 브릿지: 누워서 무릎을 구부리고 엉덩이를 들어올리기 (15회×3세트)');
      } else {
        tight.push('둔근', '햄스트링', '요추신근');
        weak.push('복직근', '장요근', '대퇴사두근');
        comments.push(`골반 후방경사: ${pelvic.toFixed(1)}°로 목표 0°보다 작습니다.`);
        details.push(`• 둔근과 햄스트링이 과도하게 긴장되어 있습니다.`);
        details.push(`• 복직근과 장요근이 약화되어 골반이 뒤로 기울어집니다.`);
        exercises.push('1. 둔근 스트레칭: 앉아서 한쪽 무릎을 가슴에 당기기 (좌우 각 30초)');
        exercises.push('2. 햄스트링 스트레칭: 다리를 뻗고 앞으로 숙이기 (30초×3회)');
        exercises.push('3. 복직근 강화: 크런치 운동 (15회×3세트)');
        exercises.push('4. 장요근 강화: 무릎 당기기 운동 (10회×3세트)');
      }
    } else {
      comments.push(`골반 정렬 양호: ${pelvic.toFixed(1)}°`);
      details.push(`• 골반 정렬이 양호한 상태입니다.`);
    }
  }
  
  // 무릎 각도 분석 (상세)
  if(knee != null) {
    if(knee < 175) {
      if(knee < 165) {
        tight.push('햄스트링', '비복근', '가자미근', '슬와근');
        weak.push('대퇴사두근', '둔근', '대퇴직근');
        comments.push(`무릎 과굴곡 심각: ${knee.toFixed(1)}°로 목표 180°보다 ${(180-knee).toFixed(1)}° 낮습니다.`);
        details.push(`• 햄스트링과 비복근이 심각하게 단축되어 무릎을 구부리고 있습니다.`);
        details.push(`• 대퇴사두근이 약화되어 무릎을 펴지 못합니다.`);
        details.push(`• 장기적으로 무릎 관절 압력 증가 및 전방 십자인대 부상 위험이 있습니다.`);
        exercises.push('1. 햄스트링 스트레칭: 서서 다리를 올리고 앞으로 숙이기 (좌우 각 30초×3회)');
        exercises.push('2. 비복근 스트레칭: 벽에 손을 대고 한쪽 다리를 뒤로 내밀며 스트레칭 (좌우 각 30초)');
        exercises.push('3. 대퇴사두근 강화: 의자에 앉아 다리를 펴며 무릎 락 (10초 유지×10회)');
        exercises.push('4. 스쿼트: 천천히 앉았다 일어서기 (10회×3세트)');
      } else {
        tight.push('햄스트링', '비복근');
        weak.push('대퇴사두근');
        comments.push(`무릎 약간 굴곡: ${knee.toFixed(1)}°로 목표에 근접합니다.`);
        details.push(`• 햄스트링과 비복근에 약간의 긴장이 있습니다.`);
        details.push(`• 대퇴사두근 강화가 필요합니다.`);
        exercises.push('1. 햄스트링 스트레칭: 좌우 각 30초씩 스트레칭');
        exercises.push('2. 대퇴사두근 강화: 의자에 앉아 다리 펴기 (10회×2세트)');
        exercises.push('3. 스쿼트: 10회×2세트');
      }
    } else if(knee <= 185) {
      comments.push(`무릎 정렬 양호: ${knee.toFixed(1)}°`);
      details.push(`• 무릎 정렬이 양호한 상태입니다.`);
    } else {
      comments.push(`무릎 과신전: ${knee.toFixed(1)}°로 목표를 초과합니다.`);
      details.push(`• 무릎이 과도하게 펴져 있어 후방 십자인대 부상 위험이 있습니다.`);
      exercises.push('1. 무릎 미세 굴곡 연습: 서서 무릎을 살짝 구부리기 (10회×2세트)');
      exercises.push('2. 대퇴사두근 이완: 누워서 무릎 아래에 베개를 넣고 스트레칭');
    }
  }
  
  // 종합 운동 추천
  if(exercises.length === 0 && (tight.length > 0 || weak.length > 0)) {
    exercises.push('1. 전신 스트레칭: 매일 아침 10분간 전신 스트레칭');
    exercises.push('2. 코어 강화: 플랭크 30초 유지 (3세트)');
    exercises.push('3. 자세 교정 운동: 벽에 등을 대고 서서 몸 정렬 유지 (1분×3회)');
  }
  
  // 필라테스 추천 (패턴 기반)
  const pilates = [];
  
  if(fullMetrics) {
    // 패턴 기반 필라테스 추천 생성
    // 1. 거북목(FHP)
    const cvaVal = fullMetrics.CVA?.value_deg;
    const niaVal = fullMetrics.NIA?.value_deg;
    const hpdVal = fullMetrics.HPD?.value_cm;
    if(cvaVal != null && cvaVal < 50 && niaVal != null && niaVal > 20 && hpdVal != null && hpdVal > 2) {
      if(pilatesPatterns.FHP) {
        pilates.push({
          pattern: 'FHP',
          name: pilatesPatterns.FHP.name,
          condition: pilatesPatterns.FHP.condition,
          interpretation: pilatesPatterns.FHP.interpretation,
          tight: pilatesPatterns.FHP.tight,
          weak: pilatesPatterns.FHP.weak,
          exercises: pilatesPatterns.FHP.exercises
        });
      }
    }
    
    // 2. 라운드 숄더(RSP)
    const saaVal = fullMetrics.SAA?.value_deg;
    if(saaVal != null && saaVal > 10) {
      if(pilatesPatterns.RSP) {
        pilates.push({
          pattern: 'RSP',
          name: pilatesPatterns.RSP.name,
          condition: pilatesPatterns.RSP.condition,
          interpretation: pilatesPatterns.RSP.interpretation,
          tight: pilatesPatterns.RSP.tight,
          weak: pilatesPatterns.RSP.weak,
          exercises: pilatesPatterns.RSP.exercises
        });
      }
    }
    
    // 3. 과전경사 골반
    const ptaVal = fullMetrics.PTA?.value_deg;
    if(ptaVal != null && ptaVal > 15) {
      if(pilatesPatterns.AnteriorTilt) {
        pilates.push({
          pattern: 'AnteriorTilt',
          name: pilatesPatterns.AnteriorTilt.name,
          condition: pilatesPatterns.AnteriorTilt.condition,
          interpretation: pilatesPatterns.AnteriorTilt.interpretation,
          tight: pilatesPatterns.AnteriorTilt.tight,
          weak: pilatesPatterns.AnteriorTilt.weak,
          exercises: pilatesPatterns.AnteriorTilt.exercises
        });
      }
    }
    
    // 4. 후경사 골반
    if(ptaVal != null && ptaVal < 5) {
      if(pilatesPatterns.PosteriorTilt) {
        pilates.push({
          pattern: 'PosteriorTilt',
          name: pilatesPatterns.PosteriorTilt.name,
          condition: pilatesPatterns.PosteriorTilt.condition,
          interpretation: pilatesPatterns.PosteriorTilt.interpretation,
          tight: pilatesPatterns.PosteriorTilt.tight,
          weak: pilatesPatterns.PosteriorTilt.weak,
          exercises: pilatesPatterns.PosteriorTilt.exercises
        });
      }
    }
    
    // 5. X자 다리
    const kaVal = fullMetrics.KA?.value_deg;
    const qAngleVal = fullMetrics.Q_Angle?.value_deg;
    if(kaVal != null && kaVal < 175) {
      if(pilatesPatterns.GenuValgum) {
        pilates.push({
          pattern: 'GenuValgum',
          name: pilatesPatterns.GenuValgum.name,
          condition: pilatesPatterns.GenuValgum.condition,
          interpretation: pilatesPatterns.GenuValgum.interpretation,
          tight: pilatesPatterns.GenuValgum.tight,
          weak: pilatesPatterns.GenuValgum.weak,
          exercises: pilatesPatterns.GenuValgum.exercises
        });
      }
    }
    
    // 6. O자 다리
    if(kaVal != null && kaVal > 180) {
      if(pilatesPatterns.GenuVarum) {
        pilates.push({
          pattern: 'GenuVarum',
          name: pilatesPatterns.GenuVarum.name,
          condition: pilatesPatterns.GenuVarum.condition,
          interpretation: pilatesPatterns.GenuVarum.interpretation,
          tight: pilatesPatterns.GenuVarum.tight,
          weak: pilatesPatterns.GenuVarum.weak,
          exercises: pilatesPatterns.GenuVarum.exercises
        });
      }
    }
    
    // 7. 체중 중심 전방
    const gsbVal = fullMetrics.GSB?.value_cm;
    if(gsbVal != null && gsbVal > 2) {
      if(pilatesPatterns.ForwardCenter) {
        pilates.push({
          pattern: 'ForwardCenter',
          name: pilatesPatterns.ForwardCenter.name,
          condition: pilatesPatterns.ForwardCenter.condition,
          interpretation: pilatesPatterns.ForwardCenter.interpretation,
          tight: pilatesPatterns.ForwardCenter.tight,
          weak: pilatesPatterns.ForwardCenter.weak,
          exercises: pilatesPatterns.ForwardCenter.exercises
        });
      }
    }
    
    // 8. 체중 중심 후방
    if(gsbVal != null && gsbVal < -2) {
      if(pilatesPatterns.BackwardCenter) {
        pilates.push({
          pattern: 'BackwardCenter',
          name: pilatesPatterns.BackwardCenter.name,
          condition: pilatesPatterns.BackwardCenter.condition,
          interpretation: pilatesPatterns.BackwardCenter.interpretation,
          tight: pilatesPatterns.BackwardCenter.tight,
          weak: pilatesPatterns.BackwardCenter.weak,
          exercises: pilatesPatterns.BackwardCenter.exercises
        });
      }
    }
  }
  
  // 패턴 기반 추천이 없으면 기존 방식 사용
  if(pilates.length === 0) {
    const oldPilates = recommendPilates([...new Set(tight)], [...new Set(weak)]);
    pilates.push(...oldPilates);
  }
  
  return { 
    tight: [...new Set(tight)], 
    weak: [...new Set(weak)], 
    comments,
    details,
    exercises: [...new Set(exercises)],
    pilates
  };
}

// 체형 유형 분석 함수
function analyzePostureType(metrics) {
  if(!metrics || Object.keys(metrics).length === 0) {
    console.warn("⚠️ fullMetrics 없음 - 분석 생략");
    return "분석 데이터가 충분하지 않습니다.";
  }
  
  let analysis = [];
  let summarySection = '';
  let detailSections = [];
  let recommendations = [];
  
  // 측정값 추출
  const cva = metrics.CVA?.value;
  const hpd = metrics.HPD?.value;
  const nia = metrics.NIA?.value;
  const pta = metrics.PTA?.value;
  const tia = metrics.TIA?.value;
  const ka = metrics.KA?.value;
  const lld = metrics.LLD?.value;
  const gsb = metrics.GSB?.value;
    const hpa = metrics.HPA?.value;
  const qAngle = metrics['Q_Angle']?.value;
  const kneeDev = metrics['Knee_Deviation']?.value;
  const pds = metrics.PDS?.value;
  const pdsStatus = metrics.PDS?.status;
  
  // 문제 카운트
  let issueCount = 0;
  
  // === 1. 거북목 자세 (Forward Head Posture) ===
  if(cva != null && cva < 50) {
    issueCount++;
    const severity = cva < 40 ? '심각' : cva < 45 ? '중등도' : '경미';
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:13px;">📍 거북목 자세 (Forward Head Posture) - ${severity}</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>현재 상태:</strong> CVA ${cva.toFixed(1)}° (정상: ≥50°), HPD ${hpd != null ? hpd.toFixed(1) + 'cm' : '미측정'}<br>
          <strong>주요 원인:</strong> 장시간 스마트폰·컴퓨터 사용, 잘못된 베개 높이, 깊은 근육(Deep neck flexor) 약화<br>
          <strong>발생 증상:</strong> 
          • 목뒤 통증 및 경직 (Upper trapezius, Levator scapulae 긴장)
          • 두통 (Tension headache), 어지럼증
          • 어깨 결림 및 날개뼈 통증
          • 턱관절 장애(TMJ disorder) 유발 가능<br>
          <strong>근육 불균형:</strong>
          • 긴장된 근육: 상부 승모근, 견갑거근, 흉쇄유돌근, 후두하근
          • 약화된 근육: 심부 경추 굴곡근(Longus colli, capitis), 하부 승모근<br>
          <strong>교정 방향:</strong>
          ① 턱당김 운동(Chin tuck): 심부 경추 굴곡근 강화
          ② 흉추 신전 운동: 등 윗부분 유연성 확보
          ③ 견갑골 후인 운동: 어깨를 뒤로 당기는 근육 강화
          ④ 작업 환경 개선: 모니터 눈높이 조정, 스마트폰 사용 자세 개선<br>
          <strong>주의사항:</strong> 급격한 교정 시도는 경추 디스크에 무리를 줄 수 있으므로 점진적으로 접근해야 합니다.
        </div>
      </div>
    `);
  }
  
  // === 2. 골반 경사 문제 ===
  const ptaSigned = metrics.PTA?.value_signed;
  if(pta != null && ptaSigned != null && (ptaSigned > 15 || ptaSigned < 0)) {
    issueCount++;
    if(ptaSigned > 15) {
      const severity = ptaSigned > 25 ? '심각' : ptaSigned > 20 ? '중등도' : '경미';
      detailSections.push(`
        <div style="border-left:3px solid #ffb86c; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffb86c; font-size:13px;">📍 골반 전방 경사 (Anterior Pelvic Tilt) - ${severity}</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> PTA ${ptaSigned.toFixed(1)}° (정상: 0-15°) - ASIS가 PSIS보다 낮음<br>
            <strong>주요 원인:</strong> 장시간 앉아있는 생활, 하이힐 착용, 복부 근력 약화, 임신 후 회복 부족<br>
            <strong>발생 증상:</strong>
            • 요추 과전만(Hyperlordosis)으로 인한 만성 요통
            • 하복부 돌출 (pseudo-pregnancy appearance)
            • 엉덩이가 뒤로 튀어나온 자세
            • 고관절 굴곡근(Hip flexor) 단축으로 인한 보행 장애<br>
            <strong>근육 불균형:</strong>
            • 긴장·단축된 근육: 장요근(Iliopsoas), 대퇴직근(Rectus femoris), 척추기립근(Erector spinae)
            • 약화·신장된 근육: 복직근(Rectus abdominis), 대둔근(Gluteus maximus), 햄스트링<br>
            <strong>교정 방향:</strong>
            ① 고관절 굴곡근 스트레칭: 런지 자세에서 장요근 늘리기
            ② 코어 강화: 플랭크, 데드버그(Dead bug) 운동
            ③ 대둔근 활성화: 브릿지, 힙 쓰러스트, 클램쉘
            ④ 골반 후방 경사 연습: 벽에 등대고 골반 중립 자세 학습<br>
            <strong>복합 증후군:</strong> Lower Cross Syndrome(하부 교차 증후군)의 핵심 특징입니다.
          </div>
        </div>
      `);
    } else if(ptaSigned < 0) {
      detailSections.push(`
        <div style="border-left:3px solid #ffb86c; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffb86c; font-size:13px;">📍 골반 후방 경사 (Posterior Pelvic Tilt)</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> PTA ${ptaSigned.toFixed(1)}° (정상: 0-15°) - ASIS가 PSIS보다 높음<br>
            <strong>주요 원인:</strong> 과도한 코어 운동, 장시간 구부정한 앉은 자세, 햄스트링 과긴장<br>
            <strong>발생 증상:</strong>
            • 평평한 허리(Flat back)로 인한 충격 흡수 감소
            • 골반저근 기능 저하
            • 엉덩이 편평화, 하체 혈액순환 저하<br>
            <strong>교정 방향:</strong>
            ① 햄스트링 스트레칭
            ② 대둔근·척추기립근 강화
            ③ 골반 전방 경사 연습 (단, 과하지 않게)
          </div>
        </div>
      `);
    }
  }
  
  // === 3. 상부 교차 증후군 (Upper Cross Syndrome) 체크 ===
  const hasUpperCross = (cva != null && cva < 50);
  if(hasUpperCross) {
    issueCount++;
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px; background:rgba(255,107,107,0.05); padding:10px;">
        <strong style="color:#ff6b6b; font-size:13px;">⚠️ 상부 교차 증후군 (Upper Cross Syndrome) 의심</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>증후군 설명:</strong> 거북목과 둥근 어깨가 동시에 나타나는 현대인의 대표적 자세 불균형 패턴입니다.<br>
          <strong>전형적 특징:</strong>
          • 머리 전방 돌출 (CVA: ${cva.toFixed(1)}°)
          • 흉추 후만 증가 (등이 굽음)
          • 어깨 전방 회전<br>
          <strong>교정 우선순위:</strong>
          ① 긴장 해소: 상부 승모근, 대흉근, 흉쇄유돌근 이완
          ② 활성화: 심부 경추 굴곡근, 중·하부 승모근, 전거근
          ③ 자세 교육: 앉은 자세에서 흉추 신전 유지
        </div>
      </div>
    `);
  }
  
  // === 4. 무릎 정렬 문제 ===
  if(ka != null && (ka > 185 || ka < 175)) {
    issueCount++;
    if(ka > 185) {
      const severity = ka > 195 ? '심각' : ka > 190 ? '중등도' : '경미';
      detailSections.push(`
        <div style="border-left:3px solid #ffd166; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffd166; font-size:13px;">📍 무릎 과신전 (Genu Recurvatum) - ${severity}</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> KA ${ka.toFixed(1)}° (정상: 175-185°)<br>
            <strong>주요 원인:</strong> 관절 과이완성(Joint hypermobility), 대퇴사두근 우세, 햄스트링 약화, 잘못된 서기 습관<br>
            <strong>발생 증상:</strong>
            • 무릎 후방 인대 과부하 (PCL, 후방 관절낭 스트레스)
            • 슬개골 압박 증가로 슬개대퇴 통증 증후군 위험
            • 무릎 불안정성, 장기적으로 조기 관절염 유발<br>
            <strong>교정 방향:</strong>
            ① 햄스트링 강화: 레그컬, 루마니안 데드리프트
            ② 대퇴사두근 과긴장 완화
            ③ 서기 자세 교정: 무릎을 살짝 구부린 상태 유지 연습
            ④ 고유수용성 훈련: 한 발 서기, 밸런스 보드<br>
            <strong>주의사항:</strong> 무릎을 "딱" 펴는 습관을 즉시 중단해야 합니다.
          </div>
        </div>
      `);
    } else {
      detailSections.push(`
        <div style="border-left:3px solid #ffd166; padding-left:12px; margin-bottom:16px;">
          <strong style="color:#ffd166; font-size:13px;">📍 무릎 과굴곡 자세</strong>
          <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
            <strong>현재 상태:</strong> KA ${ka.toFixed(1)}° (정상: 175-185°)<br>
            <strong>주요 원인:</strong> 햄스트링 과긴장, 종아리 근육 단축, 골반 후방 경사 동반<br>
            <strong>교정 방향:</strong> 햄스트링·종아리 스트레칭, 대퇴사두근 강화
          </div>
        </div>
      `);
    }
  }
  
  // === 5. 다리 길이 불균형 & 측만 위험 ===
  if(lld != null && lld > 1) {
    issueCount++;
    const severity = lld > 2 ? '심각' : lld > 1.5 ? '중등도' : '경미';
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:13px;">📍 다리 길이 불균형 (Leg Length Discrepancy) - ${severity}</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>현재 상태:</strong> LLD ${lld.toFixed(1)}cm (정상: ≤1cm)<br>
          <strong>구분:</strong>
          • 구조적 불균형: 실제 뼈 길이 차이 (X-ray 촬영 필요)
          • 기능적 불균형: 근육 불균형·골반 회전으로 인한 겉보기 차이<br>
          <strong>발생 증상:</strong>
          • 골반 기울어짐 → 척추 측만증(Scoliosis) 유발
          • 보행 시 비대칭 → 무릎·고관절·허리 통증
          • 한쪽 다리 피로 누적<br>
          <strong>교정 방향:</strong>
          ① 기능적 불균형: 골반 교정 운동, 중둔근(Gluteus medius) 강화, TFL·QL 스트레칭
          ② 구조적 불균형: 깔창(Heel lift) 사용 고려, 전문의 상담 필수<br>
          <strong>연쇄 반응:</strong> LLD → 골반 기울어짐 → 척추 측만 → 어깨 높이 차이 → 목 통증
        </div>
      </div>
    `);
  }
  
  // === 6. 전신 균형 문제 ===
  if(gsb != null && gsb > 2) {
    issueCount++;
    detailSections.push(`
      <div style="border-left:3px solid #ff6b6b; padding-left:12px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:13px;">📍 전신 정렬 불균형 (Global Postural Imbalance)</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>현재 상태:</strong> GSB ${gsb.toFixed(1)}cm<br>
          <strong>의미:</strong> 주요 관절들이 수직 중력선에서 크게 벗어나 있어 전신 근골격계에 과부하가 걸린 상태입니다.<br>
          <strong>발생 증상:</strong>
          • 쉽게 피로함, 장시간 서 있거나 걷기 힘듦
          • 만성 통증의 다발성 발생 (목, 어깨, 허리, 무릎 등)
          • 에너지 소모 증가, 호흡 효율 감소<br>
          <strong>교정 방향:</strong>
          ① 전체적인 자세 재정렬 프로그램 필요 (통합적 접근)
          ② 필라테스, 요가 등 전신 균형 운동
          ③ 전문가(물리치료사, 카이로프랙터) 상담 권장
        </div>
      </div>
    `);
  }
  
  // === 종합 평가 및 요약 ===
  if(pds != null) {
    if(pdsStatus === 'normal') {
      summarySection = `<div style="background:rgba(46,196,182,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#2ec4b6; font-size:14px;">✓ 전반적으로 양호한 자세</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          대부분의 측정값이 정상 범위에 있습니다. (PDS: ${pds.toFixed(1)}점)<br>
          현재 상태를 유지하기 위해 규칙적인 스트레칭과 근력 운동을 지속하세요.
        </div>
      </div>`;
    } else if(pdsStatus === 'mild') {
      summarySection = `<div style="background:rgba(255,209,102,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#ffd166; font-size:14px;">⚠️ 경미한 자세 불균형</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          ${issueCount}개 항목에서 개선이 필요합니다. (PDS: ${pds.toFixed(1)}점)<br>
          지금부터 교정을 시작하면 단기간 내 개선이 가능한 수준입니다.
        </div>
      </div>`;
    } else if(pdsStatus === 'moderate') {
      summarySection = `<div style="background:rgba(255,184,108,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#ffb86c; font-size:14px;">⚠️ 중등도 자세 불균형</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          ${issueCount}개 항목에서 교정이 필요합니다. (PDS: ${pds.toFixed(1)}점)<br>
          체계적인 교정 운동 프로그램과 생활 습관 개선이 필요합니다.
        </div>
      </div>`;
    } else {
      summarySection = `<div style="background:rgba(255,107,107,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
        <strong style="color:#ff6b6b; font-size:14px;">🚨 심각한 자세 불균형</strong>
        <div style="margin-top:6px; font-size:11px; line-height:1.6; color:var(--muted);">
          ${issueCount}개 항목에서 정상 범위를 벗어났습니다. (PDS: ${pds.toFixed(1)}점)<br>
          <strong>전문가 상담을 강력히 권장합니다.</strong> (물리치료사, 정형외과 전문의, 카이로프랙터)<br>
          방치 시 만성 통증 및 구조적 변형이 고착될 수 있습니다.
        </div>
      </div>`;
    }
  }
  
  // === 통합 권장사항 ===
  if(issueCount > 0) {
    recommendations.push(`
      <div style="background:rgba(124,156,255,0.08); padding:12px; border-radius:8px; margin-top:16px;">
        <strong style="color:#7c9cff; font-size:13px;">💡 통합 교정 권장사항</strong>
        <div style="margin-top:8px; font-size:11px; line-height:1.7; color:var(--muted);">
          <strong>1. 일상생활 개선:</strong><br>
          • 작업 환경: 모니터 눈높이, 의자 높이, 책상 거리 조정<br>
          • 수면 자세: 경추 지지 베개, 옆으로 누워 자기<br>
          • 스마트폰: 눈높이까지 들고 보기, 사용 시간 제한<br><br>
          
          <strong>2. 운동 프로그램:</strong><br>
          • 매일: 스트레칭 10-15분 (긴장된 근육 이완)<br>
          • 주 3-4회: 근력 운동 30분 (약화된 근육 강화)<br>
          • 주 2-3회: 유산소 운동 30분 (전신 순환 개선)<br><br>
          
          <strong>3. 전문가 도움:</strong><br>
          • 물리치료: 수기 치료, 도수 치료, 운동 치료<br>
          • 필라테스/요가: 전문 강사의 1:1 교정 수업<br>
          • 정기 검진: 3-6개월마다 자세 재평가<br><br>
          
          <strong>4. 교정 순서:</strong><br>
          ① 1-2주차: 긴장된 근육 이완 (마사지, 폼롤러, 스트레칭)<br>
          ② 3-4주차: 약화된 근육 활성화 (저강도 운동)<br>
          ③ 5주차 이후: 점진적 강화 및 자세 통합 훈련
        </div>
      </div>
    `);
  }
  
  // === 최종 출력 조합 ===
  if(detailSections.length === 0) {
    return summarySection || "현재 자세는 전반적으로 양호합니다.";
  }
  
  return summarySection + detailSections.join('') + recommendations.join('');
}

function updateScoreAndAnalysis(scoreData, cva, pelvic, knee, analysis) {
  const scoreEl = document.getElementById("totalScore");
  const reasonEl = document.getElementById("scoreReason");
  const commentEl = document.getElementById("aiComment");
  const commentPanel = document.getElementById("aiCommentPanel");
  const musclePanel = document.getElementById("musclePanel");
  const tightList = document.getElementById("muscleTightList");
  const weakList = document.getElementById("muscleWeakList");
  const exercisePanel = document.getElementById("exercisePanel");
  const exerciseList = document.getElementById("exerciseList");
  const pilatesPanel = document.getElementById("pilatesPanel");
  const pilatesList = document.getElementById("pilatesList");
  const allMetricsList = document.getElementById("allMetricsList");
  const pdsValueEl = document.getElementById("pdsValue");
  const conclusionPanel = document.getElementById("conclusionPanel");
  const conclusionContent = document.getElementById("conclusionContent");
  
  // 전체 분석 항목 표시
  const S = sessions[cur];
  // ✅ 안전 가드: fullMetrics를 여러 소스에서 가져오기
  const fullMetrics = S.metrics?.fullMetrics || analysis?.fullMetrics || window.fullMetrics || {};
  if(allMetricsList && fullMetrics) {
    // 측면 항목 (파란색 #7c9cff)
    const sideMetricsOrder = [
      {key: 'CVA', name: 'CVA(두개경추각)', unit: '°', type: 'side'},
      {key: 'HPD', name: 'HPD(두부전방이동)', unit: 'cm', type: 'side'},
      {key: 'TIA', name: 'TIA(체간경사각)', unit: '°', type: 'side'},
      {key: 'SAA', name: 'SAA(어깨전방각)', unit: '°', type: 'side'},
      {key: 'PTA', name: 'PTA(골반 전후경사각)', unit: '°', type: 'side'},
      {key: 'KA', name: 'KA(무릎각)', unit: '°', type: 'side'},
      {key: 'Tibial_Angle', name: 'Tibial(경골경사각)', unit: '°', type: 'side'},
      {key: 'Knee_Deviation', name: 'Knee Dev(무릎편위)', unit: '°', type: 'side'},
      {key: 'LLD', name: 'LLD(하지길이차)', unit: 'cm', type: 'side'},
      {key: 'GSB', name: 'GSB(중력중심선)', unit: 'cm', type: 'side'},
      {key: 'HPA', name: 'HPA(고관절각)', unit: '°', type: 'side'},
      {key: 'PDS', name: 'PDS(자세점수)', unit: 'score', type: 'side'}
    ];
    
    // 정면 항목 (청록색 #2ec4b6)
    const frontMetricsOrder = [
      {key: 'STA_F', name: 'STA(어깨기울기각)', unit: '°', type: 'front'},
      {key: 'STA', name: 'STA(어깨기울기각)', unit: '°', type: 'front'}, // 하위 호환성
      {key: 'POA_F', name: 'POA(골반기울기각)', unit: '°', type: 'front'},
      {key: 'POA', name: 'POA(골반기울기각)', unit: '°', type: 'front'}, // 하위 호환성
      {key: 'LLD_F', name: 'LLD(하지길이차)', unit: 'cm', type: 'front'},
      {key: 'TD', name: 'TD(체간편위)', unit: '°', type: 'front'},
      {key: 'HTA', name: 'HTA(머리기울기각)', unit: '°', type: 'front'},
      {key: 'SPP', name: 'SPP(어깨골반평행도)', unit: '°', type: 'front'},
      {key: 'Q_Angle', name: 'Q-Angle(Q각)', unit: '°', type: 'front'},  // 정면 분석 항목으로 이동
      {key: 'KAS', name: 'KAS(무릎정렬대칭성)', unit: '°', type: 'front'},
      {key: 'LLAS', name: 'LLAS(하지축대칭성)', unit: '°', type: 'front'},
      {key: 'FBA', name: 'FBA(발정렬각)', unit: '°', type: 'front'}
    ];
    
    // 모든 항목 합치기 (측면 먼저, 정면 나중)
    const metricsOrder = [...sideMetricsOrder, ...frontMetricsOrder];
    
    let html = '';
    const processedKeys = new Set(); // 중복 방지
    
    metricsOrder.forEach(m => {
      // 이미 처리된 키는 건너뛰기
      if(processedKeys.has(m.key)) return;
      
      // STA_F와 STA 중 하나만, POA_F와 POA 중 하나만 선택
      let metricKey = m.key;
      if(m.key === 'STA' && fullMetrics['STA_F']) {
        metricKey = 'STA_F';
        if(processedKeys.has('STA_F')) return;
      }
      if(m.key === 'POA' && fullMetrics['POA_F']) {
        metricKey = 'POA_F';
        if(processedKeys.has('POA_F')) return;
      }
      
      const metric = fullMetrics[metricKey] || fullMetrics[m.key];
      if(metric) {
        processedKeys.add(metricKey);
        if(m.key !== metricKey) processedKeys.add(m.key);
        
        // PTA는 부호 포함 값(value_signed) 사용, 나머지는 기존 방식
        let value;
        if (metricKey === 'PTA' && metric.value_signed !== undefined) {
          value = metric.value_signed; // 음수 값도 그대로 표시
        } else {
          value = metric.value !== undefined ? metric.value : (metric.value_deg !== undefined ? metric.value_deg : (metric.value_cm !== undefined ? metric.value_cm : null));
        }
        const status = metric.status || 'unknown';
        const unit = metric.unit || m.unit;
        if(value !== null && value !== undefined) {
          const statusColor = status === 'normal' ? '#2ec4b6' : status === 'mild' ? '#ffd166' : status === 'moderate' ? '#ffb86c' : '#ff6b6b';
          const statusText = status === 'normal' ? '✓' : status === 'mild' ? '⚠' : status === 'moderate' ? '⚠⚠' : status === 'severe' ? '✗' : '?';
          
          // 측면 항목은 파란색, 정면 항목은 청록색으로 이름 표시
          const nameColor = m.type === 'front' ? '#2ec4b6' : '#7c9cff';
          
          // PTA 음수 값 표시 (부호 포함)
          const displayValue = (metricKey === 'PTA' && value < 0) ? value.toFixed(1) : value.toFixed(1);
          const sign = (metricKey === 'PTA' && value < 0) ? '' : '';
          
          html += `<div style="display:flex; justify-content:space-between; margin-bottom:3px; padding:2px 0;">
            <span style="color:${nameColor}; font-weight:${m.type === 'front' ? '600' : '400'};">${m.name}:</span>
            <span style="color:${statusColor};">${displayValue}${unit} ${statusText}</span>
          </div>`;
        }
      }
    });
    allMetricsList.innerHTML = html || '<div style="color:var(--muted);">분석 데이터 없음</div>';
    
    // PDS 표시
    if(fullMetrics.PDS && pdsValueEl) {
      const pds = fullMetrics.PDS.value;
      const pdsStatus = fullMetrics.PDS.status;
      const pdsColor = pdsStatus === 'normal' ? '#2ec4b6' : pdsStatus === 'mild' ? '#ffd166' : '#ff6b6b';
      pdsValueEl.textContent = `${pds.toFixed(1)} (${pdsStatus})`;
      pdsValueEl.style.color = pdsColor;
    } else if(pdsValueEl) {
      pdsValueEl.textContent = '—';
    }
  }
  
  // 전체 분석 항목 기준으로 점수 재계산 (fullMetrics가 있으면)
  if(fullMetrics && Object.keys(fullMetrics).length > 0) {
    const scoreResult = computeScoreFromFullMetrics(fullMetrics);
    if(scoreResult.score != null) {
      scoreData = scoreResult;
    }
  }
  
  if(scoreData && scoreData.score != null) {
    const score = scoreData.score;
    scoreEl.textContent = score;
    
    // 점수 색상
    if(score >= 85) {
      scoreEl.style.color = "#2ec4b6";
    } else if(score >= 70) {
      scoreEl.style.color = "#ffd166";
    } else {
      scoreEl.style.color = "#ff6b6b";
    }
    
    // 점수 근거
    if(scoreData.reasons && Array.isArray(scoreData.reasons) && scoreData.reasons.length > 0) {
      reasonEl.textContent = "감점 근거: " + scoreData.reasons.join(", ");
    } else {
      reasonEl.textContent = "모든 측정값이 정상 범위 내에 있습니다.";
    }
  } else {
    scoreEl.textContent = "—";
    reasonEl.textContent = "";
  }
  
  // AI 코멘트 (더 상세하게)
  if(analysis && analysis.comments && Array.isArray(analysis.comments) && analysis.comments.length > 0) {
    let commentText = analysis.comments.join(" ");
    if(analysis.details && Array.isArray(analysis.details) && analysis.details.length > 0) {
      commentText += "\n\n" + analysis.details.join("\n");
    }
    commentEl.innerHTML = commentText.replace(/\n/g, '<br>');
    commentPanel.style.display = "block";
    
    // 체형 유형 분석 추가
    const postureTypeContent = document.getElementById("postureTypeContent");
    if(postureTypeContent) {
      // fullMetrics가 없으면 세션에서 가져오기
      const metricsForAnalysis = fullMetrics || S.metrics?.fullMetrics || analysis?.fullMetrics || window.fullMetrics || {};
      if(metricsForAnalysis && Object.keys(metricsForAnalysis).length > 0) {
        let postureType = analyzePostureType(metricsForAnalysis);
        postureTypeContent.innerHTML = postureType;
      } else {
        console.warn("⚠️ fullMetrics 없음 - 체형 유형 분석 생략");
        postureTypeContent.innerHTML = "분석 데이터가 충분하지 않습니다.";
      }
    }
  } else {
    commentPanel.style.display = "none";
  }
  
  // 근육 분석 (상세)
  const hasTight = analysis?.tight && Array.isArray(analysis.tight) && analysis.tight.length > 0;
  const hasWeak = analysis?.weak && Array.isArray(analysis.weak) && analysis.weak.length > 0;
  
  if(analysis && (hasTight || hasWeak)) {
    if(hasTight) {
      tightList.innerHTML = analysis.tight.join(", ").replace(/,/g, ', ');
    } else {
      tightList.textContent = "없음";
      tightList.style.color = "var(--muted)";
    }
    
    if(hasWeak) {
      weakList.innerHTML = analysis.weak.join(", ").replace(/,/g, ', ');
    } else {
      weakList.textContent = "없음";
      weakList.style.color = "var(--muted)";
    }
    
    musclePanel.style.display = "block";
  } else {
    musclePanel.style.display = "none";
  }
  
  // 운동 추천
  if(analysis && analysis.exercises && Array.isArray(analysis.exercises) && analysis.exercises.length > 0) {
    exerciseList.innerHTML = analysis.exercises.map(ex => `<div style="margin-bottom:6px;">${ex}</div>`).join("");
    exercisePanel.style.display = "block";
  } else {
    exercisePanel.style.display = "none";
  }
  
  // 필라테스 추천 (패턴 기반)
  if(analysis && analysis.pilates && Array.isArray(analysis.pilates) && analysis.pilates.length > 0) {
    const pilatesHTML = analysis.pilates.map((item, idx) => renderPilatesItemCard(item, { context:'dark', index: idx, limitPerTool: 2 })).join('');
    pilatesList.innerHTML = pilatesHTML;
    pilatesPanel.style.display = "block";
  } else {
    pilatesPanel.style.display = "none";
  }
  
  // 결론 및 향후 권장사항 생성 (회원 이름 포함, 임상 중심)
  if(conclusionPanel && conclusionContent && (analysis || scoreData)) {
    // 회원 이름 가져오기 (세션에서 또는 전역 변수에서)
    const memberName = S.memberName || window.memberName || '회원';
    
    let conclusionText = '';
    
    // 패턴 요약
    const patterns = [];
    if(analysis && analysis.pilates && analysis.pilates.length > 0) {
      analysis.pilates.forEach(item => {
        if(item.name || item.issue) {
          patterns.push(item.name || item.issue);
        }
      });
    }
    
    // 근육 불균형 요약
    const tightMuscles = analysis && analysis.tight ? analysis.tight : [];
    const weakMuscles = analysis && analysis.weak ? analysis.weak : [];
    
    // 결론 작성
    conclusionText += `${memberName}님의 검사 결과와 AI 분석을 종합해보면, 관찰된 주요 패턴은 다음과 같습니다:\n\n`;
    
    if(patterns.length > 0) {
      patterns.forEach((pattern, idx) => {
        conclusionText += `${idx + 1}. ${pattern}\n`;
      });
      conclusionText += '\n';
    } else {
      conclusionText += '특이 패턴 없음\n\n';
    }
    
    conclusionText += `위 패턴은 특정 근육군의 긴장(짧아짐)과 약화(약해짐)이 동반되는 전형적인 임상 소견입니다. 아래의 권장사항을 일관되게 6~12주 동안 적용하면 증상 완화와 자세 개선이 기대됩니다.\n\n`;
    
    // 단기 권장사항
    conclusionText += `【단기(1~4주)】\n`;
    conclusionText += `1. 긴장 근육 이완 중심(폼롤러, 근막 이완, 정적 스트레칭) — 하루 1회 10~15분\n`;
    conclusionText += `2. 호흡 조절과 함께하는 코어 기본운동 (Dead Bug, Pelvic Tilt) — 매일 5~10분\n`;
    conclusionText += `3. 일상 생활에서의 자세 리셋(30~40분마다) — 습관화\n\n`;
    
    // 중기 권장사항
    conclusionText += `【중기(4~8주)】\n`;
    conclusionText += `1. 약화 근육 활성화 (둔근, 복횡근 등) — 주 3회, 점진적 부하\n`;
    conclusionText += `2. 필라테스 기구 운동을 포함한 통합 프로그램 — 주 2~3회\n`;
    conclusionText += `3. 정기 재평가로 프로그램 조정 (3~4주마다)\n\n`;
    
    // 장기 권장사항
    conclusionText += `【장기(8~12주 이상)】\n`;
    conclusionText += `통합적 기능 회복을 목표로 일상화 및 운동강도 증진을 권장합니다. 근력, 유연성, 신경근 제어가 모두 개선되면 자세 개선 효과는 장기적으로 유지됩니다.\n\n`;
    
    // 점수 기반 추가 권장사항
    if(scoreData && scoreData.score != null) {
      const score = scoreData.score;
      if(score < 70) {
        conclusionText += `현재 체형 종합 점수가 ${score}점으로 개선이 필요합니다. 위의 단기 권장사항부터 꾸준히 실시하시기 바랍니다.\n\n`;
      } else if(score < 85) {
        conclusionText += `현재 체형 종합 점수가 ${score}점으로 양호한 편입니다. 중기 권장사항을 중심으로 지속적인 관리가 필요합니다.\n\n`;
      } else {
        conclusionText += `현재 체형 종합 점수가 ${score}점으로 우수합니다. 장기 권장사항을 통해 현재 상태를 유지하고 더욱 개선하시기 바랍니다.\n\n`;
      }
    }
    
    conclusionText += `"우리는 걱정 대신 근거(데이터)로 움직입니다."`;
    
    conclusionContent.textContent = conclusionText;
    conclusionPanel.style.display = "block";
  } else if(conclusionPanel) {
    conclusionPanel.style.display = "none";
  }
}

// 필라테스 운동 상세 설명 모달 표시 함수
function showExerciseModal(exerciseEn = '', exerciseKo = '', purpose = '') {
  const modal = document.getElementById("pilatesExerciseModal");
  const modalTitle = document.getElementById("modalExerciseTitle");
  const modalContent = document.getElementById("modalExerciseContent");
  const closeBtn = document.getElementById("closeModalBtn");
  if(!modal || !modalTitle || !modalContent) return;
  
  const detail = getPilatesExerciseDetail(exerciseEn, exerciseKo);
  const manualDesc = pilatesExerciseDescriptions[exerciseEn] || pilatesExerciseDescriptions[exerciseKo];
  const finalEn = detail?.exercise_en || exerciseEn || manualDesc?.ko || 'Pilates Exercise';
  const finalKo = detail?.exercise_ko || exerciseKo || manualDesc?.ko || '';
  modalTitle.textContent = finalKo ? `${finalEn} (${finalKo})` : finalEn;
  
  let contentHTML = '';
  let hasContent = false;
  
  if(detail) {
    hasContent = true;
    const infoBadges = [];
    if(detail.posture_ko || detail.posture_key) {
      infoBadges.push(`자세: ${detail.posture_ko || detail.posture_key}`);
    }
    if(detail.equipment_ko || detail.equipment_en) {
      infoBadges.push(`장비: ${detail.equipment_ko || detail.equipment_en}`);
    }
    if(detail.sets_reps) {
      infoBadges.push(`세트/반복: ${detail.sets_reps}`);
    }
    if(infoBadges.length) {
      contentHTML += `<div style="margin-bottom:15px; display:flex; flex-wrap:wrap; gap:6px;">${infoBadges.map(badge => `<span style="font-size:11px; background:#eef2ff; color:#4c1d95; padding:4px 8px; border-radius:999px;">${badge}</span>`).join('')}</div>`;
    }
    
    const finalPurpose = detail.purpose || purpose || '자세 교정 및 기능 회복';
    contentHTML += `<div style="margin-bottom:20px;">
      <h4 style="color:#2ec4b6; font-size:15px; margin-bottom:10px; border-bottom:2px solid #2ec4b6; padding-bottom:5px;">운동 목적</h4>
      <p style="margin-bottom:15px; line-height:1.8;">${formatMultilineText(finalPurpose) || '높은 안정성과 가동성을 동시에 확보하기 위한 루틴입니다.'}</p>
    </div>`;
    
    if(detail.how_to_do) {
      contentHTML += `<div style="margin-bottom:20px;">
        <h4 style="color:#2ec4b6; font-size:15px; margin-bottom:10px; border-bottom:2px solid #2ec4b6; padding-bottom:5px;">운동 설명</h4>
        <div style="margin-bottom:15px; line-height:1.8; white-space:pre-wrap;">${formatMultilineText(detail.how_to_do)}</div>
      </div>`;
    }
    
    if(detail.key_cues || detail.sets_reps) {
      contentHTML += `<div style="margin-bottom:20px;">
        <h4 style="color:#2ec4b6; font-size:15px; margin-bottom:10px; border-bottom:2px solid #2ec4b6; padding-bottom:5px;">핵심 큐 & 진행</h4>
        ${detail.key_cues ? `<p style="margin-bottom:10px; line-height:1.8;">${formatMultilineText(detail.key_cues)}</p>` : ''}
        ${detail.sets_reps ? `<p style="margin-bottom:8px; line-height:1.6; color:#555;">권장 세트: ${detail.sets_reps}</p>` : ''}
      </div>`;
    }
    
    if(detail.precaution) {
      contentHTML += `<div style="margin-bottom:20px;">
        <h4 style="color:#ff6b6b; font-size:15px; margin-bottom:10px; border-bottom:2px solid #ff6b6b; padding-bottom:5px;">주의사항</h4>
        <p style="margin-bottom:15px; line-height:1.8; color:#ffb86c;">${formatMultilineText(detail.precaution)}</p>
      </div>`;
    }
  }
  
  if(manualDesc) {
    hasContent = true;
    contentHTML += `<div style="margin-bottom:20px;">
      <h4 style="color:#2ec4b6; font-size:15px; margin-bottom:10px; border-bottom:2px solid #2ec4b6; padding-bottom:5px;">전문가 팁</h4>
      <p style="margin-bottom:15px; line-height:1.8;">${formatMultilineText(manualDesc.description)}</p>
    </div>`;
    
    if(manualDesc.instructions) {
      contentHTML += `<div style="margin-bottom:20px;">
        <h4 style="color:#2ec4b6; font-size:15px; margin-bottom:10px; border-bottom:2px solid #2ec4b6; padding-bottom:5px;">수행 방법</h4>
        <p style="margin-bottom:15px; line-height:1.8;">${formatMultilineText(manualDesc.instructions)}</p>
      </div>`;
    }
    
    if(manualDesc.benefits) {
      contentHTML += `<div style="margin-bottom:20px;">
        <h4 style="color:#2ec4b6; font-size:15px; margin-bottom:10px; border-bottom:2px solid #2ec4b6; padding-bottom:5px;">운동 효과</h4>
        <p style="margin-bottom:15px; line-height:1.8;">${formatMultilineText(manualDesc.benefits)}</p>
      </div>`;
    }
    
    if(manualDesc.precautions) {
      contentHTML += `<div style="margin-bottom:20px;">
        <h4 style="color:#ff6b6b; font-size:15px; margin-bottom:10px; border-bottom:2px solid #ff6b6b; padding-bottom:5px;">주의사항</h4>
        <p style="margin-bottom:15px; line-height:1.8; color:#ffb86c;">${formatMultilineText(manualDesc.precautions)}</p>
      </div>`;
    }
  }
  
  if(!hasContent) {
    contentHTML += `<div style="margin-bottom:20px;">
      <p style="margin-bottom:15px; line-height:1.8;">${exerciseKo || finalEn}</p>
      ${purpose ? `<p style="margin-bottom:15px; line-height:1.8; color:#2ec4b6;">목적: ${formatMultilineText(purpose)}</p>` : ''}
      <p style="margin-bottom:15px; line-height:1.8; color:var(--muted);">상세 설명을 불러오는 중입니다. 잠시 후 다시 시도해주세요.</p>
    </div>`;
  }
  
  modalContent.innerHTML = contentHTML;
  modal.style.display = "block";
  
  closeBtn.onclick = () => {
    modal.style.display = "none";
  };
  
  modal.onclick = (e) => {
    if(e.target === modal) {
      modal.style.display = "none";
    }
  };
  
  document.addEventListener('keydown', function escHandler(e) {
    if(e.key === 'Escape' && modal.style.display === 'block') {
      modal.style.display = "none";
      document.removeEventListener('keydown', escHandler);
    }
  });
}

function updateDisplay() {
  const M = sessions[cur].metrics;
  document.getElementById("dispCva").textContent = M.cva != null ? M.cva.toFixed(1) + "°" : "—";
  document.getElementById("dispPel").textContent = M.pelvic != null ? M.pelvic.toFixed(1) + "°" : "—";
  document.getElementById("dispKnee").textContent = M.knee != null ? M.knee.toFixed(1) + "°" : "—";
}

function fmtDeg(v) {
  return (v == null || isNaN(v)) ? "—" : v.toFixed(1) + "°";
}

function deltaStr(b, a, suf = "") {
  if(b == null || a == null || isNaN(b) || isNaN(a)) return "—";
  const d = a - b;
  const sign = d > 0 ? "+" : "";
  return sign + d.toFixed(1) + (suf || "");
}

function updateCompare() {
  const B = sessions.Before, A = sessions.After;
  
  // fullMetrics에서 16가지 항목 가져오기
  const bMetrics = B.metrics?.fullMetrics || {};
  const aMetrics = A.metrics?.fullMetrics || {};
  
  // 헬퍼 함수: 메트릭 값 가져오기
  const getMetricValue = (metrics, key) => {
    const metric = metrics[key];
    if(!metric) return null;
    return metric.value !== undefined ? metric.value : 
           (metric.value_deg !== undefined ? metric.value_deg : 
           (metric.value_cm !== undefined ? metric.value_cm : null));
  };
  
  // 측면 + 정면 항목 업데이트
  const compareItems = [
    // 측면 항목
    {key: 'CVA', id: 'Cva', unit: '°'},
    {key: 'HPD', id: 'Hpd', unit: 'cm'},
    {key: 'TIA', id: 'Tia', unit: '°'},
    {key: 'SAA', id: 'Saa', unit: '°'},
    {key: 'PTA', id: 'Pta', unit: '°'},
    {key: 'KA', id: 'Ka', unit: '°'},
    {key: 'Tibial_Angle', id: 'Tibial', unit: '°'},
    {key: 'Knee_Deviation', id: 'Kneedev', unit: '°'},
    {key: 'LLD', id: 'Lld', unit: 'cm'},
    {key: 'GSB', id: 'Gsb', unit: 'cm'},
    {key: 'HPA', id: 'Hpa', unit: '°'},
    {key: 'PDS', id: 'Pds', unit: ''},
    // 정면 항목
    {key: 'STA_F', altKey: 'STA', id: 'Sta', unit: '°'},
    {key: 'POA_F', altKey: 'POA', id: 'Poa', unit: '°'},
    {key: 'LLD_F', id: 'Lldf', unit: 'cm'},
    {key: 'TD', id: 'Td', unit: '°'},
    {key: 'HTA', id: 'Hta', unit: '°'},
    {key: 'SPP', id: 'Spp', unit: '°'},
    {key: 'Q_Angle', id: 'Qangle', unit: '°'},  // 정면 분석 항목으로 이동
    {key: 'KAS', id: 'Kas', unit: '°'},
    {key: 'LLAS', id: 'Llas', unit: '°'},
    {key: 'FBA', id: 'Fba', unit: '°'}
  ];
  
  // 헬퍼 함수: 정면 메트릭 키 가져오기 (하위 호환성)
  const getFrontMetricKey = (metrics, key, altKey) => {
    if(metrics[key]) return key;
    if(altKey && metrics[altKey]) return altKey;
    return key;
  };
  
  compareItems.forEach(item => {
    // 정면 항목의 경우 하위 호환성 키 확인
    const metricKeyB = item.altKey ? getFrontMetricKey(bMetrics, item.key, item.altKey) : item.key;
    const metricKeyA = item.altKey ? getFrontMetricKey(aMetrics, item.key, item.altKey) : item.key;
    
    const vB = getMetricValue(bMetrics, metricKeyB);
    const vA = getMetricValue(aMetrics, metricKeyA);
    
    const elB = document.getElementById(`cmp${item.id}B`);
    const elA = document.getElementById(`cmp${item.id}A`);
    const elD = document.getElementById(`cmp${item.id}D`);
    
    if(elB && elA && elD) {
      if(vB != null) {
        elB.textContent = vB.toFixed(item.unit === '' ? 2 : 1) + item.unit;
      } else {
        elB.textContent = "—";
      }
      
      if(vA != null) {
        elA.textContent = vA.toFixed(item.unit === '' ? 2 : 1) + item.unit;
      } else {
        elA.textContent = "—";
      }
      
      if(vB != null && vA != null) {
        elD.textContent = deltaStr(vB, vA, item.unit);
      } else {
        elD.textContent = "—";
      }
    }
  });
  
  // 점수 비교 업데이트
  const sB = B.score ? B.score.score : null, sA = A.score ? A.score.score : null;
  const scoreElB = document.getElementById("cmpScoreB");
  const scoreElA = document.getElementById("cmpScoreA");
  const scoreElD = document.getElementById("cmpScoreD");
  
  if(scoreElB && scoreElA && scoreElD) {
    scoreElB.textContent = sB != null ? sB : "—";
    scoreElA.textContent = sA != null ? sA : "—";
    if(sB != null && sA != null) {
      scoreElD.textContent = deltaStr(sB, sA, "");
    } else {
      scoreElD.textContent = "—";
    }
  }
}

// 좌표 수정 모드 토글
const btnEditCoords = document.getElementById("btnEditCoords");
const coordEditPanel = document.getElementById("coordEditPanel");
if(btnEditCoords && coordEditPanel) {
  btnEditCoords.onclick = () => {
    editMode = !editMode;
    console.log("좌표 수정 모드:", editMode ? "활성" : "비활성");
    if(editMode) {
      // 원본 크기 저장
      if(originalCanvasSize.width === 0) {
        originalCanvasSize.width = cv.width / DPR;
        originalCanvasSize.height = cv.height / DPR;
        originalCanvasSize.styleWidth = parseFloat(cv.style.width) || cv.width / DPR;
        originalCanvasSize.styleHeight = parseFloat(cv.style.height) || cv.height / DPR;
      }
      coordEditPanel.style.display = "block";
      btnEditCoords.style.background = "rgba(124,156,255,0.4)";
      btnEditCoords.textContent = "✏️ 좌표 수정 모드 (활성)";
      // 확대 적용
      applyZoom();
    } else {
      // 원래 크기로 복원
      currentZoom = 1;
      coordEditPanel.style.display = "none";
      btnEditCoords.style.background = "rgba(124,156,255,0.2)";
      btnEditCoords.textContent = "✏️ 좌표 수정 모드";
      selectedPoint = null;
      const selectEl = document.getElementById("coordSelectPoint");
      const xEl = document.getElementById("coordX");
      const yEl = document.getElementById("coordY");
      const zoomEl = document.getElementById("zoomLevel");
      if(selectEl) selectEl.value = "";
      if(xEl) xEl.value = "";
      if(yEl) yEl.value = "";
      if(zoomEl) zoomEl.value = "1";
      // 원본 크기 초기화하여 다시 계산되도록
      originalCanvasSize.width = 0;
      originalCanvasSize.height = 0;
      originalCanvasSize.styleWidth = 0;
      originalCanvasSize.styleHeight = 0;
      // 원본 크기로 복원
      const S = sessions[cur];
      const orientation = S.poseData?.orientation || "side";
      const img = orientation === "front" ? S.imgFront : S.imgSide;
      if(img) {
        resizeCanvasFor(img);
      }
      draw(); // 다시 그리기
    }
  };
} else {
  console.error("좌표 수정 모드 요소를 찾을 수 없습니다:", {btnEditCoords, coordEditPanel});
}

// 확대 적용 함수
function applyZoom() {
  const S = sessions[cur];
  const orientation = S.poseData?.orientation || "side";
  const img = orientation === "front" ? S.imgFront : S.imgSide;
  
  if(!editMode || !img) {
    return;
  }
  
  const zoomEl = document.getElementById("zoomLevel");
  if(zoomEl) {
    const newZoom = parseInt(zoomEl.value) || 1;
    currentZoom = clamp(newZoom, 1, 4); // 1~4배로 제한
  }
  
  // 원본 이미지로 확대 적용 (비율 유지)
  resizeCanvasFor(img);
  
  // 좌표 입력 필드 업데이트
  if(selectedPoint) {
    const P = getPts(cur);
    const pt = P[selectedPoint];
    if(pt && coordX && coordY) {
      // 좌표는 항상 원본 크기 기준으로 표시
      coordX.value = pt.x.toFixed(1);
      coordY.value = pt.y.toFixed(1);
    }
  }
}

// 확대 배율 변경
const zoomLevel = document.getElementById("zoomLevel");
if(zoomLevel) {
  zoomLevel.addEventListener("change", () => {
    if(editMode) {
      applyZoom();
    }
  });
}

// 점 선택 드롭다운 변경
const coordSelectPoint = document.getElementById("coordSelectPoint");
const coordX = document.getElementById("coordX");
const coordY = document.getElementById("coordY");

// 점 선택 시 좌표 표시 함수
function updateCoordDisplay() {
  if(!coordX || !coordY) return;
  
  if(selectedPoint) {
    const P = getPts(cur);
    const pt = P[selectedPoint];
    if(pt) {
      // 원본 크기 기준 좌표 표시
      coordX.value = pt.x.toFixed(1);
      coordY.value = pt.y.toFixed(1);
    } else {
      // 점이 없으면 기본값 설정 (이미지가 있는 경우 중앙 근처)
      if(sessions[cur].img) {
        const originalW = originalCanvasSize.width || (cv.width / DPR);
        const originalH = originalCanvasSize.height || (cv.height / DPR);
        const defaultX = (originalW / 2).toFixed(1);
        const defaultY = (originalH / 2).toFixed(1);
        coordX.value = defaultX;
        coordY.value = defaultY;
      } else {
        coordX.value = "";
        coordY.value = "";
      }
    }
    draw();
  } else {
    coordX.value = "";
    coordY.value = "";
    draw();
  }
}

if(coordSelectPoint && coordX && coordY) {
  coordSelectPoint.addEventListener("change", e => {
    selectedPoint = e.target.value || null;
    console.log("선택된 점:", selectedPoint);
    updateCoordDisplay();
  });
  
  // 초기화 시에도 좌표 표시 업데이트 (점이 이미 선택되어 있으면)
  if(selectedPoint) {
    updateCoordDisplay();
  }
} else {
  console.error("좌표 입력 요소를 찾을 수 없습니다:", {coordSelectPoint, coordX, coordY});
}

// 드래그할 때도 좌표 업데이트를 위해 함수를 전역으로 노출
window.updateCoordDisplay = updateCoordDisplay;

// 좌표 적용 (저장 버튼 역할 - AI 분석 실행)
const coordApply = document.getElementById("coordApply");
if(coordApply) {
  coordApply.onclick = () => {
    if(!selectedPoint) {
      alert("점을 선택해주세요.");
      return;
    }
    const x = parseFloat(coordX.value);
    const y = parseFloat(coordY.value);
    if(isNaN(x) || isNaN(y)) {
      alert("올바른 좌표를 입력해주세요.");
      return;
    }
    // 좌표는 항상 원본 크기 기준으로 저장
    const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
    const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
    const orientation = sessions[cur].poseData?.orientation || "side";
    const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
    const clampedX = clamp(x, 0, originalW);
    const clampedY = clamp(y, 0, originalH);
    map.set(selectedPoint, {
      x: clampedX,
      y: clampedY
    });
    // 점선과 도트가 항상 그려지도록 보장
    try {
      draw();
    } catch(err) {
      console.error("draw() 호출 중 오류 (coordApply):", err);
      // 에러가 발생해도 다시 시도
      setTimeout(() => {
        try {
          draw();
        } catch(retryErr) {
          console.error("draw() 재시도 실패:", retryErr);
        }
      }, 10);
    }
    // 입력 필드 업데이트
    coordX.value = clampedX.toFixed(1);
    coordY.value = clampedY.toFixed(1);
    
    // 저장 후 원래 크기로 복원 및 모드 종료
    if(editMode) {
      // 먼저 editMode를 false로 설정하여 resizeCanvasFor가 원본 크기로 복원하도록 함
      editMode = false;
      currentZoom = 1;
      
      // UI 업데이트
      const zoomEl = document.getElementById("zoomLevel");
      if(zoomEl) zoomEl.value = "1";
      
      // 패널 닫기
      if(coordEditPanel) {
        coordEditPanel.style.display = "none";
      }
      
      // 버튼 상태 업데이트
      if(btnEditCoords) {
        btnEditCoords.style.background = "rgba(124,156,255,0.2)";
        btnEditCoords.textContent = "✏️ 좌표 수정 모드";
      }
      
      // 선택된 점 초기화
      selectedPoint = null;
      const selectEl = document.getElementById("coordSelectPoint");
      if(selectEl) selectEl.value = "";
      
      // 원본 크기로 복원 (orientation에 따라 올바른 이미지 사용)
      const S = sessions[cur];
      const orientation = S.poseData?.orientation || "side";
      const img = orientation === "front" ? S.imgFront : S.imgSide;
      
      // 모바일에서 안정적인 렌더링을 위해 requestAnimationFrame 사용
      requestAnimationFrame(() => {
        if(img) {
          resizeCanvasFor(img);
        } else if(S.img) {
          resizeCanvasFor(S.img);
        }
        
        // 강제 리플로우를 위해 한 프레임 더 대기 (모바일에서 필요)
        requestAnimationFrame(() => {
          draw();
          
          // 모바일에서 추가 안정성을 위해 한 번 더 대기
          requestAnimationFrame(() => {
            // 캔버스 크기 강제 업데이트 (모바일에서 필요할 수 있음)
            if(cv && cv.style) {
              cv.style.width = cv.style.width;
              cv.style.height = cv.style.height;
            }
          });
        });
      });
    }
    
    // AI 분석 실행 (비동기로 처리하여 랙 방지, 모바일에서는 더 긴 지연)
    const isMobile = window.innerWidth <= 768 && 'ontouchstart' in window;
    const delay = isMobile ? 150 : 50;
    setTimeout(() => {
      computeAll();
      // 실시간 분석 실행
      if(typeof liveAnalyzer !== 'undefined') {
        liveAnalyzer.analyzeCurrentSession();
      }
    }, delay);
  };
}

// 취소
const coordCancel = document.getElementById("coordCancel");
if(coordCancel) {
  coordCancel.onclick = () => {
    selectedPoint = null;
    if(coordSelectPoint) coordSelectPoint.value = "";
    if(coordX) coordX.value = "";
    if(coordY) coordY.value = "";
    draw();
  };
}

// X, Y 좌표 입력 필드에서 Enter 키로도 적용 가능
if(coordX) {
  coordX.addEventListener("keypress", e => {
    if(e.key === "Enter") {
      if(coordApply) coordApply.click();
    }
  });
}
if(coordY) {
  coordY.addEventListener("keypress", e => {
    if(e.key === "Enter") {
      if(coordApply) coordApply.click();
    }
  });
}

// 좌표 증감 버튼 기능 (자동 적용)
function adjustCoordinate(coordField, delta) {
  if(!coordField) return;
  
  // 현재 값이 비어있으면 기본값 설정
  let currentValue = parseFloat(coordField.value);
  if(isNaN(currentValue)) {
    // 좌표가 없으면 중앙값으로 설정
    const originalW = originalCanvasSize.width || (cv.width / DPR);
    const originalH = originalCanvasSize.height || (cv.height / DPR);
    if(coordField === coordX) {
      currentValue = originalW / 2;
    } else {
      currentValue = originalH / 2;
    }
  }
  
  const newValue = currentValue + delta;
  coordField.value = newValue.toFixed(1);
  
  // 자동으로 적용 (점이 선택되어 있고 좌표가 유효한 경우)
  if(selectedPoint && !isNaN(newValue)) {
    const xField = coordX;
    const yField = coordY;
    if(!xField || !yField) return;
    
    const x = parseFloat(xField.value);
    const y = parseFloat(yField.value);
    
    if(!isNaN(x) && !isNaN(y)) {
      // 좌표는 항상 원본 크기 기준으로 저장
      const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
      const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
      const orientation = sessions[cur].poseData?.orientation || "side";
      const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
      const clampedX = clamp(x, 0, originalW);
      const clampedY = clamp(y, 0, originalH);
      
      map.set(selectedPoint, {
        x: clampedX,
        y: clampedY
      });
      
      // 입력 필드도 업데이트 (클램핑된 값)
      xField.value = clampedX.toFixed(1);
      yField.value = clampedY.toFixed(1);
      
    draw();
    computeMetricsOnly(); // 실시간 분석 없음 (저장 버튼 클릭 시에만 AI 분석)
    }
  }
}

// 증감 버튼 연속 클릭 변수
let incrementTimer = null;
let incrementInterval = null;

function startIncrement(coordField, delta) {
  // 즉시 한 번 실행
  adjustCoordinate(coordField, delta);
  
  // 짧은 딜레이 후 연속 실행
  incrementTimer = setTimeout(() => {
    incrementInterval = setInterval(() => {
      adjustCoordinate(coordField, delta);
    }, 50); // 50ms마다 실행 (빠른 증감)
  }, 300); // 300ms 후 연속 실행 시작
}

function stopIncrement() {
  if(incrementTimer) {
    clearTimeout(incrementTimer);
    incrementTimer = null;
  }
  if(incrementInterval) {
    clearInterval(incrementInterval);
    incrementInterval = null;
  }
}

// X 좌표 증감 버튼
const coordXDec = document.getElementById("coordXDec");
const coordXInc = document.getElementById("coordXInc");
if(coordXDec) {
  coordXDec.onmousedown = () => {
    if(coordX) startIncrement(coordX, -0.1);
  };
  coordXDec.onmouseup = stopIncrement;
  coordXDec.onmouseleave = stopIncrement;
  coordXDec.ontouchstart = (e) => {
    e.preventDefault();
    if(coordX) startIncrement(coordX, -0.1);
  };
  coordXDec.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordXDec.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}
if(coordXInc) {
  coordXInc.onmousedown = () => {
    if(coordX) startIncrement(coordX, 0.1);
  };
  coordXInc.onmouseup = stopIncrement;
  coordXInc.onmouseleave = stopIncrement;
  coordXInc.ontouchstart = (e) => {
    e.preventDefault();
    if(coordX) startIncrement(coordX, 0.1);
  };
  coordXInc.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordXInc.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}

// Y 좌표 증감 버튼 (Y는 화면 아래로 갈수록 값이 커지므로 반대로)
const coordYDec = document.getElementById("coordYDec");
const coordYInc = document.getElementById("coordYInc");
if(coordYDec) {
  coordYDec.onmousedown = () => {
    if(coordY) startIncrement(coordY, 0.1); // Y는 위로 가려면 값이 증가해야 함
  };
  coordYDec.onmouseup = stopIncrement;
  coordYDec.onmouseleave = stopIncrement;
  coordYDec.ontouchstart = (e) => {
    e.preventDefault();
    if(coordY) startIncrement(coordY, 0.1);
  };
  coordYDec.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordYDec.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}
if(coordYInc) {
  coordYInc.onmousedown = () => {
    if(coordY) startIncrement(coordY, -0.1); // Y는 아래로 가려면 값이 감소해야 함
  };
  coordYInc.onmouseup = stopIncrement;
  coordYInc.onmouseleave = stopIncrement;
  coordYInc.ontouchstart = (e) => {
    e.preventDefault();
    if(coordY) startIncrement(coordY, -0.1);
  };
  coordYInc.ontouchend = (e) => {
    e.preventDefault();
    stopIncrement();
  };
  coordYInc.ontouchcancel = (e) => {
    e.preventDefault();
    stopIncrement();
  };
}

// 드래그 기능 (마우스 + 터치)
function getEventPos(e) {
  const r = cv.getBoundingClientRect();
  const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
  
  // 캔버스 상대 좌표 (캔버스 기준)
  // getBoundingClientRect()는 이미 스크롤된 위치를 반영하므로
  // clientX - r.left는 캔버스 전체에서의 CSS 픽셀 위치입니다
  let x = clientX - r.left;
  let y = clientY - r.top;
  
  // 확대 모드
  if(editMode && currentZoom > 1) {
    // x, y는 이미 확대된 캔버스 전체에서의 CSS 픽셀 위치 (스크롤 포함)
    // 따라서 zoom으로 나누기만 하면 원본 크기 좌표가 됨
    x = x / currentZoom;
    y = y / currentZoom;
    
    // 원본 크기 범위로 제한
    const originalW = originalCanvasSize.width || (cv.width / DPR / currentZoom);
    const originalH = originalCanvasSize.height || (cv.height / DPR / currentZoom);
    x = Math.max(0, Math.min(x, originalW));
    y = Math.max(0, Math.min(y, originalH));
    
    console.log('확대 모드 좌표 변환:', {
      clientX, clientY,
      rLeft: r.left.toFixed(1), rTop: r.top.toFixed(1),
      beforeZoom: {x: (clientX - r.left).toFixed(1), y: (clientY - r.top).toFixed(1)},
      afterZoom: {x: x.toFixed(1), y: y.toFixed(1)},
      zoom: currentZoom
    });
  } else {
    // 일반 모드: CSS 좌표를 캔버스 논리 좌표로 변환
    const cssWidth = r.width;
    const cssHeight = r.height;
    
    // 원본 크기 기준으로 변환
    const originalW = originalCanvasSize.width || (cv.width / DPR);
    const originalH = originalCanvasSize.height || (cv.height / DPR);
    
    // CSS 좌표를 논리 좌표로 변환
    x = (x / cssWidth) * originalW;
    y = (y / cssHeight) * originalH;
    
    // 범위 제한
    x = Math.max(0, Math.min(x, originalW));
    y = Math.max(0, Math.min(y, originalH));
  }
  
  return { x, y };
}

function startDrag(e) {
  // 상태 초기화 (touchstart에서 이미 초기화했을 수 있지만 다시 초기화)
  // 이전 상태가 완전히 정리되었는지 확인
  if(dragKey) {
    console.log('⚠️ startDrag: 이전 드래그 상태가 아직 남아있음:', dragKey);
  }
  
  // 상태 초기화 (명시적으로)
  dragKey = null;
  isScrolling = false;
  scrollDistance = 0;
  
  // 터치 이벤트인 경우 손가락 개수 확인
  let touchCount = 0;
  if(e.touches) {
    touchCount = e.touches.length;
    touchStartTime = Date.now();
  }
  
  // 확대 모드에서 스크롤은 두 손가락만 허용
  if(editMode && currentZoom > 1 && touchCount === 2) {
    // 두 손가락 터치: 스크롤 모드만 허용 (점 드래그 불가)
    isScrolling = true;
    dragKey = null;
    if(e.touches && e.touches.length > 0) {
      scrollStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      scrollStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    }
    return false;
  }
  
  // 한 손가락 터치만 점 드래그 허용
  if(touchCount > 1 && !(editMode && currentZoom > 1)) {
    // 확대 모드가 아닌데 두 손가락 이상이면 무시
    return false;
  }
  
  const pos = getEventPos(e);
  const P = getPts(cur);
  
  // Long press 관련 상태 초기화 (더 이상 사용하지 않지만 정리용)
  if(longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  longPressDetected = false;
  longPressNearPoint = null;
  
  // 먼저 모든 점을 체크하여 점을 터치했는지 확인
  // getEventPos는 이미 원본 크기 기준으로 좌표를 반환하므로, 점 좌표와 직접 비교 가능
  let bestPoint = null;
  let bestDistance = 1e9;
  
  // threshold 계산: 확대 모드에서는 1cm 정도의 감지 영역만 유지
  // 1cm를 픽셀로 변환 (일반적으로 96 DPI 기준 약 37.8픽셀, 하지만 실제로는 devicePixelRatio 고려)
  // 실제 화면 크기를 고려하여 더 정확하게 계산
  const r = cv.getBoundingClientRect();
  const screenWidth = r.width; // CSS 픽셀
  
  // 2cm를 픽셀로 변환 (96 DPI 기준: 1cm ≈ 37.8px, 2cm ≈ 75.6px)
  // 하지만 실제 화면에서는 devicePixelRatio를 고려해야 함
  // 간단하게 화면 크기 기준으로 2cm를 추정 (화면 너비의 약 5% 정도)
  const cmToPixel = screenWidth * 0.05; // 화면 너비의 5%를 2cm로 추정
  // 확대 모드에서는 원본 좌표 기준이므로 threshold를 적절히 설정
  // 너무 크면 빈 화면을 눌러도 드래그가 시작될 수 있으므로 적절한 범위 유지
  const baseThreshold = Math.max(50, Math.min(100, cmToPixel)); // 최소 50px, 최대 100px (2cm)
  
  // 확대 모드에서는 원본 크기 기준으로 threshold를 계산
  // 모든 확대 배율에서 동일한 인식 범위를 유지하기 위해 원본 좌표 기준으로 threshold 사용
  let threshold;
  if(editMode && currentZoom > 1) {
    // 확대 모드: 원본 좌표 기준으로 threshold 설정
    // 모든 확대 배율(2, 3, 4배)에서 동일한 인식 범위를 유지
    // 원본 좌표 기준이므로 threshold는 그대로 사용
    threshold = baseThreshold; // 확대 모드에서는 원본 기준 threshold 사용 (모든 배율에서 동일)
  } else {
    // 일반 모드: 화면 픽셀 기준 (라벨 영역 포함)
    threshold = baseThreshold * 1.5; // 라벨 영역 포함을 위해 약간 더 크게
  }
  
  console.log('드래그 감지 시작, threshold:', threshold, 'editMode:', editMode, 'zoom:', currentZoom, 'pos:', pos, 'baseThreshold:', baseThreshold);
  
  // 좌표 수정 모드일 때는 선택된 점만 체크
  if(editMode && selectedPoint) {
    const pt = P[selectedPoint];
    if(pt) {
      // 배율 1이어도 원본 좌표 기준으로 거리 계산 (threshold도 원본 기준)
      // pos는 이미 원본 크기 기준으로 변환되어 있음
      const d = Math.hypot(pt.x - pos.x, pt.y - pos.y);
      if(d < threshold) {
        bestPoint = selectedPoint;
        bestDistance = d;
        console.log('✅ 선택된 점 드래그 시작 (배율 ' + currentZoom + '):', selectedPoint, '거리:', d.toFixed(2));
      } else {
        console.log('❌ 선택된 점이 너무 멀어서 드래그 불가:', selectedPoint, '거리:', d.toFixed(2), 'threshold:', threshold);
      }
    }
    // 선택된 점만 체크하므로 다른 점은 체크하지 않음 (bestPoint가 null이면 드래그 시작 안 됨)
  } else if(editMode && !selectedPoint) {
    // editMode지만 선택된 점이 없으면 드래그 불가
    console.log('⚠️ 좌표 수정 모드이지만 선택된 점이 없어서 드래그 불가');
    return false;
  } else {
    // 일반 모드 (editMode가 false): 모든 점 체크 (현재 orientation에 맞는 키포인트 사용)
    const currentKeypoints = getKeypoints();
    for(const k of currentKeypoints) {
      const p = P[k.key];
      if(!p) continue;
      
      // 일반 모드에서는 CSS 좌표 기준으로 거리 계산
        // pos는 이미 원본 크기 기준으로 변환되어 있음
      const d = Math.hypot(p.x - pos.x, p.y - pos.y);
      
        if(d < threshold) {
        console.log('✅ 일반 모드 점 감지:', k.key, '점 좌표:', p, '터치 좌표:', pos, '거리:', d.toFixed(2), 'threshold:', threshold, 'zoom:', currentZoom);
      }
      
      if(d < threshold && d < bestDistance) {
        bestPoint = k.key;
        bestDistance = d;
      }
    }
  }
  
  // 점 근처를 터치했을 때만 드래그 모드로 전환
  // bestPoint가 설정되고 threshold 내에 있을 때만 드래그 시작
  if(bestPoint && bestDistance < threshold) {
    // preventDefault는 이벤트 리스너에서 처리하므로 여기서는 하지 않음
    isScrolling = false;
    dragKey = bestPoint; // 확실하게 설정
    
    // 스크롤 시작 위치 저장 (드래그 중에도 사용)
    if(e.touches && e.touches.length > 0) {
      scrollStartX = e.touches[0].clientX;
      scrollStartY = e.touches[0].clientY;
    } else {
      scrollStartX = e.clientX;
      scrollStartY = e.clientY;
    }
    
    console.log('✅ 드래그 시작 성공:', bestPoint, '거리:', bestDistance.toFixed(2), 'threshold:', threshold, 'pos:', pos, 'dragKey:', dragKey, 'editMode:', editMode, 'zoom:', currentZoom);
    return true;
  } else {
    // 점 근처를 누르지 않았으면 드래그 시작하지 않음
    console.log('❌ 점 근처를 누르지 않음, bestPoint:', bestPoint, '거리:', bestDistance < 1e9 ? bestDistance.toFixed(2) : 'N/A', 'threshold:', threshold, 'pos:', pos);
  }
  
  // 점이 아닌 빈 화면을 터치했으면 드래그 시작하지 않음
  // 확대 모드에서 한 손가락 터치는 스크롤 불가 (두 손가락만 스크롤)
  // 일반 모드에서는 아무 동작도 하지 않음
  isScrolling = false;
  dragKey = null; // 명시적으로 null로 설정
  return false;
}

function doDrag(e) {
  // 터치 이벤트인 경우 손가락 개수 확인
  let touchCount = 0;
  if(e.touches) {
    touchCount = e.touches.length;
  }
  
  // 두 손가락 터치: 스크롤만 허용 (확대 모드에서만)
  if(touchCount === 2 && editMode && currentZoom > 1) {
    e.preventDefault();
    e.stopPropagation();
    
    // 스크롤 모드 활성화 확인
    if(!isScrolling) {
      // 스크롤 모드가 아니면 초기화하고 시작
      isScrolling = true;
      dragKey = null;
    }
    
    // 두 손가락의 중심점 계산
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentX = (touch1.clientX + touch2.clientX) / 2;
    const currentY = (touch1.clientY + touch2.clientY) / 2;
    
    // 스크롤 시작 위치가 설정되지 않았으면 설정
    if(scrollStartX === 0 && scrollStartY === 0) {
      scrollStartX = currentX;
      scrollStartY = currentY;
      return;
    }
    
    // 스크롤만 수행
    const canvasWrap = cv.parentElement;
    const deltaX = scrollStartX - currentX;
    const deltaY = scrollStartY - currentY;
    canvasWrap.scrollLeft += deltaX;
    canvasWrap.scrollTop += deltaY;
    scrollStartX = currentX;
    scrollStartY = currentY;
    return;
  }
  
  // 한 손가락만 드래그 허용 (두 손가락 이상이면 무시)
  if(touchCount > 1 && !(editMode && currentZoom > 1 && touchCount === 2)) {
    return;
  }
  
  // dragKey가 없으면 드래그 처리 안 함
  if(!dragKey) {
    return;
  }
  
  // 드래그 모드가 이미 활성화되어 있으면 드래그 처리만 수행 (스크롤 완전 차단)
  if(dragKey) {
    e.preventDefault(); // 스크롤 방지
    e.stopPropagation(); // 이벤트 전파 차단
    
    const pos = getEventPos(e);
    // 좌표는 항상 원본 크기 기준으로 저장
    const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
    const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
    const x = clamp(pos.x, 0, originalW);
    const y = clamp(pos.y, 0, originalH);
    const orientation = sessions[cur].poseData?.orientation || "side";
    const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
    const p = map.get(dragKey);
    
    if(!p) {
      // 점이 없으면 드래그 종료
      console.log('점이 없어 드래그 종료:', dragKey);
      dragKey = null;
      isScrolling = false;
      return;
    }
    
    // 좌표 수정 모드에서는 선택된 점만 이동 (다른 점은 절대 이동 불가)
    if(editMode && selectedPoint) {
      if(dragKey !== selectedPoint) {
        // 선택된 점이 아니면 드래그 무시
        console.log('⚠️ 선택된 점이 아니므로 드래그 무시:', 'dragKey:', dragKey, 'selectedPoint:', selectedPoint);
        dragKey = null; // 드래그 종료
        return;
      }
    }
    
    // 좌표 업데이트 (즉시 반영)
    p.x = x;
    p.y = y;
    
    // 입력 필드도 실시간 업데이트 (원본 크기 기준)
    if(coordX && coordY) {
      coordX.value = x.toFixed(1);
      coordY.value = y.toFixed(1);
    }
    
    // 선택된 점과 일치하면 좌표 표시 업데이트
    if(selectedPoint === dragKey && typeof window.updateCoordDisplay === 'function') {
      window.updateCoordDisplay();
    }
    
    // 즉시 화면 업데이트 (점선과 도트가 항상 그려지도록)
    try {
      draw();
    } catch(err) {
      console.error("draw() 호출 중 오류 (doDrag):", err);
      // 에러가 발생해도 다시 시도
      setTimeout(() => {
        try {
          draw();
        } catch(retryErr) {
          console.error("draw() 재시도 실패:", retryErr);
        }
      }, 10);
    }
    
    // 실시간 분석 업데이트 (throttle 적용)
    if(!dragUpdateTimer) {
      dragUpdateTimer = requestAnimationFrame(() => {
        computeAll(); // 전체 분석 실행
        dragUpdateTimer = null;
      });
    }
    
    return; // 드래그 모드에서는 스크롤 완전 차단
  }
}

// 드래그 업데이트 타이머
let dragUpdateTimer = null;

function endDrag(e) {
  // Long press 타이머 정리 (더 이상 사용하지 않지만 정리용)
  if(longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  
  // 드래그 업데이트 타이머 정리
  if(dragUpdateTimer) {
    cancelAnimationFrame(dragUpdateTimer);
    dragUpdateTimer = null;
  }
  
  // 드래그가 끝나면 상태 완전히 초기화 (다음 드래그를 위해)
  const wasDragging = dragKey !== null;
  if(dragKey) {
    console.log('드래그 종료:', dragKey);
    // 최종 분석 실행
    computeAll();
  }
  
  // 모든 상태 완전히 초기화 (매번 확실히)
  dragKey = null;
  isScrolling = false;
  scrollDistance = 0;
  scrollStartX = 0;
  scrollStartY = 0;
  longPressDetected = false;
  longPressNearPoint = null;
  
  // 마우스 상태도 초기화
  if(typeof isMouseDown !== 'undefined') {
    isMouseDown = false;
  }
  
  // 상태 초기화 확인 로그
  if(wasDragging) {
    console.log('드래그 상태 초기화 완료, 다음 드래그 준비됨');
  }
}

// 마우스 이벤트
let isMouseDown = false;
cv.addEventListener('mousedown', (e) => {
  isMouseDown = true;
  
  // 자동 추적 모드 토글 체크 (dot를 클릭하면 토글) - startDrag 전에 체크
  const pos = getEventPos(e);
  const P = getPts(cur);
  const currentKeypoints = getKeypoints();
  let clickedPoint = null;
  let minDistance = 1e9;
  const threshold = 50; // 클릭 감지 범위
  
  for(const k of currentKeypoints) {
    const p = P[k.key];
    if(!p) continue;
    const d = Math.hypot(p.x - pos.x, p.y - pos.y);
    if(d < threshold && d < minDistance) {
      clickedPoint = k.key;
      minDistance = d;
    }
  }
  
  // dot를 클릭했을 때 자동 추적 모드 토글
  if(clickedPoint) {
    if(autoFollowKey === clickedPoint) {
      // 이미 자동 추적 중이면 해제
      autoFollowKey = null;
      dragKey = null;
      console.log('🛑 자동 추적 모드 해제:', clickedPoint);
      isMouseDown = false;
      e.preventDefault();
      return;
    } else {
      // 자동 추적 모드 활성화
      autoFollowKey = clickedPoint;
      dragKey = null; // 드래그 모드는 해제
      console.log('▶️ 자동 추적 모드 활성화:', clickedPoint);
      isMouseDown = false;
      e.preventDefault();
      return;
    }
  }
  
  // 자동 추적 모드가 아니면 일반 드래그 처리
  const dragStarted = startDrag(e);
  
  // 점을 찾지 못했으면 isMouseDown을 false로 설정 (드래그가 시작되지 않았으므로)
  if(!dragStarted) {
    isMouseDown = false;
  } else {
    // 드래그가 시작되면 자동 추적 모드 해제
    if(autoFollowKey) {
      autoFollowKey = null;
    }
  }
});

window.addEventListener('mouseup', () => {
  isMouseDown = false;
  endDrag();
});

window.addEventListener('mouseleave', () => {
  isMouseDown = false;
  endDrag();
});

window.addEventListener('mousemove', (e) => {
  // 자동 추적 모드: dragKey 없이도 마우스를 따라옴
  if(autoFollowKey) {
    const pos = getEventPos(e);
    const originalW = originalCanvasSize.width || (cv.width / DPR / (editMode ? currentZoom : 1));
    const originalH = originalCanvasSize.height || (cv.height / DPR / (editMode ? currentZoom : 1));
    const x = clamp(pos.x, 0, originalW);
    const y = clamp(pos.y, 0, originalH);
    const orientation = sessions[cur].poseData?.orientation || "side";
    const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
    const p = map.get(autoFollowKey);
    
    if(p) {
      p.x = x;
      p.y = y;
      
      // 입력 필드도 실시간 업데이트
      if(coordX && coordY && selectedPoint === autoFollowKey) {
        coordX.value = x.toFixed(1);
        coordY.value = y.toFixed(1);
      }
      
      // 즉시 화면 업데이트 (점선과 도트가 항상 그려지도록)
      try {
        draw();
      } catch(err) {
        console.error("draw() 호출 중 오류 (autoFollow):", err);
        // 에러가 발생해도 다시 시도
        setTimeout(() => {
          try {
            draw();
          } catch(retryErr) {
            console.error("draw() 재시도 실패:", retryErr);
          }
        }, 10);
      }
      
      // 실시간 분석 업데이트 (throttle 적용)
      if(!dragUpdateTimer) {
        dragUpdateTimer = requestAnimationFrame(() => {
          computeMetricsOnly();
          dragUpdateTimer = null;
        });
      }
    }
  }
  
  // dragKey가 설정되어 있을 때만 드래그 처리 (점을 클릭했을 때만)
  if(dragKey) {
    doDrag(e);
  }
});

// 터치 이벤트 (모바일 지원)
cv.addEventListener('touchstart', (e) => {
  const touchCount = e.touches ? e.touches.length : 0;
  
  // 이전 상태가 남아있으면 완전히 초기화 (드래그든 스크롤이든)
  // 스크롤 후 새로운 드래그를 위해 완전히 초기화
  if(dragKey || isScrolling) {
    console.log('⚠️ 이전 상태가 남아있음, 완전히 정리 - dragKey:', dragKey, 'isScrolling:', isScrolling);
    dragKey = null;
    isScrolling = false;
    scrollStartX = 0;
    scrollStartY = 0;
    scrollDistance = 0;
    // endDrag도 호출하여 완전히 정리
    endDrag(e);
  }
  
  // 두 손가락 스크롤인 경우 스크롤 시작 위치 설정
  if(touchCount === 2 && editMode && currentZoom > 1) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    scrollStartX = (touch1.clientX + touch2.clientX) / 2;
    scrollStartY = (touch1.clientY + touch2.clientY) / 2;
    isScrolling = true;
    dragKey = null;
    console.log('두 손가락 스크롤 시작, scrollStartX:', scrollStartX, 'scrollStartY:', scrollStartY);
    e.preventDefault();
    e.stopPropagation();
    return;
  }
  
  // 한 손가락 터치인 경우에만 점 찾기 시도
  if(touchCount === 1) {
    // 새로운 터치 시작 (이전 상태는 이미 초기화됨)
    const result = startDrag(e);
    
    // 점을 터치했으면 preventDefault
    if(result === true) {
      e.preventDefault();
      e.stopPropagation();
      console.log('한 손가락 터치 - 점 감지 성공, dragKey:', dragKey);
    } else {
      console.log('한 손가락 터치 - 점 감지 실패');
    }
  }
}, {passive: false});

window.addEventListener('touchmove', (e) => {
  const touchCount = e.touches ? e.touches.length : 0;
  
  // 두 손가락 터치인 경우 스크롤 모드
  if(touchCount === 2 && editMode && currentZoom > 1) {
    e.preventDefault();
    e.stopPropagation();
    isScrolling = true;
    dragKey = null; // 스크롤 모드에서는 드래그 키 제거
    doDrag(e);
    return;
  }
  
  // 두 손가락에서 한 손가락으로 변경된 경우 (스크롤 종료)
  if(touchCount === 1 && isScrolling && editMode && currentZoom > 1) {
    // 스크롤 모드 종료하고 상태 초기화
    console.log('스크롤 모드 종료 (두 손가락 → 한 손가락)');
    isScrolling = false;
    dragKey = null;
    scrollStartX = 0;
    scrollStartY = 0;
    // 드래그 처리 안 함 (새로운 터치가 필요)
    return;
  }
  
  // 한 손가락 터치인 경우
  if(touchCount === 1) {
    // dragKey가 설정되어 있으면 드래그 모드 (점 근처를 눌렀을 때만)
    if(dragKey) {
      e.preventDefault();
      e.stopPropagation();
      isScrolling = false; // 드래그 중에는 스크롤 아님
      doDrag(e);
      return;
    }
    
    // dragKey가 없으면 드래그 처리 안 함 (점 근처를 누르지 않았음)
    // 확대 모드에서도 빈 화면을 누르면 아무것도 하지 않음
    return;
  }
  
  // 터치가 없거나 3개 이상인 경우 상태 초기화
  if(touchCount === 0 || touchCount > 2) {
    isScrolling = false;
    dragKey = null;
  }
  
  // 기본 동작은 허용 (점이 아닌 곳을 터치한 경우)
}, {passive: false});

window.addEventListener('touchend', (e) => {
  // changedTouches를 확인하여 끝난 터치가 있는지 체크
  const remainingTouches = e.touches ? e.touches.length : 0;
  const endedTouches = e.changedTouches ? e.changedTouches.length : 0;
  
  // 모든 터치가 끝났는지 확인
  if(remainingTouches === 0) {
    // 모든 터치가 끝났으면 드래그/스크롤 완전히 종료
    console.log('모든 터치 종료, 상태 완전 초기화');
    endDrag(e);
    // 추가로 확실하게 초기화
    dragKey = null;
    isScrolling = false;
    scrollStartX = 0;
    scrollStartY = 0;
    scrollDistance = 0;
  } else if(endedTouches > 0) {
    // 일부 터치만 끝났는 경우
    // 두 손가락 스크롤 중 하나가 떨어졌으면 스크롤 모드 종료
    if(isScrolling && remainingTouches === 1) {
      console.log('스크롤 모드 종료 (한 손가락 남음), 상태 초기화');
      isScrolling = false;
      dragKey = null;
      scrollStartX = 0;
      scrollStartY = 0;
      scrollDistance = 0;
      // 다음 드래그를 위해 완전히 초기화
    } else if(remainingTouches === 1 && dragKey) {
      // 드래그 중이었는데 한 손가락이 남아있으면 드래그 계속
      // endDrag 호출하지 않음
    } else {
      // 그 외의 경우는 상태 초기화
      endDrag(e);
    }
  }
});
window.addEventListener('touchcancel', (e) => {
  // 터치가 취소되면 무조건 드래그/스크롤 종료
  console.log('터치 취소, 상태 초기화');
  endDrag(e);
});

// 파일 업로드 핸들러 (공통 함수) - 전역으로 등록
window.handleFileUpload = function handleFileUpload(e) {
  const f = e.target.files[0];
  if(!f) return;
  const targetSessionName = cur;
  const targetSession = sessions[targetSessionName];
  if(!targetSession) {
    console.warn("세션 정보를 찾을 수 없습니다.");
    return;
  }
  
  // 현재 선택된 버튼(정면/옆모습) 확인 - 사용자가 선택한 orientation 우선 사용
  const btnSide = document.getElementById("btnOrientationSide");
  const btnFront = document.getElementById("btnOrientationFront");
  const currentButtonOrientation = btnFront?.classList.contains("active") ? "front" 
    : (btnSide?.classList.contains("active") ? "side" : null);
  
  // 현재 선택된 버튼의 orientation을 우선 사용, 없으면 세션의 orientation, 그것도 없으면 기본값 "side"
  const guessedOrientation = currentButtonOrientation || targetSession.poseData?.orientation || "side";
  if(!targetSession.poseData) {
    targetSession.poseData = { orientation: guessedOrientation, landmarks: null, orientationMode: currentButtonOrientation ? "manual" : "auto" };
  } else if(!targetSession.poseData.orientationMode) {
    targetSession.poseData.orientationMode = currentButtonOrientation ? "manual" : "auto";
  }
  let imgKey = guessedOrientation === "front" ? "imgFront" : "imgSide";
  
  console.log("파일 업로드 - 현재 선택된 orientation:", guessedOrientation, "(버튼:", currentButtonOrientation, ", 세션:", targetSession.poseData?.orientation, ")");
  
  const img = new Image();
  img.onerror = (e) => {
    console.error("이미지 로드 실패:", e);
    alert("이미지를 불러올 수 없습니다. 파일 형식을 확인해주세요.");
  };
  
  img.onload = async () => {
    console.log("이미지 로드 완료:", imgKey, "naturalWidth:", img.naturalWidth, "naturalHeight:", img.naturalHeight);
    
    // 기존 이미지가 있으면 메모리 정리 (orientation별로)
    const existingImg = targetSession[imgKey];
    if(existingImg && existingImg.src && existingImg.src.startsWith('blob:')) {
      URL.revokeObjectURL(existingImg.src);
    }
    
    // 새 이미지로 교체 (orientation별로 저장)
    targetSession[imgKey] = img;
    
    // 원본 크기 초기화 (새 이미지를 로드하므로 다시 계산)
    originalCanvasSize.width = 0;
    originalCanvasSize.height = 0;
    originalCanvasSize.styleWidth = 0;
    originalCanvasSize.styleHeight = 0;
    
    // 캔버스 크기 조정
    resizeCanvasFor(img);
    
    // 이미지 그리기 (약간의 지연을 두어 캔버스가 준비될 때까지 대기)
    setTimeout(() => {
      try {
        draw();
        computeMetricsOnly(); // 이미지 업로드 시에는 AI 분석 안 함
        console.log("이미지 그리기 완료");
      } catch(err) {
        console.error("이미지 그리기 실패:", err);
        // 재시도
        setTimeout(() => {
          try {
            draw();
            computeMetricsOnly();
          } catch(err2) {
            console.error("이미지 그리기 재시도 실패:", err2);
          }
        }, 200);
      }
    }, 100);
    
    // 포즈 감지 자동 실행 (사용자가 선택한 orientation 우선 사용)
    const prevOrientation = targetSession.poseData?.orientation || guessedOrientation;
    let detectedOrientation = null;
    
    // 사용자가 명시적으로 버튼을 선택한 경우, 그 orientation을 우선 사용
    const userSelectedOrientation = currentButtonOrientation;
    
    if(typeof applyPoseDetection === 'function') {
      try {
        // 사용자가 선택한 orientation을 세션에 먼저 설정 (AI 감지 전에)
        if(userSelectedOrientation && !targetSession.poseData) {
          targetSession.poseData = { orientation: userSelectedOrientation, landmarks: null, orientationMode: "manual" };
        } else if(userSelectedOrientation && targetSession.poseData) {
          targetSession.poseData.orientation = userSelectedOrientation;
          targetSession.poseData.orientationMode = "manual";
        }
        
        const detectionResult = await applyPoseDetection(img, targetSessionName);
        detectedOrientation = detectionResult?.orientation || null;
      } catch(err) {
        console.error("포즈 감지 실패:", err);
      }
    }

    // 사용자가 명시적으로 선택한 orientation이 있으면 그것을 우선 사용
    const finalOrientation = userSelectedOrientation || detectedOrientation || guessedOrientation;
    
    if(finalOrientation) {
      const desiredKey = finalOrientation === "front" ? "imgFront" : "imgSide";
      if(desiredKey !== imgKey) {
        const prevImg = targetSession[desiredKey];
        if(prevImg && prevImg !== img && prevImg.src && prevImg.src.startsWith('blob:')) {
          URL.revokeObjectURL(prevImg.src);
        }
        targetSession[desiredKey] = img;
        if(targetSession[imgKey] === img) {
          targetSession[imgKey] = null;
        }
        imgKey = desiredKey;
      }
      
      if(!targetSession.poseData) {
        targetSession.poseData = { orientation: finalOrientation, landmarks: null, orientationMode: userSelectedOrientation ? "manual" : "auto" };
      }
      targetSession.poseData.orientation = finalOrientation;
      targetSession.poseData.orientationMode = userSelectedOrientation ? "manual" : "auto";
      
      if(targetSessionName === cur) {
        if(prevOrientation !== finalOrientation) {
          setOrientation(finalOrientation);
        } else {
          draw();
        }
        try {
          computeAll();
        } catch(errCompute) {
          console.warn("computeAll 실행 실패, 기본 지표만 갱신:", errCompute);
          computeMetricsOnly();
        }
      }
    }
  };
  
  img.crossOrigin = "anonymous";
  const blobUrl = URL.createObjectURL(f);
  img.src = blobUrl;
  
  // 파일 입력 초기화 (같은 파일 다시 선택 가능하도록)
  e.target.value = '';
}

// 업로드 (Before/After 각각 하나의 사진만 유지) - DOM 준비 후 실행
function setupFileUploads() {
  ["filePicker","cameraPicker"].forEach(id => {
    const input = document.getElementById(id);
    if(!input) {
      console.warn(`파일 입력 요소를 찾을 수 없습니다: ${id}`);
      return;
    }
    
    // 모바일에서 label 클릭 시 input 클릭 트리거
    const label = input.closest('label.btn');
    if(label) {
      // 기존 이벤트 제거를 위해 새로 생성
      const newLabel = label.cloneNode(true);
      label.parentNode.replaceChild(newLabel, label);
      const newInput = newLabel.querySelector('input');
      
      if(!newInput) {
        console.warn(`input 요소를 찾을 수 없습니다: ${id}`);
        return;
      }
      
      // input에 직접 change 이벤트 처리
      newInput.addEventListener("change", handleFileUpload);
      
      // input에 직접 터치/클릭 이벤트는 기본 동작을 사용하므로 추가 처리 불필요
      // (input이 직접 클릭/터치되면 자동으로 파일 선택 다이얼로그가 열림)
      
      // 모바일에서 더 확실하게 작동하도록 여러 이벤트 처리
      let touchStarted = false;
      let touchMoved = false;
      
      // touchstart: 터치 시작
      newLabel.addEventListener('touchstart', (e) => {
        // input이 직접 터치된 경우는 제외
        if(e.target === newInput || e.target.closest('input') === newInput) {
          return;
        }
        console.log('Label 터치 시작:', id);
        touchStarted = true;
        touchMoved = false;
      }, { passive: true });
      
      // touchmove: 터치 이동 감지
      newLabel.addEventListener('touchmove', (e) => {
        if(touchStarted) {
          touchMoved = true;
        }
      }, { passive: true });
      
      // touchend: 터치 종료 시 input 클릭
      newLabel.addEventListener('touchend', (e) => {
        // input이 직접 터치된 경우는 제외
        if(e.target === newInput || e.target.closest('input') === newInput) {
          return;
        }
        
        // 터치가 이동했으면 클릭으로 간주하지 않음
        if(touchMoved) {
          touchStarted = false;
          touchMoved = false;
          return;
        }
        
        if(touchStarted) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          
          console.log('Label 터치 종료, input 클릭 시도:', id);
          
          // 즉시 input 클릭 (모바일에서 더 확실하게 작동)
          // requestAnimationFrame을 사용하여 브라우저 렌더링 사이클에 맞춤
          requestAnimationFrame(() => {
            try {
              // input을 포커스하고 클릭
              newInput.focus();
              // 약간의 지연을 두고 클릭 (모바일에서 더 확실하게 작동)
              setTimeout(() => {
                try {
                  newInput.click();
                  console.log('Input 클릭 성공:', id);
                } catch(err) {
                  console.error('Input click failed:', err);
                  // 폴백: 직접 파일 선택 다이얼로그 열기 시도
                  try {
                    const event = new MouseEvent('click', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                    });
                    newInput.dispatchEvent(event);
                  } catch(err2) {
                    console.error('Input dispatchEvent failed:', err2);
                  }
                }
              }, 50);
            } catch(err) {
              console.error('Input focus failed:', err);
            }
          });
          
          touchStarted = false;
          touchMoved = false;
        }
      }, { passive: false });
      
      // click 이벤트 처리 (데스크톱 및 일부 모바일)
      // 데스크탑에서는 label의 기본 동작을 신뢰하고, 모바일에서만 추가 처리
      const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      newLabel.addEventListener('click', (e) => {
        // input이 직접 클릭된 경우는 제외 (기본 동작 사용)
        if(e.target === newInput || e.target.closest('input') === newInput) {
          return;
        }
        
        // 모바일에서 터치 이벤트로 이미 처리된 경우는 제외
        if(isMobile && touchStarted) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        
        // 데스크탑에서는 label의 기본 동작을 신뢰 (for 속성으로 자동 연결됨)
        // 모바일에서만 프로그래밍 방식으로 클릭
        if(isMobile) {
          e.preventDefault();
          e.stopPropagation();
          
          // requestAnimationFrame을 사용하여 브라우저 렌더링 사이클에 맞춤
          requestAnimationFrame(() => {
            try {
              newInput.focus();
              newInput.click();
              console.log('Input 클릭 성공 (모바일):', id);
            } catch(err) {
              console.error('Input click failed:', err);
            }
          });
        }
        // 데스크탑에서는 기본 동작을 그대로 사용 (label의 for 속성이 자동으로 input을 클릭함)
      }, { passive: false });
      
      // mousedown은 처리하지 않음 (데스크탑에서 기본 동작 사용)
    } else {
      // label이 없는 경우 (하위 호환성)
      const newInput = input.cloneNode(true);
      input.parentNode.replaceChild(newInput, input);
      newInput.addEventListener("change", handleFileUpload);
    }
  });
}

// DOM 준비 후 파일 업로드 설정
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupFileUploads);
} else {
  setupFileUploads();
}

// Reset 버튼 (안전한 초기화)
function setupResetButton() {
  const btnReset = document.getElementById("btnReset");
  if(!btnReset) {
    console.warn("Reset 버튼을 찾을 수 없습니다.");
    return;
  }
  addMobileTouchSupport(btnReset, () => {
    const orientation = sessions[cur].poseData?.orientation || "side";
    const currentPoints = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
    currentPoints.clear();
    draw();
    computeMetricsOnly(); // 리셋 시에는 AI 분석 안 함
  });
}

// DOM 준비 후 Reset 버튼 설정
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupResetButton);
} else {
  setupResetButton();
}

// ✅ 캘리브레이션 기능
let calibrationMode = false;
function setupCalibrateButton() {
  const btnCalibrate = document.getElementById("btnCalibrate");
  if(!btnCalibrate) {
    console.warn("캘리브레이션 버튼을 찾을 수 없습니다.");
    return;
  }
  addMobileTouchSupport(btnCalibrate, () => {
    calibrationMode = !calibrationMode;
    const panel = document.getElementById("calibrationPanel");
    const S = sessions[cur];
    
    if(calibrationMode) {
      panel.style.display = "block";
      // 세션에 캘리브레이션 점 저장
      S.calibrationPoint1 = null;
      S.calibrationPoint2 = null;
      document.getElementById("calPoint1").textContent = "클릭하여 선택";
      document.getElementById("calPoint2").textContent = "클릭하여 선택";
      document.getElementById("calibrationResult").textContent = "";
      // 캘리브레이션 모드에서는 클릭 이벤트로 점 선택
      cv.style.cursor = "crosshair";
      draw(); // 초기화
    } else {
      panel.style.display = "none";
      cv.style.cursor = "default";
      calibrationMode = false;
      // 캘리브레이션 점 초기화
      S.calibrationPoint1 = null;
      S.calibrationPoint2 = null;
      draw();
    }
  });
}

// DOM 준비 후 캘리브레이션 버튼 설정
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupCalibrateButton);
} else {
  setupCalibrateButton();
}

// 캘리브레이션 클릭 핸들러 (다른 이벤트와 충돌 방지)
cv.addEventListener('click', (e) => {
  if(!calibrationMode) return;
  
  // 다른 이벤트와 충돌 방지
  e.preventDefault();
  e.stopPropagation();
  e.stopImmediatePropagation();
  
  const pos = getEventPos(e);
  const S = sessions[cur];
  
  if(!S.calibrationPoint1) {
    // 점 1 저장
    S.calibrationPoint1 = pos;
    document.getElementById("calPoint1").textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    draw(); // 점이 영구적으로 표시됨
    console.log('캘리브레이션 점 1:', pos);
  } else if(!S.calibrationPoint2) {
    // 점 2 저장
    S.calibrationPoint2 = pos;
    document.getElementById("calPoint2").textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    draw(); // 점과 선이 영구적으로 표시됨
    console.log('캘리브레이션 점 2:', pos);
    
    // 두 점 사이 거리 계산해서 미리보기 표시
    if(S.calibrationPoint1 && S.calibrationPoint2) {
      const distPx = dist(S.calibrationPoint1, S.calibrationPoint2);
      document.getElementById("calibrationResult").textContent = 
        `거리: ${distPx.toFixed(1)}px (실제 길이 입력 후 계산 버튼 클릭)`;
      document.getElementById("calibrationResult").style.color = "var(--muted)";
    }
  } else {
    // 두 점 모두 선택되었으면 다시 시작
    S.calibrationPoint1 = pos;
    S.calibrationPoint2 = null;
    document.getElementById("calPoint1").textContent = `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
    document.getElementById("calPoint2").textContent = "클릭하여 선택";
    document.getElementById("calibrationResult").textContent = "";
    draw();
    console.log('캘리브레이션 재시작 - 점 1:', pos);
  }
}, true); // capture phase에서 먼저 처리

// 캘리브레이션 관련 버튼들 초기화
function setupCalibrationButtons() {
  const btnConfirm = document.getElementById("btnCalibrateConfirm");
  const btnCancel = document.getElementById("btnCalibrateCancel");
  const btnSaveJSON = document.getElementById("btnSaveJSON");
  const btnLoadJSON = document.getElementById("btnLoadJSON");
  
  if(btnConfirm) {
    addMobileTouchSupport(btnConfirm, () => {
      const S = sessions[cur];
      if(!S.calibrationPoint1 || !S.calibrationPoint2) {
        alert("두 점을 모두 선택해주세요.");
        return;
      }
      
      const realLengthCm = parseFloat(document.getElementById("calibrationLength").value);
      if(!realLengthCm || realLengthCm <= 0) {
        alert("실제 길이(cm)를 올바르게 입력해주세요.");
        return;
      }
      
      try {
        const pxPerCm = calibratePxPerCm(S.calibrationPoint1, S.calibrationPoint2, realLengthCm);
        S.pxPerCm = pxPerCm;
        document.getElementById("calibrationResult").textContent = 
          `✅ 캘리브레이션 완료: ${pxPerCm.toFixed(2)} px/cm`;
        document.getElementById("calibrationResult").style.color = "#2ec4b6";
        
        // 메트릭 재계산
        computeMetricsOnly();
        
        console.log(`캘리브레이션: ${pxPerCm.toFixed(2)} px/cm`);
      } catch(err) {
        alert("캘리브레이션 오류: " + err.message);
      }
    });
  }
  
  if(btnCancel) {
    addMobileTouchSupport(btnCancel, () => {
      calibrationMode = false;
      document.getElementById("calibrationPanel").style.display = "none";
      const S = sessions[cur];
      S.calibrationPoint1 = null;
      S.calibrationPoint2 = null;
      cv.style.cursor = "default";
      draw();
    });
  }
  
  if(btnSaveJSON) {
    btnSaveJSON.onclick = () => {
      // 저장 전에 AI 분석 실행
      computeAll();
      
      const orientation = sessions[cur].poseData?.orientation || "side";
      const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
      const obj = Object.fromEntries(map);
      const json = JSON.stringify(obj, null, 2);
      const blob = new Blob([json], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `posture_coords_${cur}_${orientation}_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    };
  }
  
  if(btnLoadJSON) {
    btnLoadJSON.onclick = () => {
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.accept = 'application/json';
      inp.onchange = e => {
        const f = e.target.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = () => {
          try {
            const obj = JSON.parse(r.result);
            const orientation = sessions[cur].poseData?.orientation || "side";
            const map = orientation === "front" ? sessions[cur].frontPoints : sessions[cur].sidePoints;
            map.clear();
            for(const k of Object.keys(obj)) map.set(k, obj[k]);
            draw();
            computeAll();
          } catch(err) {
            alert('JSON 파싱 실패: ' + err.message);
          }
        };
        r.readAsText(f);
      };
      inp.click();
    };
  }
}

// DOM 준비 후 캘리브레이션 관련 버튼들 설정
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupCalibrationButtons);
} else {
  setupCalibrationButtons();
}

// Before-After 오버레이 이미지 생성 (Canvas API 사용)
// 스켈레톤 그리기 함수 (Before-After 오버레이용)
function drawSkeleton(ctx, points, color, labelPrefix, isDashed = false) {
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;
  ctx.globalAlpha = isDashed ? 0.9 : 0.8;
  ctx.setLineDash(isDashed ? [6, 4] : []);
  
  // 키포인트 순서 정의 (측면)
  const keyOrder = ['tragus', 'c7', 'acromion', 'hip', 'knee', 'ankle'];
  
  // 키포인트 간 선 그리기
  for(let i = 0; i < keyOrder.length - 1; i++) {
    const key1 = keyOrder[i];
    const key2 = keyOrder[i + 1];
    const p1 = points[key1];
    const p2 = points[key2];
    
    if(p1 && p2 && p1.x != null && p1.y != null && p2.x != null && p2.y != null) {
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }
  }
  
  // ASIS-PSIS 연결 (골반)
  if(points.asis && points.psis) {
    ctx.beginPath();
    ctx.moveTo(points.asis.x, points.asis.y);
    ctx.lineTo(points.psis.x, points.psis.y);
    ctx.stroke();
  }
  
  ctx.setLineDash([]);
  
  // 각 키포인트에 점과 라벨 그리기
  Object.keys(points).forEach(key => {
    const p = points[key];
    if(!p || p.x == null || p.y == null) return;
    
    // 점 그리기
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    // 라벨 그리기
    ctx.font = '13px Arial';
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.strokeText(`${labelPrefix}:${key}`, p.x + 12, p.y);
    ctx.fillText(`${labelPrefix}:${key}`, p.x + 12, p.y);
  });
  
  ctx.globalAlpha = 1.0;
}

// Before-After 오버레이 이미지 생성 (스켈레톤 포함)
async function createOverlayImageWithSkeleton(beforeImgData, afterImgData, beforePoints, afterPoints, alpha = 0.5) {
  return new Promise((resolve, reject) => {
    try {
      const beforeImg = new Image();
      const afterImg = new Image();
      
      beforeImg.onload = () => {
        afterImg.onload = () => {
          // 캔버스 생성
          const overlayCanvas = document.createElement('canvas');
          const overlayCtx = overlayCanvas.getContext('2d');
          
          // 크기 설정 (더 큰 이미지 기준)
          const width = Math.max(beforeImg.width, afterImg.width);
          const height = Math.max(beforeImg.height, afterImg.height);
          overlayCanvas.width = width;
          overlayCanvas.height = height;
          
          // 배경 이미지 그리기 (Before 이미지 사용)
          overlayCtx.drawImage(beforeImg, 0, 0, width, height);
          
          // Before 스켈레톤 그리기 (파란색, 점선)
          if(beforePoints) {
            // 이미지 크기에 맞게 좌표 스케일링
            const scaleX = width / beforeImg.width;
            const scaleY = height / beforeImg.height;
            const scaledBeforePoints = {};
            Object.keys(beforePoints).forEach(key => {
              if(beforePoints[key] && beforePoints[key].x != null && beforePoints[key].y != null) {
                scaledBeforePoints[key] = {
                  x: beforePoints[key].x * scaleX,
                  y: beforePoints[key].y * scaleY
                };
              }
            });
            drawSkeleton(overlayCtx, scaledBeforePoints, '#2E86C1', 'B', true);
          }
          
          // After 이미지 오버레이 (주황색 톤, 투명도 적용)
          overlayCtx.globalCompositeOperation = 'source-over';
          overlayCtx.globalAlpha = alpha;
          
          // After 이미지를 주황색 톤으로 변환
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(afterImg, 0, 0, width, height);
          
          const afterImageData = tempCtx.getImageData(0, 0, width, height);
          for(let i = 0; i < afterImageData.data.length; i += 4) {
            afterImageData.data[i] = Math.min(255, afterImageData.data[i] * 1.3); // R 증가 (주황색 톤)
            afterImageData.data[i + 1] = Math.min(255, afterImageData.data[i + 1] * 1.1); // G 증가
            afterImageData.data[i + 2] = Math.min(255, afterImageData.data[i + 2] * 0.7); // B 감소
          }
          tempCtx.putImageData(afterImageData, 0, 0);
          
          overlayCtx.drawImage(tempCanvas, 0, 0);
          overlayCtx.globalAlpha = 1.0;
          
          // After 스켈레톤 그리기 (주황색, 실선)
          if(afterPoints) {
            const scaleX = width / afterImg.width;
            const scaleY = height / afterImg.height;
            const scaledAfterPoints = {};
            Object.keys(afterPoints).forEach(key => {
              if(afterPoints[key] && afterPoints[key].x != null && afterPoints[key].y != null) {
                scaledAfterPoints[key] = {
                  x: afterPoints[key].x * scaleX,
                  y: afterPoints[key].y * scaleY
                };
              }
            });
            drawSkeleton(overlayCtx, scaledAfterPoints, '#E67E22', 'A', false);
          }
          
          resolve(overlayCanvas.toDataURL('image/png'));
        };
        afterImg.onerror = reject;
        afterImg.src = afterImgData;
      };
      beforeImg.onerror = reject;
      beforeImg.src = beforeImgData;
    } catch(err) {
      reject(err);
    }
  });
}

// 기존 함수 유지 (하위 호환성)
async function createOverlayImage(beforeImgData, afterImgData, alpha = 0.5) {
  return new Promise((resolve, reject) => {
    try {
      const beforeImg = new Image();
      const afterImg = new Image();
      
      beforeImg.onload = () => {
        afterImg.onload = () => {
          // 캔버스 생성
          const overlayCanvas = document.createElement('canvas');
          const overlayCtx = overlayCanvas.getContext('2d');
          
          // 크기 설정 (더 큰 이미지 기준)
          const width = Math.max(beforeImg.width, afterImg.width);
          const height = Math.max(beforeImg.height, afterImg.height);
          overlayCanvas.width = width;
          overlayCanvas.height = height;
          
          // Before 이미지 그리기 (파란색 톤)
          overlayCtx.globalCompositeOperation = 'source-over';
          overlayCtx.drawImage(beforeImg, 0, 0, width, height);
          
          // 파란색 필터 적용
          const beforeImageData = overlayCtx.getImageData(0, 0, width, height);
          for(let i = 0; i < beforeImageData.data.length; i += 4) {
            beforeImageData.data[i] = Math.min(255, beforeImageData.data[i] * 0.7 + 50); // R 증가 (파란색 톤)
            beforeImageData.data[i + 1] = Math.min(255, beforeImageData.data[i + 1] * 0.8 + 30); // G 증가
            beforeImageData.data[i + 2] = Math.min(255, beforeImageData.data[i + 2] * 1.2); // B 증가
          }
          overlayCtx.putImageData(beforeImageData, 0, 0);
          
          // After 이미지 그리기 (주황색 톤, 투명도 적용)
          overlayCtx.globalCompositeOperation = 'source-over';
          overlayCtx.globalAlpha = alpha;
          
          // After 이미지를 주황색 톤으로 변환
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.drawImage(afterImg, 0, 0, width, height);
          
          const afterImageData = tempCtx.getImageData(0, 0, width, height);
          for(let i = 0; i < afterImageData.data.length; i += 4) {
            afterImageData.data[i] = Math.min(255, afterImageData.data[i] * 1.3); // R 증가 (주황색 톤)
            afterImageData.data[i + 1] = Math.min(255, afterImageData.data[i + 1] * 1.1); // G 증가
            afterImageData.data[i + 2] = Math.min(255, afterImageData.data[i + 2] * 0.7); // B 감소
          }
          tempCtx.putImageData(afterImageData, 0, 0);
          
          overlayCtx.drawImage(tempCanvas, 0, 0);
          overlayCtx.globalAlpha = 1.0;
          
          resolve(overlayCanvas.toDataURL('image/png'));
        };
        afterImg.onerror = reject;
        afterImg.src = afterImgData;
      };
      beforeImg.onerror = reject;
      beforeImg.src = beforeImgData;
    } catch(err) {
      reject(err);
    }
  });
}

// 안전한 랜드마크 매핑 함수 (재시도 로직 포함)
async function getMappedKeypoints(session, orientation = 'side', maxRetries = 10) {
  // 1) 포즈 데이터 소스 유연하게 탐색
  const pose = session?.poseData || session?.sidePose || session?.frontPose || {};
  let raw = Array.isArray(pose.landmarks) ? pose.landmarks : [];
  
  // 2) 추론이 아직이면 짧게 재시도
  if (!raw || !raw.length) {
    for (let i = 0; i < maxRetries; i++) {
      await new Promise(r => setTimeout(r, 100));
      const retry = session?.poseData?.landmarks || session?.sidePose?.landmarks || session?.frontPose?.landmarks || [];
      if (retry && retry.length > 0) {
        raw = retry;
        break;
      }
    }
  }
  
  // 3) 여전히 비어있으면 null 반환
  if (!raw || !raw.length) {
    console.warn('⚠️ landmarks empty. fallback to manual points only.');
    return null;
  }
  
  // 4) 정상 매핑
  try {
    return mapPoseToKeypoints({ keypoints: raw }, orientation);
  } catch(err) {
    console.warn('랜드마크 매핑 실패:', err);
    return null;
  }
}

// Confidence Heatmap 생성 (안전 버전 - 개선)
async function createConfidenceHeatmap(imgData, sessionName, orientation = 'side') {
  return new Promise((resolve, reject) => {
    try {
      const img = new Image();
      img.onload = async () => {
        try {
          const session = sessions?.[sessionName];
          if(!session) {
            console.warn(`세션 ${sessionName}을 찾을 수 없음`);
            resolve({ heatmapImage: imgData, avgConfidence: 0.8 });
            return;
          }
          
          const heatmapCanvas = document.createElement('canvas');
          const heatmapCtx = heatmapCanvas.getContext('2d');
          if(!heatmapCtx) {
            throw new Error('Canvas context를 가져올 수 없습니다.');
          }
          
          heatmapCanvas.width = img.width;
          heatmapCanvas.height = img.height;
          
          // 원본 이미지 그리기
          heatmapCtx.drawImage(img, 0, 0);
          
          // 키포인트 가져오기
          const points = orientation === 'front' ? session.frontPoints : session.sidePoints;
          
          // 안전한 랜드마크 매핑 (재시도 포함)
          const MIN_CONF = 0.6;
          const mapped = await getMappedKeypoints(session, orientation);
          
          // 평균 confidence 계산
          let totalConfidence = 0;
          let validCount = 0;
          
          if(mapped) {
            Object.values(mapped).forEach(point => {
              if(point && point.score != null && point.score >= MIN_CONF) {
                totalConfidence += point.score;
                validCount++;
              }
            });
          }
          
          const avgConfidence = validCount > 0 ? totalConfidence / validCount : 0.8;
          
          // 각 키포인트에 confidence 기반 색상 적용
          points.forEach((point, key) => {
            if(!point || point.x == null || point.y == null) return;
            
            // landmarks에서 confidence 찾기
            let confidence = 0.8; // 기본값
            try {
              if(mapped && mapped[key] && mapped[key].score != null) {
                const score = mapped[key].score;
                // 최소 신뢰도 미만은 제외
                if(score >= MIN_CONF) {
                  confidence = score;
                }
              }
            } catch(err) {
              console.warn(`키포인트 ${key} confidence 계산 실패:`, err);
              confidence = 0.8;
            }
            
            // Confidence 기반 색상 계산 (안전한 방식)
            // 높음(1.0): 빨강, 중간(0.5): 노랑, 낮음(0.0): 파랑
            const r = Math.floor(255 * confidence);
            const g = Math.floor(150 * confidence);
            const b = Math.floor(255 * (1 - confidence));
            const alpha = 0.4 + 0.3 * confidence;
            
            // 원 그리기
            heatmapCtx.beginPath();
            heatmapCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            heatmapCtx.arc(point.x, point.y, 13, 0, Math.PI * 2);
            heatmapCtx.fill();
            
            // 라벨 (안전한 폰트 사용)
            heatmapCtx.font = '10px helvetica';
            heatmapCtx.fillStyle = '#fff';
            heatmapCtx.fillText(key, point.x + 15, point.y - 6);
            heatmapCtx.fillText(`${(confidence * 100).toFixed(0)}%`, point.x + 15, point.y + 9);
          });
          
          // 평균 신뢰도 표시
          heatmapCtx.fillStyle = '#ffffffcc';
          heatmapCtx.font = '14px helvetica';
          heatmapCtx.fillText(`AI 평균 신뢰도: ${(avgConfidence * 100).toFixed(1)}%`, 20, 25);
          
          resolve({ 
            heatmapImage: heatmapCanvas.toDataURL('image/png'), 
            avgConfidence: avgConfidence 
          });
        } catch(err) {
          console.error('Heatmap 생성 중 오류:', err);
          // 오류 발생 시 원본 이미지 반환
          resolve({ heatmapImage: imgData, avgConfidence: 0.8 });
        }
      };
      img.onerror = (err) => {
        console.error('이미지 로드 실패:', err);
        reject(new Error('이미지를 로드할 수 없습니다.'));
      };
      img.src = imgData;
    } catch(err) {
      console.error('Heatmap 생성 초기화 실패:', err);
      reject(err);
    }
  });
}

// ========== 필라테스 추천 및 AI 심층 분석 함수 ==========

// 안전 유틸
const getMetricValue = (m, k, d = null) => {
  if(!m) return d;
  const metric = m[k];
  if(!metric) return d;
  // {before, after} 형태 또는 단일 값
  if(metric.after != null) return metric.after;
  if(metric.before != null) return metric.before;
  if(typeof metric === 'number') return metric;
  if(metric.value != null) return metric.value;
  return d;
};

// 정상범위 기준
const NORMAL_RANGE = {
  CVA: v => v >= 50,          // 두개경추각
  HPD: v => v <= 2,           // 두부 전방이동 (cm)
  TIA: v => v >= 0 && v <= 10, // 체간경사
  SAA: v => v >= 0 && v <= 10, // 어깨 전방각
  PTA: v => v >= 0 && v <= 15, // 골반 전후경사
  KA:  v => v >= 175 && v <= 185, // 무릎각
  Tibial_Angle: v => v >= 0 && v <= 10, // 경골경사
  GSB: v => v <= 2,           // 중력중심선(cm)
  HPA: v => v >= 0 && v <= 10,  // Head–Pelvis Angle
};

// 패턴 판정 (After 우선, 없으면 단일 값)
function detectPatterns(metrics) {
  const v = k => getMetricValue(metrics, k);
  const pat = [];

  // 거북목(FHP): CVA 낮음(정상 미만)
  if (v('CVA') != null && !NORMAL_RANGE.CVA(v('CVA'))) pat.push('FHP');

  // 라운드 숄더: SAA↑
  if (v('SAA') != null && !NORMAL_RANGE.SAA(v('SAA'))) pat.push('RSP');

  // 골반 과전경사/후경사: PTA 기준
  if (v('PTA') != null) {
    if (v('PTA') > 15) pat.push('ANT_TILT');
    else if (v('PTA') < 5) pat.push('POST_TILT');
  }

  // 하지 정렬: KA
  if (v('KA') != null) {
    if (v('KA') < 175) pat.push('VALGUS');
    if (v('KA') > 185) pat.push('VARUS');
  }

  // 체중 전/후방 이동: GSB
  if (v('GSB') != null) {
    if (v('GSB') > 2) pat.push('FORWARD_COG');
  }

  return [...new Set(pat)];
}

// 필라테스 데이터베이스 (기존 패턴 DB - 하위 호환성 유지)
const PILATES_PATTERN_DB = {
  FHP: {
    title: '거북목(Forward Head Posture)',
    tight: ['SCM(흉쇄유돌근)', '상부승모', '견갑거근', '소흉근'],
    weak:  ['심부경부굴근', '하부승모', '전거근'],
    moves: {
      Mat: [
        { name: 'Chin Tuck & Axial Elongation (턱당기기+축신장)', goal: '경추 정렬·안정화',
          easy: '벽에 뒤통수 살짝 대고, 턱을 가볍게 당겨 목을 길게. 5초 유지×8~10회.' },
        { name: 'Swan Prep', goal: '흉추 신전, 견갑 안정',
          easy: '엎드려 가슴만 살짝 들어 올리며 긴 호흡. 허리 꺾지 말고 6~8회.' },
      ],
      Reformer: [
        { name: 'Pulling Straps', goal: '견갑 후방 안정화',
          easy: '엎드려 스트랩 당기며 어깨를 아래뒤로. 목은 길게 8~10회.' },
      ],
      Cadillac: [
        { name: 'Tower Swan', goal: '흉추 신전+견갑 후방',
          easy: '푸시스루바 잡고 복부 당긴 채 가슴을 길게 열기 6~8회.' },
      ],
      Chair: [
        { name: 'Press Down Front', goal: '전거근/하부승모 활성',
          easy: '스프링 페달 앞에서 팔로 살짝 눌러 어깨를 아래로 고정 8~10회.' },
      ],
      Barrel: [
        { name: 'Swan on Ladder Barrel', goal: '흉추 가동성',
          easy: '가슴을 배럴 위에 두고 천천히 신전·복귀 6~8회.' },
      ],
    }
  },
  RSP: {
    title: '라운드 숄더(Rounded Shoulder)',
    tight: ['대흉근', '소흉근', '상부승모'],
    weak:  ['하부승모', '능형근', '전거근'],
    moves: {
      Mat: [
        { name: 'Prone Scapular Retraction', goal: '견갑 후인',
          easy: '엎드려 날개뼈를 뒤로 모으고 아래로 8~12회.' },
      ],
      Reformer: [
        { name: 'Rowing Back / Pulling Straps', goal: '견갑 안정',
          easy: '가슴 활짝 열며 스트랩 뒤로 당기기 8~10회.' },
      ],
      Cadillac: [
        { name: 'Arm Springs - Extension', goal: '어깨 후방 근육 강화',
          easy: '팔 뒤로 뻗으며 어깨는 아래 고정 8~12회.' },
      ],
      Chair: [
        { name: 'Spine Stretch (Chair ver.)', goal: '흉추 신전·견갑 안정',
          easy: '등을 길게 만들며 페달 살짝 누르기 6~8회.' },
      ],
      Barrel: [
        { name: 'Shoulder Extension on Barrel', goal: '어깨 후인·흉추 가동성',
          easy: '배럴에서 팔을 뒤로 뻗고 가슴 열기 6~8회.' },
      ],
    }
  },
  ANT_TILT: {
    title: '골반 과전경사(Anterior Tilt)',
    tight: ['장요근', '대퇴직근', '척추기립근'],
    weak:  ['복직근/복횡근', '둔근'],
    moves: {
      Mat: [
        { name: 'Pelvic Curl', goal: '후방경사 유도',
          easy: '무릎 굽혀 누워 골반을 말아 올려 8~10회.' },
        { name: 'Dead Bug / Toe Tap', goal: '복횡근 활성',
          easy: '허리 뜨지 않게, 다리 번갈아 낮추기 8~10회.' },
      ],
      Reformer: [
        { name: 'Bridge on Reformer', goal: '후방 사슬 강화',
          easy: '발바닥 고정, 엉덩이 올려 척추 말아 올리기 8회.' },
      ],
      Cadillac: [
        { name: 'Roll Down (Push Through Bar)', goal: '코어 조절',
          easy: '갈비를 안쪽으로, 등 말아 내렸다 올라오기 6~8회.' },
      ],
      Chair: [
        { name: 'Standing Hip Extension', goal: '둔근 강화',
          easy: '몸통 고정, 다리 뒤로 뻗기 8~12회.' },
      ],
      Barrel: [
        { name: 'Short Box - Round Back', goal: '코어·후방사슬',
          easy: '복부 당기고 등 둥글게 낮췄다 복귀 6~8회.' },
      ],
    }
  },
  POST_TILT: {
    title: '골반 후경사(Posterior Tilt)',
    tight: ['햄스트링', '복직근'],
    weak:  ['장요근', '대퇴직근', '척추기립근'],
    moves: {
      Mat: [
        { name: 'Leg Pull Front', goal: '전방 사슬 강화',
          easy: '플랭크 자세에서 몸통 길게 20~30초×3.' },
      ],
      Reformer: [
        { name: 'Footwork - Parallel Heels', goal: '고관절 신전',
          easy: '무릎-발끝 정렬 유지해 밀기 10~12회.' },
      ],
      Cadillac: [
        { name: 'Leg Springs - Supine', goal: '장요근 기능적 수축',
          easy: '골반 고정, 다리 들어 올렸다 내리기 8~10회.' },
      ],
      Chair: [
        { name: 'Swan Press', goal: '요추 신전 강화',
          easy: '가슴을 길게, 허리 꺾지 않기 6~8회.' },
      ],
      Barrel: [
        { name: 'Swan on Barrel', goal: '요추/흉추 가동성',
          easy: '편안한 범위만큼 신전 6~8회.' },
      ],
    }
  },
  VALGUS: {
    title: 'X자 다리(Genu Valgum)',
    tight: ['내전근', '내측광근'],
    weak:  ['중둔근', '외회전근', '외측광근'],
    moves: {
      Mat: [
        { name: 'Side-Lying Leg Lift', goal: '중둔근 강화',
          easy: '옆으로 누워 위쪽 다리 들어 올리기 10~12회.' },
      ],
      Reformer: [
        { name: 'Side Splits', goal: '하지 외측 안정',
          easy: '골반 수평 유지하며 벌리고 모으기 8~10회.' },
      ],
      Cadillac: [
        { name: 'Standing Hip Abduction', goal: '고관절 외전',
          easy: '몸통 고정, 옆으로 차 올리기 8~10회.' },
      ],
      Chair: [
        { name: 'Step Up Lateral', goal: '외측 안정',
          easy: '의자 옆으로 올라갔다 내려오기 8회.' },
      ],
      Barrel: [
        { name: 'Side Bend Stretch', goal: '측면 가동성',
          easy: '몸통 길게 늘이며 옆굽힘 6회.' },
      ],
    }
  },
  VARUS: {
    title: 'O자 다리(Genu Varum)',
    tight: ['외측광근', '비복근', '대퇴이두'],
    weak:  ['내전근', '내측광근'],
    moves: {
      Mat: [
        { name: 'Ball Squeeze Bridge', goal: '내전근 활성',
          easy: '무릎 사이 볼 끼고 브릿지 8~10회.' },
      ],
      Reformer: [
        { name: 'Footwork - Small V', goal: '내측광근 강화',
          easy: '작은 V, 무릎 모아 밀기 10~12회.' },
      ],
      Cadillac: [
        { name: 'Standing Leg Press - Adduction', goal: '내전근 강화',
          easy: '스트랩으로 다리 안쪽으로 당기기 8~10회.' },
      ],
      Chair: [
        { name: 'Seated Adduction', goal: '내측 조절',
          easy: '밴드/스프링으로 무릎 모으기 8~12회.' },
      ],
      Barrel: [
        { name: 'Adductor Stretch on Barrel', goal: '내전근 신장',
          easy: '편안한 범위로 20초 유지×3.' },
      ],
    }
  },
  FORWARD_COG: {
    title: '체중 중심 전방(Forward Center)',
    tight: ['대퇴직근', '요추기립근', '종아리'],
    weak:  ['둔근', '햄스트링', '복부'],
    moves: {
      Mat: [
        { name: 'Pelvic Curl', goal: '둔근/햄스트링 활성',
          easy: '천천히 말아 올려 8~10회.' },
      ],
      Reformer: [
        { name: 'Scooter', goal: '둔근 신전 조절',
          easy: '몸통 고정, 뒷다리 페달 살짝 밀기 8~12회.' },
      ],
      Cadillac: [
        { name: 'Tower Roll Up', goal: '코어 활성',
          easy: '발바닥 바에 두고 말아 올라가기 6~8회.' },
      ],
      Chair: [
        { name: 'Standing Leg Press', goal: '후방 체중 이동',
          easy: '발로 페달 눌러 엉덩이 뒤로, 무릎 과신전 금지 8~10회.' },
      ],
      Barrel: [
        { name: 'Swan', goal: '흉추 안정',
          easy: '가슴을 길게, 목 길게 6~8회.' },
      ],
    }
  },
};

function buildPilatesTextFromAnalysis(pilatesItems) {
  if (!Array.isArray(pilatesItems) || pilatesItems.length === 0) return '';
  return pilatesItems.map((item, idx) => renderPilatesItemCard(item, { context:'pdf', index: idx, limitPerTool: Infinity })).join('');
}

// 필라테스 추천 텍스트 생성
function generatePilatesSessionText(metrics, pilatesItems = null) {
  const pilatesTextFromAnalysis = buildPilatesTextFromAnalysis(pilatesItems);
  if (pilatesTextFromAnalysis) return pilatesTextFromAnalysis;
  
  const pats = detectPatterns(metrics);
  if (!pats.length) {
    return `<div style="padding:12px; background:#f8f9ff; border-radius:10px; border:1px solid #e0e7ff; font-size:12px; font-family: var(--font-body); color:#111;">
      현재 측정값은 대체로 정상 범위입니다. 기본 코어 안정과 전신 가동성 루틴을 권장합니다.
    </div>`;
  }

  const blocks = pats.map(code => {
    const d = PILATES_PATTERN_DB[code];
    if (!d) return '';
    const tools = ['Mat', 'Reformer', 'Cadillac', 'Chair', 'Barrel'];
    const toolHTML = tools.map(tool => {
      if(!d.moves[tool] || d.moves[tool].length === 0) return '';
      const moves = d.moves[tool].map(m => `<li style="margin-bottom:4px;">${m.name} — ${m.goal}<br><span style="color:#475569;">${m.easy}</span></li>`).join('');
      return `<div style="margin-top:8px;">
        <div style="font-weight:600; color:#5c44b8; font-size:11px;">${tool}</div>
        <ul style="margin:6px 0 0 16px; padding:0; color:#0f172a; font-size:11px;">${moves}</ul>
      </div>`;
    }).join('');
    return `<div style="margin-bottom:12px; padding:12px; background:#f6f3ff; border-radius:12px; border:1px solid #ded3ff; font-family: var(--font-body);">
      <div style="font-weight:700; color:#5c44b8; margin-bottom:6px;">${d.title}</div>
      <div style="font-size:11px; margin-bottom:4px;"><strong style="color:#ff6b6b;">긴장:</strong> ${d.tight.join(', ')}</div>
      <div style="font-size:11px; margin-bottom:6px;"><strong style="color:#7c9cff;">약화:</strong> ${d.weak.join(', ')}</div>
      ${toolHTML}
      <div style="margin-top:8px; font-size:11px; color:#475569;">권장: 통증 0~2/10 범위 유지, 8~12회×2~3세트, 호흡은 "길게 들이쉬고 길게 내쉬기".</div>
    </div>`;
  }).filter(Boolean);

  return blocks.join('');
}

// ✅ AI 심층 분석 생성 (DB 기반 상세 분석)
function generateAIDeepAnalysis(metrics) {
  const g = k => {
    const m = metrics?.[k];
    return {
      before: (m && m.before != null) ? m.before : null,
      after:  (m && m.after != null) ? m.after : (typeof m === 'number' ? m : null)
    };
  };

  const lines = [];
  lines.push('▶ 전신 정렬 종합 소견');
  lines.push('- 본 분석은 머리-어깨-골반-하지의 선형 정렬과 분절 각도를 종합 평가하며, 지표는 임상 정상범위를 기준으로 해석됩니다.');
  lines.push('- 운동 처방은 과사용/저사용 근육의 균형 회복과 신경근 재교육을 목표로 구성되었습니다.\n');

  const seq = [
    { k:'CVA',  name:'CVA(두개경추각)', unit:'°',     fn:NORMAL_RANGE.CVA },
    { k:'HPD',  name:'HPD(두부 전방이동)', unit:'cm',  fn:NORMAL_RANGE.HPD },
    { k:'TIA',  name:'TIA(체간경사각)', unit:'°',      fn:NORMAL_RANGE.TIA },
    { k:'SAA',  name:'SAA(어깨 전방각)', unit:'°',     fn:NORMAL_RANGE.SAA },
    { k:'PTA',  name:'PTA(골반 전후경사)', unit:'°',   fn:NORMAL_RANGE.PTA },
    { k:'KA',   name:'KA(무릎각)', unit:'°',           fn:NORMAL_RANGE.KA },
    { k:'Tibial_Angle', name:'Tibial(경골 경사각)', unit:'°', fn:NORMAL_RANGE.Tibial_Angle },
    { k:'GSB',  name:'GSB(중력중심선 편차)', unit:'cm', fn:NORMAL_RANGE.GSB },
    { k:'HPA',  name:'HPA(머리-골반 각)', unit:'°',    fn:NORMAL_RANGE.HPA },
  ];

  // ✅ DB에서 각 지표별 상세 정보 가져오기
  seq.forEach(s => {
    const {before, after} = g(s.k);
    const currentValue = after != null ? after : before;
    const vStr = x => (x == null ? '-' : `${x.toFixed(2)}${s.unit}`);
    const parts = [];
    parts.push(`- ${s.name}: ${vStr(before)} → ${vStr(after)}`);
    
    // ✅ DB 기반 상세 해석 추가
    if (currentValue != null) {
      // 정상 범위 확인
      if (typeof s.fn === 'function') {
        const ok = s.fn(currentValue);
        parts.push(`  · 해석: ${ok ? '정상 범위' : '정상 범위 이탈'}`);
      }
      
      // DB에서 해당 지표의 상세 정보 가져오기
      const abnormal = classifyAbnormalType(s.k, currentValue, NORMAL_TEXT[s.k] || '');
      const dbItems = POSTURE_DB.filter(r => {
        const dbCode = String(r['지표코드'] || '').toUpperCase();
        const dbAbnormal = String(r['이상유형'] || '');
        return dbCode === s.k.toUpperCase() && dbAbnormal.includes(abnormal);
      });
      
      if(dbItems.length > 0) {
        const dbItem = dbItems[0]; // 첫 번째 매칭 항목 사용
        if(dbItem['원인']) {
          parts.push(`  · 원인: ${dbItem['원인']}`);
        }
        if(dbItem['증상']) {
          parts.push(`  · 증상: ${dbItem['증상']}`);
        }
        if(dbItem['임상적의미']) {
          parts.push(`  · 임상적 의미: ${dbItem['임상적의미']}`);
        }
        if(dbItem['긴장근육(주요)']) {
          parts.push(`  · 긴장된 근육: ${dbItem['긴장근육(주요)']}`);
        }
        if(dbItem['약화근육(주요)']) {
          parts.push(`  · 약화된 근육: ${dbItem['약화근육(주요)']}`);
        }
        if(dbItem['교정운동(도수/자가)']) {
          parts.push(`  · 교정 운동: ${dbItem['교정운동(도수/자가)']}`);
        }
      }
    }
    
    if (before != null && after != null) {
      const d = +(after - before).toFixed(1);
      if (Math.abs(d) >= 0.1) {
        const sign = d > 0 ? '증가' : '감소';
        const improvement = (d < 0 && s.k === 'CVA') || (d > 0 && s.k === 'PTA' && after > 15) ? '악화' : 
                           (d > 0 && s.k === 'CVA') || (d < 0 && s.k === 'PTA' && after > 15) ? '개선' : '변화';
        parts.push(`  · 변화: ${Math.abs(d)}${s.unit} ${sign} (${improvement})`);
      } else {
        parts.push(`  · 변화: 유의미한 변화 없음`);
      }
    }
    lines.push(parts.join('\n'));
  });

  // ✅ 패턴 요약 (DB 기반)
  const pats = detectPatterns(metrics);
  lines.push('\n▶ 패턴 요약');
  if(pats.length) {
    lines.push(`- 관찰된 주요 패턴: ${pats.map(p => PILATES_PATTERN_DB[p]?.title || p).join(', ')}`);
    // 각 패턴별 상세 설명 추가
    pats.forEach(p => {
      const dbItem = POSTURE_DB.find(r => {
        const dbTitle = String(r['지표명'] || '').toLowerCase();
        const patternTitle = (PILATES_PATTERN_DB[p]?.title || p).toLowerCase();
        return dbTitle.includes(patternTitle) || patternTitle.includes(dbTitle);
      });
      if(dbItem) {
        if(dbItem['원인']) lines.push(`  · ${PILATES_PATTERN_DB[p]?.title || p} 원인: ${dbItem['원인']}`);
        if(dbItem['증상']) lines.push(`  · ${PILATES_PATTERN_DB[p]?.title || p} 증상: ${dbItem['증상']}`);
      }
    });
  } else {
    lines.push('- 특이 패턴 없음(기본 안정화 권장)');
  }

  // ✅ 임상적 권고 (상세)
  lines.push('\n▶ 임상적 권고');
  lines.push('- 2~4주 간 주 2~3회, 각 세션 30~45분. 통증 0~2/10 범위 유지.');
  lines.push('- "정렬→가동성→근지구력→기능 통합" 순서로 진행.');
  lines.push('- 일상 자세 팁: 스크린 눈높이 조절, 30~40분마다 30초 리셋 스트레칭, 장시간 서기/앉기 시 골반 중립 체크.');
  lines.push('- 호흡: 운동 중 "길게 들이쉬고 길게 내쉬기"를 유지하여 코어 안정성을 높입니다.');
  lines.push('- 진행 순서: ① 워밍업(5분) → ② 스트레칭(10분) → ③ 강화 운동(20분) → ④ 쿨다운(5분)');
  lines.push('- 주의사항: 통증이 3/10 이상이면 운동을 중단하고 전문가와 상담하세요.');

  return lines.join('\n');
}

function buildPlanTexts({ memberName = '회원', patterns = [], scoreResult = null, analysis = {}, comparisonSummary = '' }) {
  const uniquePatterns = Array.from(new Set((patterns || []).filter(Boolean)));
  const tightHighlight = Array.isArray(analysis?.tight) ? analysis.tight.filter(Boolean).slice(0, 3).join(', ') : '';
  const weakHighlight = Array.isArray(analysis?.weak) ? analysis.weak.filter(Boolean).slice(0, 3).join(', ') : '';
  const quickItems = [];
  if (comparisonSummary) quickItems.push(comparisonSummary);
  if (tightHighlight) quickItems.push(`긴장 근육 이완: ${tightHighlight} 중심으로 폼롤러 · 정적 스트레칭 10~15분`);
  if (weakHighlight) quickItems.push(`약화 근육 활성화: ${weakHighlight} 중심의 코어/둔근 강화 8~12회 × 2~3세트`);
  quickItems.push('필라테스 루틴(다음 페이지)을 주 3회 이상 실행하여 정렬 패턴을 재교육합니다.');
  if (scoreResult?.score != null) {
    if (scoreResult.score < 70) {
      quickItems.push(`체형 점수 ${scoreResult.score}점 → 6주 집중 교정이 필요합니다.`);
    } else if (scoreResult.score < 85) {
      quickItems.push(`체형 점수 ${scoreResult.score}점 → 중기 강도의 근력/가동성 관리가 필요합니다.`);
    } else {
      quickItems.push(`체형 점수 ${scoreResult.score}점 → 현재 정렬을 유지하며 심화 루틴을 진행합니다.`);
    }
  }
  const quickHtml = quickItems.length
    ? `<ul style="margin:0; padding-left:18px; font-size:11px; line-height:1.7; color:#1f2937;">${quickItems.map(item => `<li style="margin-bottom:4px;">${escapeHtml(item)}</li>`).join('')}</ul>`
    : `<div style="font-size:11px; color:#475569;">데이터가 충분하지 않습니다. 자세 측정을 완료한 뒤 다시 생성해주세요.</div>`;

  let fullText = `${memberName}님의 검사 결과와 AI 분석을 종합해보면, 관찰된 주요 패턴은 다음과 같습니다:\n\n`;
  if (uniquePatterns.length > 0) {
    uniquePatterns.forEach((pattern, idx) => {
      fullText += `${idx + 1}. ${pattern}\n`;
    });
  } else {
    fullText += '특이 패턴 없음\n';
  }
  fullText += '\n';
  if (comparisonSummary) {
    fullText += `${comparisonSummary}\n\n`;
  }
  fullText += '위 패턴은 특정 근육군의 긴장(짧아짐)과 약화(약해짐)이 동반되는 전형적인 임상 소견입니다. 아래의 권장사항을 일관되게 6~12주 동안 적용하면 증상 완화와 자세 개선이 기대됩니다.\n\n';
  fullText += '【단기(1~4주)】\n';
  fullText += '1. 긴장 근육 이완 중심(폼롤러, 근막 이완, 정적 스트레칭) — 하루 1회 10~15분\n';
  fullText += '2. 호흡 조절과 함께하는 코어 기본운동 (Dead Bug, Pelvic Tilt) — 매일 5~10분\n';
  fullText += '3. 일상 생활에서의 자세 리셋(30~40분마다) — 습관화\n\n';
  fullText += '【중기(4~8주)】\n';
  fullText += '1. 약화 근육 활성화 (둔근, 복횡근 등) — 주 3회, 점진적 부하\n';
  fullText += '2. 필라테스 기구 운동을 포함한 통합 프로그램 — 주 2~3회\n';
  fullText += '3. 정기 재평가로 프로그램 조정 (3~4주마다)\n\n';
  fullText += '【장기(8~12주 이상)】\n';
  fullText += '통합적 기능 회복을 목표로 일상화 및 운동강도 증진을 권장합니다. 근력, 유연성, 신경근 제어가 모두 개선되면 자세 개선 효과는 장기적으로 유지됩니다.\n\n';
  if (scoreResult?.score != null) {
    const score = scoreResult.score;
    if (score < 70) {
      fullText += `현재 체형 종합 점수가 ${score}점으로 개선이 필요합니다. 위의 단기 권장사항부터 꾸준히 실시하시기 바랍니다.\n\n`;
    } else if (score < 85) {
      fullText += `현재 체형 종합 점수가 ${score}점으로 양호한 편입니다. 중기 권장사항을 중심으로 지속적인 관리가 필요합니다.\n\n`;
    } else {
      fullText += `현재 체형 종합 점수가 ${score}점으로 우수합니다. 장기 권장사항을 통해 현재 상태를 유지하고 더욱 개선하시기 바랍니다.\n\n`;
    }
  }
  fullText += '"우리는 걱정 대신 근거(데이터)로 움직입니다."';

  return {
    quickHtml,
    fullText: fullText.trim()
  };
}

function buildBeforeAfterSummaryHTML(comparison) {
  if (!comparison || !Array.isArray(comparison.results) || comparison.results.length === 0) {
    return '<div style="font-size:11px; color:#475569; line-height:1.6;">Before-After 비교 데이터가 없습니다.</div>';
  }
  const improved = comparison.results.filter(r => r.status === 'improved').length;
  const worsened = comparison.results.filter(r => r.status === 'worsened').length;
  const maintained = comparison.results.filter(r => r.status === 'maintained').length;
  const stats = [
    { label: '개선', value: improved, color: '#16a34a' },
    { label: '유지', value: maintained, color: '#2563eb' },
    { label: '주의', value: worsened, color: '#dc2626' }
  ];
  const statsHtml = `<div style="display:flex; flex-wrap:wrap; gap:8px;">${stats.map(stat => `
    <div style="flex:1 1 90px; min-width:90px; padding:10px; border-radius:10px; background:rgba(0,0,0,0.03); border:1px solid rgba(0,0,0,0.05); text-align:center;">
      <div style="font-size:12px; color:${stat.color}; font-weight:600;">${stat.label}</div>
      <div style="font-size:20px; font-weight:700; color:#0b0f14;">${stat.value}</div>
    </div>`).join('')}</div>`;

  const summaryText = comparison.summary?.overallComment
    ? `<div style="margin-top:12px; font-size:11px; color:#1f2937; line-height:1.6;">${escapeHtml(comparison.summary.overallComment)}</div>`
    : '';

  const topChanges = [...comparison.results]
    .sort((a, b) => Math.abs(b.delta || 0) - Math.abs(a.delta || 0))
    .slice(0, 4)
    .map(item => {
      const decimals = item.unit === '점' ? 2 : 1;
      const before = item.before != null ? item.before.toFixed(decimals) : '-';
      const after = item.after != null ? item.after.toFixed(decimals) : '-';
      const delta = item.delta != null ? `${item.delta >= 0 ? '+' : ''}${item.delta.toFixed(decimals)}${item.unit}` : '';
      const comment = item.comment ? `<div style="color:#475569; margin-top:2px;">${escapeHtml(item.comment)}</div>` : '';
      return `<li style="margin-bottom:6px;"><strong>${escapeHtml(item.name)}</strong> : ${before}${item.unit} → ${after}${item.unit} (${delta})${comment}</li>`;
    });

  const topChangesHtml = topChanges.length
    ? `<div style="margin-top:14px;">
        <div style="font-size:11px; font-weight:600; color:#111827; margin-bottom:6px;">변화 폭이 큰 지표</div>
        <ul style="margin:0; padding-left:18px; font-size:11px; color:#0f172a; line-height:1.5;">${topChanges.join('')}</ul>
      </div>`
    : '';

  return `<div style="margin-bottom:18px;">${statsHtml}${summaryText}${topChangesHtml}</div>`;
}

// ========== 100종 DB 기반 규칙 엔진 ==========

/**********************
 * 100종 DB 로더 (캐시 방식)
 **********************/
let POSTURE_DB = [];
let POSTURE_DB_MAP = Object.create(null);
let PILATES_EXERCISE_DB = []; // ✅ 필라테스 운동 DB 추가 (Pilates_Exercise_DB_1000_v2.json)
let postureDBCache = null;
let pilatesDBCache = null;
const pilatesExerciseDetailMapEn = Object.create(null);
const pilatesExerciseDetailMapKo = Object.create(null);

function registerPilatesExerciseDetails(entries) {
  if (!Array.isArray(entries)) return;
  entries.forEach(item => {
    if (!item) return;
    const keyEn = (item.exercise_en || '').trim().toLowerCase();
    const keyKo = (item.exercise_ko || '').trim().toLowerCase();
    if (keyEn) {
      pilatesExerciseDetailMapEn[keyEn] = item;
    }
    if (keyKo) {
      pilatesExerciseDetailMapKo[keyKo] = item;
    }
  });
}

function getPilatesExerciseDetail(exerciseEn, exerciseKo) {
  if (exerciseEn) {
    const found = pilatesExerciseDetailMapEn[exerciseEn.trim().toLowerCase()];
    if (found) return found;
  }
  if (exerciseKo) {
    const found = pilatesExerciseDetailMapKo[exerciseKo.trim().toLowerCase()];
    if (found) return found;
  }
  return null;
}

function formatMultilineText(text) {
  if (!text) return '';
  return escapeHtml(text).replace(/\n/g, '<br>');
}

const PILATES_EQUIPMENT_LIST = ['매트', '리포머', '캐딜락', '체어', '바렐'];
const REPORT_SIGNATURE = 'created by Kim Cook (@pila_strong)';
const REPORT_METRIC_RANGE = {
  'CVA(두개경추각)': [50, 90],
  'HPD(두부전방이동)': [0, 2],
  'TIA(체간경사각)': [0, 10],
  'SAA(어깨전방각)': [0, 10],
  'PTA(골반경사각)': [0, 15],
  'KA(무릎각)': [175, 185],
  'Tibial(경골경사각)': [0, 10],
  'GSB(중심선)': [0, 2],
  'HPA(머리-골반각)': [0, 10]
};

function chartOutOfRange(metricName = '', value = null) {
  if (value == null || Number.isNaN(value)) return false;
  const label = (metricName || '').replace(/\s+/g, '');
  const key = Object.keys(REPORT_METRIC_RANGE).find((k) => label.includes(k.replace(/[()\s]/g, '')));
  if (!key) return false;
  const [min, max] = REPORT_METRIC_RANGE[key];
  return value < min || value > max;
}

function escapeHtml(value) {
  if (value == null) return '';
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function escapeAttr(value) {
  return escapeHtml(value).replace(/"/g, '&quot;');
}

function normalizeExerciseEntry(entry) {
  if (!entry) return null;
  if (typeof entry === 'string') {
    return { name: entry };
  }
  const normalized = { ...entry };
  if (!normalized.name) {
    normalized.name = normalized.exercise_ko || normalized.exercise_en || normalized.en || normalized.ko || '';
  }
  if (!normalized.en && normalized.exercise_en) normalized.en = normalized.exercise_en;
  if (!normalized.ko && normalized.exercise_ko) normalized.ko = normalized.exercise_ko;
  if (!normalized.how && normalized.how_to_do) normalized.how = normalized.how_to_do;
  if (!normalized.purpose && normalized.description) normalized.purpose = normalized.description;
  if (!normalized.sets_reps && normalized.reps) normalized.sets_reps = normalized.reps;
  if (!normalized.precaution && normalized.warning) normalized.precaution = normalized.warning;
  return normalized;
}

function getExerciseDetailInfo(entry) {
  const normalized = normalizeExerciseEntry(entry) || {};
  const en = normalized.en || normalized.exercise_en || normalized.name || '';
  const ko = normalized.ko || normalized.exercise_ko || '';
  const detail = getPilatesExerciseDetail(en, ko);
  const titleEn = detail?.exercise_en || normalized.exercise_en || normalized.en || '';
  const titleKo = detail?.exercise_ko || normalized.exercise_ko || normalized.ko || '';
  let title = normalized.name || titleEn || titleKo || 'Pilates Exercise';
  if (titleEn && titleKo && titleEn !== titleKo) {
    title = `${titleEn} (${titleKo})`;
  } else if (titleKo && !title.includes(titleKo)) {
    title = `${title} (${titleKo})`;
  }
  const purpose = detail?.purpose || normalized.purpose || '';
  const how =
    detail?.how_to_do ||
    detail?.instructions ||
    normalized.how ||
    normalized.how_to_do ||
    normalized.instructions ||
    '';
  const cues = detail?.key_cues || normalized.key_cues || normalized.cues || '';
  const sets = detail?.sets_reps || normalized.sets_reps || normalized.reps || '';
  const precaution = detail?.precaution || normalized.precaution || normalized.warning || '';
  return { title, purpose, how, cues, sets, precaution, enKey: detail?.exercise_en || en, koKey: titleKo || ko };
}

function renderExerciseDetailHTML(entry, options = {}) {
  const info = getExerciseDetailInfo(entry);
  if (!info.title) return '';
  const context = options.context || 'ui';
  const theme = {
    ui: { detailBg: '#ffffff', text: '#1f2933', accent: '#6c4ab6', hint: '#475569' },
    dark: { detailBg: 'rgba(255,255,255,0.05)', text: '#eef2ff', accent: '#a78bfa', hint: '#cbd5f5' },
    pdf: { detailBg: '#ffffff', text: '#0b0f14', accent: '#5c44b8', hint: '#475569' }
  }[context] || { detailBg: '#ffffff', text: '#1f2933', accent: '#6c4ab6', hint: '#475569' };
  const isInteractive = context !== 'pdf';
  const baseFontSize = options.compact ? '11px' : '12px';
  const dataAttrs = isInteractive ? ` data-pilates-detail-card="1" data-exercise-en="${escapeAttr(info.enKey || info.title)}" data-exercise-ko="${escapeAttr(info.koKey || '')}" data-exercise-purpose="${escapeAttr(info.purpose || '')}"` : '';
  let html = `<div${dataAttrs} style="margin-top:${options.compact ? '4px' : '8px'}; padding:${options.compact ? '8px' : '10px'}; background:${theme.detailBg}; border-radius:8px; font-size:${baseFontSize}; color:${theme.text}; line-height:1.6; font-family: var(--font-body);${isInteractive ? ' cursor:pointer; transition:background 0.2s ease;' : ''}">`;
  html += `<div style="font-weight:600; color:${theme.accent}; margin-bottom:6px;">${info.title}</div>`;
  if (info.purpose) {
    html += `<div style="margin-bottom:4px;"><strong style="color:${theme.accent};">목적</strong><br>${formatMultilineText(info.purpose)}</div>`;
  }
  if (info.how) {
    html += `<div style="margin-bottom:8px;"><strong style="color:${theme.accent}; font-size:${parseInt(baseFontSize) + 1}px;">운동 설명</strong><br><div style="margin-top:4px; line-height:1.8;">${formatMultilineText(info.how)}</div></div>`;
  }
  if (info.cues) {
    html += `<div style="margin-bottom:4px;"><strong style="color:${theme.accent};">핵심 큐</strong><br>${formatMultilineText(info.cues)}</div>`;
  }
  if (info.sets) {
    html += `<div style="margin-bottom:4px;"><strong style="color:${theme.accent};">세트/반복</strong> ${formatMultilineText(info.sets)}</div>`;
  }
  if (info.precaution) {
    html += `<div style="margin-bottom:0;"><strong style="color:#ff6b6b;">주의</strong><br>${formatMultilineText(info.precaution)}</div>`;
  }
  if (isInteractive) {
    html += `<div style="margin-top:6px; font-size:10px; color:${theme.hint}; display:flex; align-items:center; gap:4px;">
      <span style="font-size:12px;">👆</span> 눌러서 자세한 설명 보기
    </div>`;
  }
  html += `</div>`;
  return html;
}

function renderExerciseDetailsList(entries, options = {}) {
  if (!entries) return '';
  const list = (Array.isArray(entries) ? entries : [entries])
    .map(normalizeExerciseEntry)
    .filter(Boolean);
  if (!list.length) return '';
  const unlimited = options.limit === Infinity;
  const limit =
    unlimited
      ? list.length
      : options.limit ||
        (options.context === 'pdf' ? Math.min(8, list.length) : 2);
  return list.slice(0, limit).map(entry => renderExerciseDetailHTML(entry, options)).join('');
}

function renderPilatesEquipmentSections(pilatesObj, options = {}) {
  if (!pilatesObj) return '';
  let html = '';
  PILATES_EQUIPMENT_LIST.forEach(tool => {
    const exercises = pilatesObj[tool];
    const details = renderExerciseDetailsList(exercises, options);
    if (details) {
      html += `<div style="margin-top:8px;">
        <div style="font-weight:600; font-size:11px; color:${options.context === 'dark' ? '#c7d2fe' : '#5c44b8'}; margin-bottom:4px;">${tool}</div>
        ${details}
      </div>`;
    }
  });
  return html;
}

function renderPilatesItemCard(item, options = {}) {
  if (!item) return '';
  const context = options.context || 'ui';
  const themeMap = {
    ui: { bg:'#f3e5f5', text:'#0b0f14', accent:'#9c88ff', border:'#d8c2ff' },
    dark: { bg:'rgba(255,255,255,0.05)', text:'#f8fbff', accent:'#c4b5fd', border:'rgba(255,255,255,0.12)' },
    pdf: { bg:'#f6f3ff', text:'#0b0f14', accent:'#5c44b8', border:'#d7ccff' }
  };
  const theme = themeMap[context] || themeMap.ui;
  const title = item.name || item.issue || `추천 ${typeof options.index === 'number' ? options.index + 1 : ''}`;
  const musclesText = Array.isArray(item.muscles) ? item.muscles.join(', ') : (item.muscles || '');
  const tightText = Array.isArray(item.tight) ? item.tight.join(', ') : (item.tight || '');
  const weakText = Array.isArray(item.weak) ? item.weak.join(', ') : (item.weak || '');
  const pilatesData = item.pilates || item.pilatesExercises || null;
  const equipmentHTML = renderPilatesEquipmentSections(pilatesData, { context, limit: options.limitPerTool });
  const descriptionParts = [];
  if (item.condition) descriptionParts.push(item.condition);
  if (item.interpretation) descriptionParts.push(item.interpretation);
  if (item.description) descriptionParts.push(item.description);
  const description = descriptionParts.join(' · ');
  const note = item.note || item.manual || '';

  return `
    <div style="margin-bottom:12px; padding:14px; background:${theme.bg}; border-radius:12px; border:1px solid ${theme.border}; color:${theme.text}; font-family: var(--font-body);">
      <div style="font-weight:700; font-size:14px; margin-bottom:6px; color:${theme.accent};">${title}</div>
      ${description ? `<div style="font-size:11px; margin-bottom:6px;">${formatMultilineText(description)}</div>` : ''}
      ${musclesText ? `<div style="font-size:11px; margin-bottom:4px;"><strong style="color:${theme.accent};">관련 근육:</strong> ${musclesText}</div>` : ''}
      ${tightText ? `<div style="font-size:11px; margin-bottom:4px;"><strong style="color:#ff6b6b;">긴장:</strong> ${tightText}</div>` : ''}
      ${weakText ? `<div style="font-size:11px; margin-bottom:6px;"><strong style="color:#7c9cff;">약화:</strong> ${weakText}</div>` : ''}
      ${equipmentHTML ? `<div style="margin-top:8px;">${equipmentHTML}</div>` : ''}
      ${note ? `<div style="margin-top:10px; font-size:11px; color:${theme.text === '#f8fbff' ? '#c7d2fe' : '#4b5563'};">${formatMultilineText(note)}</div>` : ''}
    </div>
  `;
}

document.addEventListener('click', (event) => {
  const card = event.target.closest('[data-pilates-detail-card="1"]');
  if (!card || typeof showExerciseModal !== 'function') return;
  event.preventDefault();
  const exerciseEn = card.getAttribute('data-exercise-en') || '';
  const exerciseKo = card.getAttribute('data-exercise-ko') || '';
  const purpose = card.getAttribute('data-exercise-purpose') || '';
  showExerciseModal(exerciseEn, exerciseKo, purpose);
});

function setPageContainerStyle(container, { width = 794 } = {}) {
  container.style.position = "fixed";
  container.style.left = "-9999px";
  container.style.top = "0";
  container.style.width = `${width}px`;
  container.style.padding = "30px 25px";
  container.style.paddingBottom = "140px";
  container.style.background = "#ffffff";
  container.style.color = "#111";
  container.style.fontFamily = 'var(--font-body)';
  container.style.fontSize = "12px";
  container.style.lineHeight = "1.55";
  container.style.letterSpacing = "0.2px";
  container.style.boxSizing = "border-box";
  container.style.overflow = "visible";
  container.style.wordWrap = "break-word";
  container.style.minHeight = "1100px";
}

function buildCoverPageHTML({ memberName, centerName, dateStr, appName, beforeViews = {}, afterViews = {}, overlayImg }) {
  const hasBefore = !!(beforeViews.side || beforeViews.front);
  const hasAfter = !!(afterViews.side || afterViews.front);
  const renderViewColumn = (label, views) => {
    const hasView = !!(views.side || views.front);
    if(!hasView) {
      return `
        <div style="flex:1; min-height:360px; border:1px dashed #cbd5f5; border-radius:12px; display:flex; align-items:center; justify-content:center; color:#94a3b8; font-size:12px;">
          ${label} 이미지가 없습니다.
        </div>
      `;
    }
    const rows = [];
    if(views.side) {
      rows.push(`
        <div style="text-align:center;">
          <img src="${views.side}" style="width:100%; height:auto; border-radius:10px; border:1px solid #e2e8f0; display:block; max-height:320px; object-fit:contain; background:#fff;" />
          <div style="margin-top:6px; font-size:11px; color:#475569; font-weight:600;">${label} · 옆모습</div>
        </div>
      `);
    }
    if(views.front) {
      rows.push(`
        <div style="text-align:center;">
          <img src="${views.front}" style="width:100%; height:auto; border-radius:10px; border:1px solid #e2e8f0; display:block; max-height:320px; object-fit:contain; background:#fff;" />
          <div style="margin-top:6px; font-size:11px; color:#475569; font-weight:600;">${label} · 정면</div>
        </div>
      `);
    }
    return `
      <div style="flex:1; display:flex; flex-direction:column; gap:14px; padding:12px; border:1px solid #e2e8f0; border-radius:12px; background:#fafbff;">
        <div style="font-size:13px; font-weight:700; color:#0f172a;">${label}</div>
        ${rows.join('')}
      </div>
    `;
  };

  return `
    <div style="text-align:center; margin-top:60px;">
      <h1 style="margin:0; padding:0; font-size:32px; font-weight:800; color:#0b0f14; margin-bottom:30px; line-height:1.3;">📋 AI 자세 분석 보고서</h1>
      ${memberName ? `<h2 style="margin:0; padding:0; font-size:20px; font-weight:600; color:#333; margin-bottom:15px;">회원명: ${memberName}</h2>` : ''}
      ${centerName ? `<h3 style="margin:0; padding:0; font-size:18px; font-weight:500; color:#666; margin-bottom:15px;">센터명: ${centerName}</h3>` : ''}
      <p style="margin:0; padding:0; font-size:14px; color:#999; margin-bottom:10px;">분석일: ${dateStr}</p>
      <p style="margin:0; padding:0; font-size:12px; color:#999; margin-top:40px;">Generated by ${appName} · ${REPORT_SIGNATURE}</p>
    </div>
    
    ${(hasBefore || hasAfter) ? `
    <div style="margin-top:24px;">
      <div style="font-size:14px; font-weight:700; margin-bottom:12px; text-align:left;">📸 Before / After (측면 + 정면)</div>
      <div style="display:flex; gap:16px; flex-wrap:wrap;">
        ${renderViewColumn('Before', beforeViews)}
        ${renderViewColumn('After', afterViews)}
      </div>
    </div>
    ` : `
    <div style="margin-top:24px; padding:32px; border:1px dashed #cbd5f5; border-radius:12px; text-align:center; color:#94a3b8;">
      업로드된 사진이 없어 표지를 구성할 수 없습니다.
    </div>
    `}
    
    ${overlayImg ? `
    <div style="margin-top:24px;">
      <div style="font-size:12px; font-weight:600; margin-bottom:8px;">🔄 Before-After 오버레이 (변화 시각화)</div>
      <div style="text-align:center;">
        <img src="${overlayImg}" style="width:100%; max-width:600px; height:auto; border-radius:10px; border:1px solid #e2e8f0; display:block; margin:0 auto; max-height:400px; object-fit:contain; background:#fff;" />
        <div style="margin-top:8px; font-size:10px; color:#666;">파란색: Before | 주황색: After (투명도 50%)</div>
      </div>
    </div>
    ` : ''}
  `;
}

function createCoverPageContainer(params) {
  const container = document.createElement('div');
  setPageContainerStyle(container);
  container.classList.add('pdf-safe');
  container.innerHTML = buildCoverPageHTML(params);
  return container;
}


async function captureReportCanvases({ centerName, memberName, appName, logoUrl }) {
  const S = sessions[cur];
  const M = S.metrics || {};
  const scoreData = S.score || {};
  let analysis = S.analysis || {};
  const hasMeaningfulAnalysis = (data) => {
    if (!data) return false;
    return ['pilates','exercises','comments','details','tight','weak'].some(key => Array.isArray(data[key]) && data[key].length > 0);
  };
  const mergeAnalysisData = (preferred = {}, fallback = {}) => ({
    ...fallback,
    ...preferred,
    pilates: (Array.isArray(preferred.pilates) && preferred.pilates.length > 0) ? preferred.pilates : (fallback.pilates || []),
    exercises: (Array.isArray(preferred.exercises) && preferred.exercises.length > 0) ? preferred.exercises : (fallback.exercises || []),
    comments: (Array.isArray(preferred.comments) && preferred.comments.length > 0) ? preferred.comments : (fallback.comments || []),
    details: (Array.isArray(preferred.details) && preferred.details.length > 0) ? preferred.details : (fallback.details || []),
    tight: (Array.isArray(preferred.tight) && preferred.tight.length > 0) ? preferred.tight : (fallback.tight || []),
    weak: (Array.isArray(preferred.weak) && preferred.weak.length > 0) ? preferred.weak : (fallback.weak || [])
  });

  const analysisResultFallback = S.analysisResult?.analysis || null;
  if (analysisResultFallback) {
    analysis = mergeAnalysisData(analysis, analysisResultFallback);
  }

  if (!hasMeaningfulAnalysis(analysis) && analysisResultFallback) {
    analysis = mergeAnalysisData(analysisResultFallback, analysis);
  }

  if (!hasMeaningfulAnalysis(analysis) && S.metrics?.fullMetrics) {
    try {
      const refreshedAnalysis = await analyzeMusclesWithDB(S.metrics.fullMetrics);
      if (refreshedAnalysis) {
        analysis = refreshedAnalysis;
        S.analysis = refreshedAnalysis;
      }
    } catch (recalcErr) {
      console.warn('PDF 생성 중 분석 데이터 보강 실패:', recalcErr);
    }
  }

  if (!analysis) {
    analysis = {};
  }

  // 통합 분석 결과 가져오기 (운동 추천 포함)
  const analysisResult = S.analysisResult || analyzePostureAutoWithRecommendation({
    sidePts: S.sidePoints.size > 0 ? Object.fromEntries(S.sidePoints) : null,
    frontPts: S.frontPoints.size > 0 ? Object.fromEntries(S.frontPoints) : null,
    pxPerCm: S.pxPerCm || 50.0
  });

  // Before/After 캔버스 이미지 가져오기 (dot와 점선 포함)
  if (!cv || !cv.toDataURL) {
    throw new Error("캔버스가 준비되지 않았습니다.");
  }

  const originalSession = cur;
  const wait = (ms = 80) => new Promise(resolve => setTimeout(resolve, ms));
  const hasOrientationData = (session, orientation) => {
    if (!session) return false;
    const map = orientation === "front" ? session.frontPoints : session.sidePoints;
    const imgRef = orientation === "front" ? session.imgFront : session.imgSide;
    return (map && map.size > 0) || !!imgRef;
  };

  const captureSessionSnapshot = async (sessionName, orientation) => {
    const session = sessions[sessionName];
    if(!session || !hasOrientationData(session, orientation)) return null;
    const originalSession = cur;
    const originalOrientation = session.poseData?.orientation || "side";

    if(cur !== sessionName) {
      switchSession(sessionName);
      await wait(80);
    }
    if(originalOrientation !== orientation) {
      setOrientation(orientation);
      await wait(80);
    } else {
      draw();
      await wait(50);
    }

    const snapshot = cv.toDataURL("image/png");

    if(originalOrientation !== orientation) {
      setOrientation(originalOrientation);
      await wait(60);
    }
    if(cur !== originalSession) {
      switchSession(originalSession);
      await wait(60);
    } else {
      draw();
    }
    return snapshot;
  };

  const beforeViews = {};
  const afterViews = {};

  const beforeSideImg = await captureSessionSnapshot("Before", "side");
  if(beforeSideImg) beforeViews.side = beforeSideImg;
  const beforeFrontImg = await captureSessionSnapshot("Before", "front");
  if(beforeFrontImg) beforeViews.front = beforeFrontImg;

  const afterSideImg = await captureSessionSnapshot("After", "side");
  if(afterSideImg) afterViews.side = afterSideImg;
  const afterFrontImg = await captureSessionSnapshot("After", "front");
  if(afterFrontImg) afterViews.front = afterFrontImg;

  if(cur !== originalSession) {
    switchSession(originalSession);
    await wait(60);
  } else {
    draw();
  }

  const beforeImg = beforeViews.side || beforeViews.front || null;
  const afterImg = afterViews.side || afterViews.front || null;
  const beforeOrientation = beforeViews.side ? "side" : (beforeViews.front ? "front" : "side");
  const afterOrientation = afterViews.side ? "side" : (afterViews.front ? "front" : "side");

  // Before-After 오버레이 이미지 생성 (스켈레톤 포함)
  let overlayImg = null;
  const overlayOrientation = (beforeViews.side && afterViews.side) ? "side"
    : (beforeViews.front && afterViews.front) ? "front"
    : null;

  if(beforeImg && afterImg && overlayOrientation) {
    try {
      const beforePointsMap = overlayOrientation === "front" ? sessions.Before?.frontPoints : sessions.Before?.sidePoints;
      const afterPointsMap = overlayOrientation === "front" ? sessions.After?.frontPoints : sessions.After?.sidePoints;

      // Map을 일반 객체로 변환 (소문자 키로 통일)
      const getPointsObject = (pointsMap) => {
        if(!pointsMap) return null;
        const obj = {};
        if(pointsMap instanceof Map) {
          pointsMap.forEach((value, key) => {
            // 키를 소문자로 변환 (tragus, c7, acromion 등)
            const lowerKey = key.toLowerCase();
            obj[lowerKey] = value;
          });
        } else if(typeof pointsMap === 'object') {
          Object.keys(pointsMap).forEach(key => {
            const lowerKey = key.toLowerCase();
            obj[lowerKey] = pointsMap[key];
          });
        }
        return obj;
      };

      const beforePoints = getPointsObject(beforePointsMap);
      const afterPoints = getPointsObject(afterPointsMap);

      // 스켈레톤이 있는 경우 스켈레톤 포함 오버레이 생성, 없으면 기본 오버레이
      const beforeBaseImg = overlayOrientation === "front" ? beforeViews.front : beforeViews.side;
      const afterBaseImg = overlayOrientation === "front" ? afterViews.front : afterViews.side;

      if(beforeBaseImg && afterBaseImg && beforePoints && afterPoints && Object.keys(beforePoints).length > 0 && Object.keys(afterPoints).length > 0) {
        overlayImg = await createOverlayImageWithSkeleton(beforeBaseImg, afterBaseImg, beforePoints, afterPoints, 0.5);
      } else {
        overlayImg = await createOverlayImage(beforeBaseImg || beforeImg, afterBaseImg || afterImg, 0.5);
      }
    } catch(err) {
      console.warn("오버레이 이미지 생성 실패:", err);
      // 폴백: 기본 오버레이 시도
      try {
        overlayImg = await createOverlayImage(beforeImg, afterImg, 0.5);
      } catch(err2) {
        console.warn("기본 오버레이 이미지 생성도 실패:", err2);
      }
    }
  }

  // Confidence Heatmap 생성 (Before, After) - 안전 버전
  let beforeHeatmap = null;
  let beforeAvgConfidence = 0.8;
  let afterHeatmap = null;
  let afterAvgConfidence = 0.8;

  if(beforeImg && sessions.Before) {
    try {
      const beforeOriginalImg = sessions.Before[beforeOrientation === "front" ? "imgFront" : "imgSide"];
      if(beforeOriginalImg && beforeOriginalImg.src) {
        const heatmapResult = await createConfidenceHeatmap(beforeOriginalImg.src, "Before", beforeOrientation);
        if(heatmapResult && typeof heatmapResult === 'object') {
          beforeHeatmap = heatmapResult.heatmapImage || heatmapResult;
          beforeAvgConfidence = heatmapResult.avgConfidence || 0.8;
        } else {
          beforeHeatmap = heatmapResult;
        }
      }
    } catch(err) {
      console.warn("Before 히트맵 생성 실패:", err);
      // 폴백: 원본 이미지 사용
      beforeHeatmap = beforeImg;
    }
  }

  if(afterImg && sessions.After) {
    try {
      const afterOriginalImg = sessions.After[afterOrientation === "front" ? "imgFront" : "imgSide"];
      if(afterOriginalImg && afterOriginalImg.src) {
        const heatmapResult = await createConfidenceHeatmap(afterOriginalImg.src, "After", afterOrientation);
        if(heatmapResult && typeof heatmapResult === 'object') {
          afterHeatmap = heatmapResult.heatmapImage || heatmapResult;
          afterAvgConfidence = heatmapResult.avgConfidence || 0.8;
        } else {
          afterHeatmap = heatmapResult;
        }
      }
    } catch(err) {
      console.warn("After 히트맵 생성 실패:", err);
      // 폴백: 원본 이미지 사용
      afterHeatmap = afterImg;
    }
  }

  // 측정 결과 기반 필라테스 추천
  const beforeMetrics = sessions.Before?.metrics || {};
  const afterMetrics = sessions.After?.metrics || {};
  const metricBasedPilates = recommendPilatesFromMetrics(beforeMetrics, afterMetrics);

  // 로고 HTML (있으면)
  const logoHtml = logoUrl ? `<img src="${logoUrl}" style="width:32px; height:32px; margin-right:8px; vertical-align:middle;" />` : '';

  // 분석 결과 요약 HTML 생성 (undefined 에러 방지)
  // 운동 추천 HTML 생성
  const exerciseRecommendationHtml = buildExerciseRecommendationHtml(analysisResult);

  const now = new Date();
  const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  const page1Container = createCoverPageContainer({
    memberName,
    centerName,
    dateStr,
    appName,
    beforeViews,
    afterViews,
    overlayImg
  });

document.body.appendChild(page1Container);

// html2canvas 옵션 정의 (폰트 디코딩 오류 방지, 모바일 최적화)
// 4개 사진 처리 시 메모리 절약을 위해 scale과 크기 제한을 더 낮춤
const isMobile = isMobileDevice();
const PDF_MAX_CANVAS_EDGE = isMobile ? 900 : 1200; // 더 낮춤 (1100/1400 → 900/1200)
const baseCanvasScale = isMobile ? 1.0 : 1.1; // 더 낮춤 (1.1/1.25 → 1.0/1.1)
const html2canvasOptions = {
  scale: baseCanvasScale,
  backgroundColor: "#ffffff",
  useCORS: true,
  allowTaint: false,
  logging: false,
  scrollX: 0,
  scrollY: -window.scrollY,
  imageTimeout: 20000,
  removeContainer: isMobile,
  // 메모리 절약 옵션 추가
  onclone: (clonedDoc) => {
    // 복제된 문서에서 불필요한 요소 제거
    const images = clonedDoc.querySelectorAll('img');
    images.forEach(img => {
      if (img.src && img.src.startsWith('data:')) {
        // 큰 data URI 이미지는 제거하거나 리사이즈
        try {
          const imgElement = new Image();
          imgElement.src = img.src;
          if (imgElement.width > 2000 || imgElement.height > 2000) {
            img.style.maxWidth = '800px';
            img.style.maxHeight = '800px';
          }
        } catch (e) {
          // 무시
        }
      }
    });
  }
};

// 첫 페이지 캡처 (useCORS로 폰트 디코딩 오류 방지, 모바일 최적화)
let canvas1;
try {
  // 모바일에서는 메모리 절약을 위해 지연 추가
  if (isMobile) {
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  canvas1 = await html2canvas(page1Container, {
    ...html2canvasOptions,
    windowWidth: page1Container.scrollWidth,
    windowHeight: page1Container.scrollHeight
  });

  if (!canvas1 || !canvas1.toDataURL) {
    throw new Error('첫 페이지 캔버스 생성 실패');
  }

  // 모든 경우에 캔버스 크기 제한 (4개 사진 처리 시 메모리 절약)
  const maxCanvasSize = PDF_MAX_CANVAS_EDGE;
  if (canvas1.width > maxCanvasSize || canvas1.height > maxCanvasSize) {
    const ratio = Math.min(maxCanvasSize / canvas1.width, maxCanvasSize / canvas1.height);
    const newCanvas = document.createElement('canvas');
    newCanvas.width = Math.floor(canvas1.width * ratio);
    newCanvas.height = Math.floor(canvas1.height * ratio);
    const ctx = newCanvas.getContext('2d');
    ctx.drawImage(canvas1, 0, 0, newCanvas.width, newCanvas.height);
    // 원본 캔버스 메모리 해제
    canvas1 = null;
    canvas1 = newCanvas;
  }
} catch (canvasErr) {
  if (document.body.contains(page1Container)) {
    document.body.removeChild(page1Container);
  }
  console.error('❌ 첫 페이지 캔버스 생성 실패:', canvasErr);
  throw new Error('PDF 생성 실패: 첫 페이지를 생성할 수 없습니다. ' + (canvasErr.message || ''));
}

if (document.body.contains(page1Container)) {
  document.body.removeChild(page1Container);
}

// 모바일에서 메모리 정리를 위한 짧은 지연
if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

const includeHeatmapPage = false;
const totalPages = includeHeatmapPage ? 7 : 6;
const pageIndexMap = {
  metrics: includeHeatmapPage ? 3 : 2,
  aiSummary: includeHeatmapPage ? 4 : 3,
  pilates: includeHeatmapPage ? 5 : 4,
  aiDeep: includeHeatmapPage ? 6 : 5,
  conclusion: includeHeatmapPage ? 7 : 6
};
let planTexts = { quickHtml: '', fullText: '' };

let canvas2 = null;
if (includeHeatmapPage && (beforeHeatmap || afterHeatmap)) {
  const page2Container = document.createElement("div");
  setPageContainerStyle(page2Container);
  page2Container.classList.add('pdf-safe');

  page2Container.innerHTML = `
    <div style="margin-bottom:20px;">
      <h2 style="margin:0; padding:0; font-size:20px; font-weight:700; color:#0b0f14; margin-bottom:8px;">🔥 AI Confidence Heatmap</h2>
      <div style="font-size:11px; color:#666; margin-bottom:20px;">각 관절의 AI 신뢰도를 색상으로 시각화합니다. 빨강(높음) → 노랑(중간) → 파랑(낮음)</div>

      ${beforeHeatmap ? `
      <div style="margin-bottom:25px;">
        <div style="font-size:13px; font-weight:600; margin-bottom:10px; color:#6366f1;">Before Confidence Heatmap</div>
        <div style="font-size:10px; color:#666; margin-bottom:5px;">AI 평균 신뢰도: ${(beforeAvgConfidence * 100).toFixed(1)}%</div>
        <img src="${beforeHeatmap}" style="width:100%; height:auto; border-radius:8px; border:1px solid #ddd; display:block; max-height:400px; object-fit:contain;" />
      </div>
      ` : ''}

      ${afterHeatmap ? `
      <div style="margin-bottom:25px;">
        <div style="font-size:13px; font-weight:600; margin-bottom:10px; color:#10b981;">After Confidence Heatmap</div>
        <div style="font-size:10px; color:#666; margin-bottom:5px;">AI 평균 신뢰도: ${(afterAvgConfidence * 100).toFixed(1)}%</div>
        <img src="${afterHeatmap}" style="width:100%; height:auto; border-radius:8px; border:1px solid #ddd; display:block; max-height:400px; object-fit:contain;" />
      </div>
      ` : ''}

      ${!beforeHeatmap && !afterHeatmap ? `
      <div style="padding:40px; text-align:center; color:#999; font-size:12px;">
        Confidence 데이터가 없습니다. AI 포즈 감지를 실행해주세요.
      </div>
      ` : ''}
    </div>

    <div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
      <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
        <span>Generated by ${appName} · ${REPORT_SIGNATURE}</span>
        <span>Page 2/${totalPages}</span>
      </div>
    </div>
  `;

  document.body.appendChild(page2Container);
  if (isMobile) {
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  canvas2 = await html2canvas(page2Container, {
    ...html2canvasOptions,
    windowWidth: page2Container.scrollWidth,
    windowHeight: page2Container.scrollHeight
  });
  if (document.body.contains(page2Container)) {
    document.body.removeChild(page2Container);
  }
  
  // 캔버스 즉시 압축 (4개 사진 처리 시 메모리 절약)
  if (canvas2 && (canvas2.width > PDF_MAX_CANVAS_EDGE || canvas2.height > PDF_MAX_CANVAS_EDGE)) {
    const ratio = Math.min(PDF_MAX_CANVAS_EDGE / canvas2.width, PDF_MAX_CANVAS_EDGE / canvas2.height);
    const newCanvas = document.createElement('canvas');
    newCanvas.width = Math.floor(canvas2.width * ratio);
    newCanvas.height = Math.floor(canvas2.height * ratio);
    const ctx = newCanvas.getContext('2d');
    ctx.drawImage(canvas2, 0, 0, newCanvas.width, newCanvas.height);
    canvas2 = newCanvas;
  }
  
  if (isMobile) {
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}

// 공통 페이지 스타일 설정 함수 (안전 폰트 사용)
const setPageContainerStyle = (container) => {
  container.style.position = "fixed";
  container.style.left = "-9999px";
  container.style.top = "0";
  container.style.width = "794px";
  container.style.padding = "30px 25px";
  container.style.paddingBottom = "140px";
  container.style.background = "#ffffff";
  container.style.color = "#111";
  container.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, "Noto Sans KR", sans-serif';
  container.style.fontSize = "12px";
  container.style.lineHeight = "1.55";
  container.style.letterSpacing = "0.2px";
  container.style.boxSizing = "border-box";
  container.style.overflow = "hidden";
  container.style.wordWrap = "break-word";
  container.style.minHeight = "1100px";
  // PDF 안전 폰트 클래스 추가
  container.classList.add('pdf-safe');
};

// ========== 페이지 3: 수치표 + 변화 그래프 (Chart.js) ==========
const comparison = analyzeBeforeAfterComparison();
try {
  await ensureChartLibrary();
} catch (chartErr) {
  console.warn('Chart.js 준비 실패:', chartErr);
}
const page3Container = document.createElement("div");
setPageContainerStyle(page3Container);

let page3HTML = '<h2 style="margin:0; padding:0; font-size:20px; font-weight:700; color:#0b0f14; margin-bottom:20px;">📊 수치표 + 변화 그래프</h2>';

if(comparison && comparison.results.length > 0) {
  let comparisonTableHTML = '<table style="width:100%; border-collapse:collapse; font-size:10px; table-layout:fixed; margin-bottom:15px;"><tr style="background:#f0f0f0;"><th style="padding:8px 6px; text-align:left; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">항목</th><th style="padding:8px 6px; text-align:center; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">Before</th><th style="padding:8px 6px; text-align:center; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">After</th><th style="padding:8px 6px; text-align:center; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">변화</th><th style="padding:8px 6px; text-align:left; border:1px solid #ddd; font-weight:600; word-wrap:break-word;">분석</th></tr>';

  comparison.results.forEach((item, idx) => {
    const statusColor = item.status === 'improved' ? '#2ec4b6' : item.status === 'worsened' ? '#ff6b6b' : '#666';
    const statusIcon = item.status === 'improved' ? '↑' : item.status === 'worsened' ? '↓' : '→';
    const deltaStr = item.delta >= 0 ? '+' + item.delta.toFixed(1) : item.delta.toFixed(1);
    comparisonTableHTML += `<tr style="background:${idx % 2 === 0 ? '#fff' : '#fafafa'};">
      <td style="padding:8px 6px; border:1px solid #ddd; word-wrap:break-word; font-size:10px;">${item.name}</td>
      <td style="padding:8px 6px; border:1px solid #ddd; text-align:center; word-wrap:break-word; font-size:10px;">${item.before.toFixed(item.unit === '점' ? 2 : 1)}${item.unit}</td>
      <td style="padding:8px 6px; border:1px solid #ddd; text-align:center; word-wrap:break-word; font-size:10px;">${item.after.toFixed(item.unit === '점' ? 2 : 1)}${item.unit}</td>
      <td style="padding:8px 6px; border:1px solid #ddd; text-align:center; word-wrap:break-word; font-size:10px; color:${statusColor}; font-weight:600;">${deltaStr}${item.unit} ${statusIcon}</td>
      <td style="padding:8px 6px; border:1px solid #ddd; word-wrap:break-word; font-size:9px; color:#555; line-height:1.4;">${item.comment}</td>
    </tr>`;
  });
  comparisonTableHTML += '</table>';

  page3HTML += `<div style="margin-bottom:20px;">${comparisonTableHTML}</div>
    <div id="beforeAfterChartSection"></div>
    <div style="margin-top:15px; padding:12px; background:#e8f5e9; border-radius:8px; border-left:4px solid #2ec4b6;">
      <div style="font-size:12px; font-weight:600; margin-bottom:8px; color:#2ec4b6;">📈 전체 변화 요약</div>
      <div style="font-size:11px; line-height:1.6; color:#333;">${comparison.summary.overallComment}</div>
    </div>`;
} else {
  page3HTML += '<div style="padding:40px; text-align:center; color:#999;">Before-After 비교 데이터가 없습니다.</div>';
}

const metricsPageNumber = pageIndexMap.metrics;
page3HTML += `<div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
      <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
        <span>Generated by ${appName} · ${REPORT_SIGNATURE}</span>
        <span>Page ${metricsPageNumber}/${totalPages}</span>
      </div>
    </div>`;

page3Container.innerHTML = page3HTML;
const labels = comparison?.results?.map(r => r.name) || [];
const beforeData = comparison?.results?.map(r => r.before) || [];
const afterData = comparison?.results?.map(r => r.after) || [];

const chartSectionPlaceholder = page3Container.querySelector('#beforeAfterChartSection');
if(chartSectionPlaceholder) {
  const section = document.createElement('div');
  section.style.marginTop = '20px';
  section.innerHTML = `
    <div style="font-size:12px; font-weight:600; margin-bottom:10px; color:#333;">📈 Before-After 그래프 (Chart.js)</div>
    <div style="background:#fff; padding:15px; border-radius:8px; border:1px solid #ddd;">
      <div style="font-size:10px; color:#666; margin-bottom:8px;">🔵 Before (교정 전) | 🟢 After (교정 후) | ⚠️ 붉은 값 = 정상범위 벗어남</div>
    </div>
  `;
  const graphShell = section.querySelector('div:nth-child(2)');
  const chartCanvas = document.createElement('canvas');
  chartCanvas.width = 800;
  chartCanvas.height = 400;
  chartCanvas.style.width = '100%';
  chartCanvas.style.maxHeight = '420px';
  graphShell.appendChild(chartCanvas);
  chartSectionPlaceholder.replaceWith(section);

  if(typeof Chart !== 'undefined') {
    const ctx = chartCanvas.getContext('2d');
    chartCanvas.chartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Before',
            data: beforeData,
            backgroundColor: beforeData.map((v, i) => 
              chartOutOfRange(labels[i], v) ? 'rgba(231,76,60,0.8)' : 'rgba(52,152,219,0.8)'),
            borderColor: beforeData.map((v, i) => 
              chartOutOfRange(labels[i], v) ? '#C0392B' : '#21618C'),
            borderWidth: 1
          },
          {
            label: 'After',
            data: afterData,
            backgroundColor: afterData.map((v, i) => 
              chartOutOfRange(labels[i], v) ? 'rgba(231,76,60,0.8)' : 'rgba(46,204,113,0.8)'),
            borderColor: afterData.map((v, i) => 
              chartOutOfRange(labels[i], v) ? '#C0392B' : '#1E8449'),
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { 
            display: true, 
            text: 'Before–After 자세 비교 그래프', 
            font: { size: 16, weight: 'bold' },
            padding: { top: 10, bottom: 20 }
          },
          legend: { 
            position: 'top',
            labels: {
              font: { size: 12 },
              padding: 15
            }
          },
          tooltip: { 
            callbacks: { 
              label: (ctx) => `${ctx.dataset.label}: ${ctx.formattedValue}${comparison.results[ctx.dataIndex].unit}` 
            } 
          }
        },
        scales: {
          y: { 
            beginAtZero: true, 
            title: { 
              display: true, 
              text: '단위 (° / cm)',
              font: { size: 12 }
            },
            ticks: {
              font: { size: 10 }
            }
          },
          x: { 
            ticks: { 
              autoSkip: false, 
              maxRotation: 45, 
              minRotation: 45,
              font: { size: 9 }
            }
          }
        }
      }
    });
    await waitForChartRender(chartCanvas.chartInstance);
  }
}

document.body.appendChild(page3Container);

let canvas3 = await html2canvas(page3Container, {
  ...html2canvasOptions,
  windowWidth: page3Container.scrollWidth,
  windowHeight: page3Container.scrollHeight
});

if (document.body.contains(page3Container)) {
  document.body.removeChild(page3Container);
}

// 캔버스 즉시 압축 (4개 사진 처리 시 메모리 절약)
if (canvas3 && (canvas3.width > PDF_MAX_CANVAS_EDGE || canvas3.height > PDF_MAX_CANVAS_EDGE)) {
  const ratio = Math.min(PDF_MAX_CANVAS_EDGE / canvas3.width, PDF_MAX_CANVAS_EDGE / canvas3.height);
  const newCanvas = document.createElement('canvas');
  newCanvas.width = Math.floor(canvas3.width * ratio);
  newCanvas.height = Math.floor(canvas3.height * ratio);
  const ctx = newCanvas.getContext('2d');
  ctx.drawImage(canvas3, 0, 0, newCanvas.width, newCanvas.height);
  canvas3 = newCanvas;
}

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

// ========== 페이지 4: AI 해석 요약 (DB 기반 분석 포함) ==========
const page4Container = document.createElement("div");
setPageContainerStyle(page4Container);

// After metrics 추출 (DB 기반 분석용)
const afterMetricsForDB = {};
const aMetricsForDB = sessions.After?.metrics?.fullMetrics || {};
const metricKeys = ['CVA', 'HPD', 'TIA', 'SAA', 'PTA', 'KA', 'Tibial_Angle', 'GSB', 'HPA', 
                    'STA', 'STA_F', 'POA', 'POA_F', 'TD', 'HTA', 'SPP', 'LLD', 'LLD_F'];
metricKeys.forEach(key => {
  const val = aMetricsForDB[key]?.value != null ? aMetricsForDB[key].value : 
              (aMetricsForDB[key]?.value_deg != null ? aMetricsForDB[key].value_deg : 
              (aMetricsForDB[key]?.value_cm != null ? aMetricsForDB[key].value_cm : null));
  if(val != null) {
    afterMetricsForDB[key] = val;
  }
});

// DB 기반 AI 분석 수행
let dbAnalysis = null;
try {
  if(Object.keys(afterMetricsForDB).length > 0) {
    dbAnalysis = await runDBDrivenAI(afterMetricsForDB);
  }
} catch(err) {
  console.warn('DB 기반 분석 실패:', err);
}

// ✅ 전체 체형 점수 계산
const fullMetricsForScore = sessions.After?.metrics?.fullMetrics || sessions[cur]?.metrics?.fullMetrics || {};
const scoreResult = computeScore(
  fullMetricsForScore.CVA?.value || fullMetricsForScore.CVA?.value_deg || null,
  fullMetricsForScore.PTA?.value || fullMetricsForScore.PTA?.value_deg || null,
  fullMetricsForScore.KA?.value || fullMetricsForScore.KA?.value_deg || null
);

const memberNameForPDF1 = memberName || '회원';

// 패턴 요약
const patterns = [];
if(analysis && analysis.pilates && analysis.pilates.length > 0) {
  analysis.pilates.forEach(item => {
    if(item.name || item.issue) {
      patterns.push(item.name || item.issue);
    }
  });
}
planTexts = buildPlanTexts({
  memberName: memberNameForPDF1,
  patterns,
  scoreResult,
  analysis,
  comparisonSummary: comparison?.summary?.overallComment || ''
});

page4Container.innerHTML = `
  <h2 style="margin:0; padding:0; font-size:20px; font-weight:700; color:#0b0f14; margin-bottom:20px;">📊 자세 분석 리포트</h2>

  <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(240px, 1fr)); gap:15px; margin-bottom:20px;">
    ${scoreResult ? `
    <div style="padding:18px; background:#f0fdf4; border-radius:12px; border:1px solid #bbf7d0;">
      <div style="font-size:13px; font-weight:700; color:#15803d; margin-bottom:8px;">📊 체형 종합 점수</div>
      <div style="font-size:32px; font-weight:800; color:#0b0f14; margin-bottom:6px;">${scoreResult.score}/100</div>
      <div style="font-size:11px; color:#15803d;">${scoreResult.reasons ? scoreResult.reasons.join(', ') : '데이터 누적 중'}</div>
    </div>` : ''}

    ${(analysis.tight && analysis.tight.length) || (analysis.weak && analysis.weak.length) ? `
    <div style="padding:18px; background:#fff7ed; border-radius:12px; border:1px solid #fed7aa;">
      <div style="font-size:13px; font-weight:700; color:#c2410c; margin-bottom:8px;">💪 근육 상태</div>
      ${analysis.tight?.length ? `<div style="font-size:11px; margin-bottom:4px;"><strong style="color:#dc2626;">긴장</strong> ${analysis.tight.join(', ')}</div>` : ''}
      ${analysis.weak?.length ? `<div style="font-size:11px; color:#334155;"><strong style="color:#2563eb;">약화</strong> ${analysis.weak.join(', ')}</div>` : ''}
    </div>` : ''}

    ${analysis.comments?.length ? `
    <div style="padding:18px; background:#e0f2fe; border-radius:12px; border:1px solid #bae6fd;">
      <div style="font-size:13px; font-weight:700; color:#0369a1; margin-bottom:8px;">🤖 AI 코멘트</div>
      <div style="font-size:11px; line-height:1.7; color:#0f172a;">${analysis.comments.join(' ')}</div>
    </div>` : ''}
  </div>

  ${(dbAnalysis?.topRecommendations || []).length ? `
  <div style="margin-bottom:20px; padding:15px; background:#f5f3ff; border-radius:12px; border:1px solid #dcd3ff;">
    <div style="font-size:13px; font-weight:700; color:#5c44b8; margin-bottom:8px;">📌 DB 기반 주요 패턴 (Top 3)</div>
    <ul style="margin:0; padding-left:18px; font-size:11px; color:#312e81; line-height:1.6;">
      ${(dbAnalysis.topRecommendations || []).slice(0,3).map((item, idx) => `<li style="margin-bottom:6px;">
        <strong>${idx + 1}. ${item.name || item.code}</strong> — ${item.abnormal || ''}
        ${item.tight ? `<br><span style="color:#dc2626;">긴장:</span> ${item.tight}` : ''}
        ${item.weak ? `<br><span style="color:#2563eb;">약화:</span> ${item.weak}` : ''}
      </li>`).join('')}
    </ul>
    <div style="margin-top:6px; font-size:10px; color:#6b7280;">※ 상세 루틴은 다음 페이지 '필라테스 추천'에서 확인하세요.</div>
  </div>` : ''}

  <div style="margin-top:15px; padding:12px; background:#f6fff7; border-radius:10px; border-left:4px solid #27ae60;">
    <div style="font-size:12px; font-weight:600; margin-bottom:8px; color:#27ae60;">✅ 향후 관리 요약</div>
    ${planTexts.quickHtml || '<div style="font-size:11px; color:#475569;">분석 데이터가 충분하지 않습니다.</div>'}
  </div>

  <div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
      <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
        <span>Generated by ${appName} · ${REPORT_SIGNATURE}</span>
        <span>Page ${pageIndexMap.aiSummary}/${totalPages}</span>
      </div>
  </div>
`;
document.body.appendChild(page4Container);

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

let canvas4 = await html2canvas(page4Container, {
  ...html2canvasOptions,
  windowWidth: page4Container.scrollWidth,
  windowHeight: page4Container.scrollHeight
});

if (document.body.contains(page4Container)) {
  document.body.removeChild(page4Container);
}

// 캔버스 즉시 압축 (4개 사진 처리 시 메모리 절약)
if (canvas4 && (canvas4.width > PDF_MAX_CANVAS_EDGE || canvas4.height > PDF_MAX_CANVAS_EDGE)) {
  const ratio = Math.min(PDF_MAX_CANVAS_EDGE / canvas4.width, PDF_MAX_CANVAS_EDGE / canvas4.height);
  const newCanvas = document.createElement('canvas');
  newCanvas.width = Math.floor(canvas4.width * ratio);
  newCanvas.height = Math.floor(canvas4.height * ratio);
  const ctx = newCanvas.getContext('2d');
  ctx.drawImage(canvas4, 0, 0, newCanvas.width, newCanvas.height);
  canvas4 = newCanvas;
}

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

// ========== 페이지 5: 필라테스 추천 루틴 (쉬운 따라하기) ==========
const page5Container = document.createElement("div");
setPageContainerStyle(page5Container);

// metrics 데이터 준비 (Before-After 비교용)
const combinedMetrics = {};
const bMetrics = sessions.Before?.metrics?.fullMetrics || {};
const aMetrics = sessions.After?.metrics?.fullMetrics || {};

// 각 지표를 {before, after} 형태로 변환
['CVA', 'HPD', 'TIA', 'SAA', 'PTA', 'KA', 'Tibial_Angle', 'GSB', 'HPA'].forEach(key => {
  const bVal = bMetrics[key]?.value != null ? bMetrics[key].value : 
               (bMetrics[key]?.value_deg != null ? bMetrics[key].value_deg : 
               (bMetrics[key]?.value_cm != null ? bMetrics[key].value_cm : null));
  const aVal = aMetrics[key]?.value != null ? aMetrics[key].value : 
               (aMetrics[key]?.value_deg != null ? aMetrics[key].value_deg : 
               (aMetrics[key]?.value_cm != null ? aMetrics[key].value_cm : null));
  if(bVal != null || aVal != null) {
    combinedMetrics[key] = { before: bVal, after: aVal };
  }
});

// 필라테스 추천 카드 HTML 생성
const pilatesHtml = generatePilatesSessionText(combinedMetrics, analysis?.pilates);

page5Container.innerHTML = `
  <h2 style="margin:0; padding:0; font-size:20px; font-weight:700; color:#0b0f14; margin-bottom:20px;">🧘 필라테스 추천 루틴 (쉬운 따라하기)</h2>
  <div style="margin-top:20px; line-height:1.6;">
    ${pilatesHtml || '<div style="font-size:12px; color:#333;">추천 루틴 데이터를 불러오지 못했습니다.</div>'}
  </div>
  <div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
      <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
        <span>Generated by ${appName} · ${REPORT_SIGNATURE}</span>
        <span>Page ${pageIndexMap.pilates}/${totalPages}</span>
      </div>
  </div>
`;

document.body.appendChild(page5Container);

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

let canvas5 = await html2canvas(page5Container, {
  ...html2canvasOptions,
  windowWidth: page5Container.scrollWidth,
  windowHeight: page5Container.scrollHeight
});

if (document.body.contains(page5Container)) {
  document.body.removeChild(page5Container);
}

// 캔버스 즉시 압축 (4개 사진 처리 시 메모리 절약)
if (canvas5 && (canvas5.width > PDF_MAX_CANVAS_EDGE || canvas5.height > PDF_MAX_CANVAS_EDGE)) {
  const ratio = Math.min(PDF_MAX_CANVAS_EDGE / canvas5.width, PDF_MAX_CANVAS_EDGE / canvas5.height);
  const newCanvas = document.createElement('canvas');
  newCanvas.width = Math.floor(canvas5.width * ratio);
  newCanvas.height = Math.floor(canvas5.height * ratio);
  const ctx = newCanvas.getContext('2d');
  ctx.drawImage(canvas5, 0, 0, newCanvas.width, newCanvas.height);
  canvas5 = newCanvas;
}

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

// ========== 페이지 6: AI 심층 분석 ==========
const page6Container = document.createElement("div");
setPageContainerStyle(page6Container);

// ✅ AI 심층 분석 텍스트 생성 (DB 기반)
const deepAnalysisText = generateAIDeepAnalysis(combinedMetrics);

// ✅ 텍스트를 HTML로 변환 (글자 잘림 방지 - word-wrap, white-space:pre-wrap 추가)
const deepAnalysisHtml = deepAnalysisText.split('\n').map(line => {
  if(line.trim() === '') return '<br>';
  if(line.startsWith('▶')) {
    return `<div style="font-size:16px; font-weight:700; color:#2c3e50; margin-top:20px; margin-bottom:10px; word-wrap:break-word; line-height:1.6;">${line}</div>`;
  }
  if(line.startsWith('📍')) {
    return `<div style="font-size:14px; font-weight:600; color:#6366f1; margin-top:15px; margin-bottom:8px; word-wrap:break-word; line-height:1.6;">${line}</div>`;
  }
  if(line.startsWith('- ')) {
    return `<div style="font-size:12px; color:#333; margin-left:10px; margin-bottom:5px; line-height:1.6; word-wrap:break-word; white-space:pre-wrap;">${line}</div>`;
  }
  if(line.startsWith('  ·')) {
    return `<div style="font-size:11px; color:#555; margin-left:25px; margin-bottom:3px; line-height:1.6; word-wrap:break-word; white-space:pre-wrap;">${line}</div>`;
  }
  return `<div style="font-size:12px; color:#333; margin-bottom:5px; line-height:1.6; word-wrap:break-word; white-space:pre-wrap;">${line}</div>`;
}).join('');

page6Container.innerHTML = `
  <h2 style="margin:0; padding:0; font-size:20px; font-weight:700; color:#0b0f14; margin-bottom:20px;">🤖 AI 자세 심층 분석</h2>
  <div style="margin-top:20px; line-height:1.6;">
    ${deepAnalysisHtml}
  </div>
  <div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
      <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
        <span>Generated by ${appName} · ${REPORT_SIGNATURE}</span>
        <span>Page ${pageIndexMap.aiDeep}/${totalPages}</span>
      </div>
  </div>
`;

document.body.appendChild(page6Container);

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

let canvas6 = await html2canvas(page6Container, {
  ...html2canvasOptions,
  windowWidth: page6Container.scrollWidth,
  windowHeight: page6Container.scrollHeight
});

if (document.body.contains(page6Container)) {
  document.body.removeChild(page6Container);
}

// 캔버스 즉시 압축 (4개 사진 처리 시 메모리 절약)
if (canvas6 && (canvas6.width > PDF_MAX_CANVAS_EDGE || canvas6.height > PDF_MAX_CANVAS_EDGE)) {
  const ratio = Math.min(PDF_MAX_CANVAS_EDGE / canvas6.width, PDF_MAX_CANVAS_EDGE / canvas6.height);
  const newCanvas = document.createElement('canvas');
  newCanvas.width = Math.floor(canvas6.width * ratio);
  newCanvas.height = Math.floor(canvas6.height * ratio);
  const ctx = newCanvas.getContext('2d');
  ctx.drawImage(canvas6, 0, 0, newCanvas.width, newCanvas.height);
  canvas6 = newCanvas;
}

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

// ========== 페이지 7: 결론 (기존 페이지 6) ==========
const page7Container = document.createElement("div");
setPageContainerStyle(page7Container);

    const beforeAfterSummaryHtml = buildBeforeAfterSummaryHTML(comparison);
const fullPlanHtml = planTexts.fullText
  ? formatMultilineText(planTexts.fullText)
  : '<div style="font-size:11px; color:#475569;">분석 데이터가 충분하지 않습니다.</div>';

page7Container.innerHTML = `
  <h2 style="margin:0; padding:0; font-size:20px; font-weight:700; color:#0b0f14; margin-bottom:20px;">📌 최종 분석 & 전략</h2>
  ${beforeAfterSummaryHtml}
  <div style="margin-top:12px; padding:18px; background:#f6fff7; border-radius:12px; border-left:4px solid #27ae60;">
    <div style="font-size:13px; font-weight:700; color:#1b5e20; margin-bottom:8px;">🧭 12주 케어 로드맵</div>
    <div style="font-size:12px; line-height:1.7; color:#111;">${fullPlanHtml}</div>
  </div>
      <div style="margin-top:16px; font-size:10px; color:#6b7280; line-height:1.6;">
        ※ 본 리포트는 교육용으로 제공되며, 의료 진단을 대체하지 않습니다. 통증이 지속되면 전문의와 상의하세요.
      </div>
      <div style="margin-top:20px; padding-top:10px; border-top:1px solid #e0e0e0;">
        <div style="display:flex; justify-content:space-between; font-size:9px; color:#666;">
          <span>Generated by ${appName} · ${REPORT_SIGNATURE}</span>
          <span>Page ${pageIndexMap.conclusion}/${totalPages}</span>
        </div>
      </div>
    `;

document.body.appendChild(page7Container);

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

let canvas7 = await html2canvas(page7Container, {
  ...html2canvasOptions,
  windowWidth: page7Container.scrollWidth,
  windowHeight: page7Container.scrollHeight
});

if (document.body.contains(page7Container)) {
  document.body.removeChild(page7Container);
}

// 캔버스 즉시 압축 (4개 사진 처리 시 메모리 절약)
if (canvas7 && (canvas7.width > PDF_MAX_CANVAS_EDGE || canvas7.height > PDF_MAX_CANVAS_EDGE)) {
  const ratio = Math.min(PDF_MAX_CANVAS_EDGE / canvas7.width, PDF_MAX_CANVAS_EDGE / canvas7.height);
  const newCanvas = document.createElement('canvas');
  newCanvas.width = Math.floor(canvas7.width * ratio);
  newCanvas.height = Math.floor(canvas7.height * ratio);
  const ctx = newCanvas.getContext('2d');
  ctx.drawImage(canvas7, 0, 0, newCanvas.width, newCanvas.height);
  canvas7 = newCanvas;
}

if (isMobile) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

// 기존 페이지 5, 6 코드는 위에서 새로운 페이지 5, 6, 7로 대체됨


  return {
    canvases: {
      cover: canvas1,
      heatmap: includeHeatmapPage && canvas2 ? canvas2 : null,
      metrics: canvas3,
      aiSummary: canvas4,
      pilates: canvas5,
      aiDeep: canvas6,
      conclusion: canvas7
    },
    includeHeatmapPage,
    totalPages,
    pageIndexMap
  };
}

function combineCanvasesVertical(canvasList, gap = 40) {
  if (!Array.isArray(canvasList) || canvasList.length === 0) {
    throw new Error("결합할 캔버스가 없습니다.");
  }
  const maxWidth = Math.max(...canvasList.map(canvas => canvas.width || 0));
  if (!maxWidth) {
    throw new Error("캔버스 너비를 확인할 수 없습니다.");
  }
  const scaledHeights = canvasList.map(canvas => {
    if (!canvas.width) return 0;
    const shouldScaleDown = canvas.width > maxWidth;
    const scale = shouldScaleDown ? maxWidth / canvas.width : 1;
    return Math.round(canvas.height * scale);
  });
  const totalHeight = scaledHeights.reduce((sum, h) => sum + h, 0) + gap * (canvasList.length - 1);
  const combined = document.createElement('canvas');
  combined.width = maxWidth;
  combined.height = totalHeight;
  const ctx = combined.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, combined.width, combined.height);
  let offsetY = 0;
  canvasList.forEach((canvas, idx) => {
    const height = scaledHeights[idx];
    if (!canvas.width || !canvas.height) return;
    const shouldScaleDown = canvas.width > maxWidth;
    const drawWidth = shouldScaleDown ? maxWidth : canvas.width;
    const scale = drawWidth / canvas.width;
    const drawHeight = canvas.height * scale;
    const offsetX = (maxWidth - drawWidth) / 2;
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, offsetX, offsetY, drawWidth, drawHeight);
    offsetY += height;
    if (idx < canvasList.length - 1) {
      offsetY += gap;
    }
  });
  return combined;
}

function downloadCanvasAsImage(canvas, fileName, btn, originalText) {
  return new Promise((resolve, reject) => {
    const finalize = () => {
      if (btn) {
        btn.textContent = originalText || btn.textContent;
        btn.disabled = false;
      }
    };
    canvas.toBlob(async (blob) => {
      if (!blob) {
        finalize();
        return reject(new Error('이미지 변환 실패'));
      }
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      const isMobile = isMobileDevice();
      const allowWebShare = false;
      try {
        if (allowWebShare && isMobile && navigator.share && navigator.canShare) {
          const file = new File([blob], fileName, { type: 'image/png' });
          if (navigator.canShare({ files: [file] })) {
            await navigator.share({ title: fileName.replace('.png',''), files: [file] });
            finalize();
            return resolve();
          }
        }
        if (isIOS) {
          const url = URL.createObjectURL(blob);
          const newWindow = window.open(url, '_blank');
          if (newWindow) {
            setTimeout(() => {
              URL.revokeObjectURL(url);
              alert('🖼️ 이미지가 새 창에서 열렸습니다. 길게 눌러 저장하세요.');
            }, 150);
            finalize();
            return resolve();
          }
        }
        const downloadUrl = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = fileName;
        link.style.position = 'fixed';
        link.style.top = '-9999px';
        link.style.left = '-9999px';
        document.body.appendChild(link);
        try {
          link.click();
        } catch (e) {
          const clickEvent = new MouseEvent('click', { view: window, bubbles: true, cancelable: true });
          link.dispatchEvent(clickEvent);
        }
        setTimeout(() => {
          URL.revokeObjectURL(downloadUrl);
          if (document.body.contains(link)) {
            document.body.removeChild(link);
          }
        }, 2000);
        if (isMobile) {
          setTimeout(() => alert('이미지를 저장했습니다. 다운로드 폴더를 확인하세요.'), 400);
        }
        finalize();
        resolve();
      } catch (err) {
        finalize();
        reject(err);
      }
    }, 'image/png');
  });
}

// CSV 파싱 함수
function parseCSV(csvText) {
  const lines = csvText.split('\n').filter(line => line.trim());
  if (lines.length < 2) return [];
  
  const headers = lines[0].split(',').map(h => h.trim());
  const records = [];
  
  for (let i = 1; i < lines.length; i++) {
    const values = [];
    let currentValue = '';
    let inQuotes = false;
    
    for (let j = 0; j < lines[i].length; j++) {
      const char = lines[i][j];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        values.push(currentValue.trim());
        currentValue = '';
      } else {
        currentValue += char;
      }
    }
    values.push(currentValue.trim());
    
    if (values.length === headers.length) {
      const record = {};
      headers.forEach((header, idx) => {
        record[header] = values[idx] || '';
      });
      records.push(record);
    }
  }
  
  return records;
}

function splitMuscleList(value) {
  if (!value) return [];
  return String(value)
    .replace(/\r/g, '')
    .split(/[,/;|·]/)
    .map((item) => item.trim())
    .filter(Boolean);
}

function normalizeMuscleName(name) {
  if (!name) return '';
  return name
    .replace(/\s*[\(\[][^)\]]*[\)\]]\s*/g, '')
    .replace(/\s+/g, '')
    .toLowerCase();
}

function buildDataUrlCandidates(relativePath) {
  const normalized = relativePath.replace(/^\/+/, '');
  const basePrefix = location.pathname.includes('/posture-ai-kor') ? '/posture-ai-kor' : '';
  const baseOrigin = location.origin;
  const list = [
    `${baseOrigin}${basePrefix}/${normalized}`,
    `${baseOrigin}/${normalized}`,
    `/${normalized}`,
    `./${normalized}`
  ];
  if (normalized.startsWith('db/')) {
    list.splice(1, 0, `https://raw.githubusercontent.com/skyman200/posture-ai-kor/main/public/${normalized}`);
  }
  return Array.from(new Set(list));
}

async function fetchWithCandidates(urls, responseType = 'text') {
  let lastError = null;
  for (const url of urls) {
    try {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      if (responseType === 'json') return await res.json();
      return await res.text();
    } catch (err) {
      lastError = err;
      console.warn(`⚠️ 데이터 로드 실패 (${url}):`, err?.message || err);
    }
  }
  throw lastError || new Error('모든 경로 로드 실패');
}

function mapPostureRecord(row) {
  const metricCode = (row.Metric_Code || row.metric_code || row.metric || row.Index_Code || '').trim();
  const deviation = (row.Deviation_Label || row.deviation || '').trim();
  const tightStr = row.Tight_Muscle || row.tight_muscle || '';
  const weakStr = row.Weak_Muscle || row.weak_muscle || '';
  const strategy = row.Recommended_Strategy || row.strategy || '';
  const notes = row.Notes || row.notes || '';
  const postureKo = row.Metric_Name_KR || row.metric_name_kr || row.Metric_Name_EN || metricCode;
  const postureEn = row.Metric_Name_EN || row.metric_name_en || '';

  const tightList = splitMuscleList(tightStr);
  const weakList = splitMuscleList(weakStr);

  return {
    ...row,
    key: row.Index_Code || metricCode || postureKo,
    posture_key: metricCode || row.Index_Code || postureKo,
    posture_ko: postureKo,
    posture_en: postureEn,
    '지표코드': metricCode,
    '지표명': postureKo,
    '이상유형': deviation,
    '긴장근육(주요)': tightStr,
    '약화근육(주요)': weakStr,
    '교정운동(도수/자가)': strategy,
    '임상적의미': notes,
    muscle_pattern: {
      tight: { primary: tightList },
      weak: { primary: weakList }
    },
    tight: tightList,
    weak: weakList,
    tightMuscles: tightList,
    weakMuscles: weakList,
    recommended_focus: {
      stretch: [],
      strengthen: []
    }
  };
}

function mapPilatesExerciseRow(row, equipmentKo) {
  // CSV 컬럼명 확인: Main_Strengthen_Muscles, Main_Stretch_Muscles
  const stretchStr = row.Main_Stretch_Muscles || row['Main_Stretch_Muscles (주요 스트레칭 근육)'] || row.main_stretch || '';
  const strengthenStr = row.Main_Strengthen_Muscles || row['Main_Strengthen_Muscles (주요 강화 근육)'] || row.main_strengthen || '';
  
  const stretchTargets = splitMuscleList(stretchStr);
  const strengthenTargets = splitMuscleList(strengthenStr);
  
  const exerciseKo = row.Exercise_Name_KR || row.exercise_ko || '';
  const exerciseEn = row.Exercise_Name_EN || row.exercise_en || '';
  
  return {
    equipment: equipmentKo,
    equipment_ko: equipmentKo,
    exercise_ko: exerciseKo,
    exercise_en: exerciseEn,
    name: exerciseEn || exerciseKo,
    ko: exerciseKo,
    posture_key: '',
    posture_ko: '',
    purpose: strengthenStr
      ? `강화: ${strengthenStr}${stretchStr ? ` / 스트레칭: ${stretchStr}` : ''}`
      : '',
    how_to_do: row['How_to_Perform_Step_by_Step_FULL_CLASSICAL'] || 
               row['How_to_Perform_EASY_FOR_BEGINNERS (상세 동작 설명)'] || 
               row['How_to_Perform_EASY_FOR_BEGINNERS'] || 
               row['How_to_Perform_Step_by_Step (상세 동작 설명)'] || 
               row['How_to_Perform_Step_by_Step'] || 
               row['How_to_Perform'] || 
               row.How_to_Perform_Step_by_Step_FULL_CLASSICAL || 
               row.How_to_Perform_EASY_FOR_BEGINNERS || 
               row.How_to_Perform_Step_by_Step || 
               row.How_to_Perform || '',
    key_cues: row.Classical_Cues_by_Jay_Grimes_Romana || row.Breathing_Pattern || row.Breathing || '',
    sets_reps: row.Reps || '',
    spring: row.Spring_Traditional || row.Spring || '',
    references: row.References || '',
    stretch_targets: stretchTargets,
    strengthen_targets: strengthenTargets,
    // CSV 원본 데이터도 저장 (하위 호환성)
    Main_Strengthen_Muscles: strengthenStr,
    Main_Stretch_Muscles: stretchStr,
    stretchMuscles: stretchTargets,
    strengthenMuscles: strengthenTargets
  };
}

async function loadPostureDB() {
  if (postureDBCache) {
    POSTURE_DB = postureDBCache;
    rebuildPostureDbMap(POSTURE_DB);
    return POSTURE_DB;
  }
  if (POSTURE_DB.length) {
    postureDBCache = POSTURE_DB;
    rebuildPostureDbMap(POSTURE_DB);
    return POSTURE_DB;
  }
  try {
    const csvText = await fetchWithCandidates(buildDataUrlCandidates('db/posture_metrics_full.csv'));
    const records = parseCSV(csvText);
    if (!records.length) {
      throw new Error('posture_metrics_full.csv 데이터가 비어 있습니다.');
    }
    const mapped = records.map(mapPostureRecord);
    POSTURE_DB = mapped;
    postureDBCache = mapped;
    rebuildPostureDbMap(mapped);
    console.log('✅ DB Loaded (CSV posture_metrics_full):', mapped.length, 'records');
    return POSTURE_DB;
  } catch (err) {
    console.error('❌ DB 로드 실패:', err);
    POSTURE_DB = [];
    postureDBCache = null;
    POSTURE_DB_MAP = Object.create(null);
    return POSTURE_DB;
  }
}

function rebuildPostureDbMap(records) {
  POSTURE_DB_MAP = Object.create(null);
  if (!Array.isArray(records)) return;
  records.forEach((item) => {
    if (!item) return;
    const key =
      (item.Index_Code ||
        item.index_code ||
        item.key ||
        item.posture_key ||
        '').toString().trim().toUpperCase();
    if (key) {
      POSTURE_DB_MAP[key] = item;
    }
  });
}

async function loadPilatesDB() {
  if (pilatesDBCache) {
    PILATES_EXERCISE_DB = pilatesDBCache;
    registerPilatesExerciseDetails(PILATES_EXERCISE_DB);
    return PILATES_EXERCISE_DB;
  }
  if (PILATES_EXERCISE_DB.length) {
    pilatesDBCache = PILATES_EXERCISE_DB;
    registerPilatesExerciseDetails(PILATES_EXERCISE_DB);
    return PILATES_EXERCISE_DB;
  }

  const equipmentFiles = [
    { path: 'db/Pilates_Mat_34_Classical.csv', label: '매트' },
    { path: 'db/Pilates_Reformer_42_Classical.csv', label: '리포머' },
    { path: 'db/Pilates_Cadillac_58_Classical.csv', label: '캐딜락' },
    { path: 'db/Pilates_WundaChair_28_Classical.csv', label: '체어' },
    { path: 'db/Pilates_Barrel_22_Classical.csv', label: '바렐' }
  ];

  const merged = [];
  for (const file of equipmentFiles) {
    try {
      const csvText = await fetchWithCandidates(buildDataUrlCandidates(file.path));
      const rows = parseCSV(csvText);
      rows.forEach((row) => {
        const mapped = mapPilatesExerciseRow(row, file.label);
        merged.push(mapped);
      });
    } catch (err) {
      console.warn(`⚠️ ${file.label} CSV 로드 실패:`, err?.message || err);
    }
  }

  if (!merged.length) {
    console.error('❌ 필라테스 운동 DB 로드 실패: CSV 데이터 없음');
    PILATES_EXERCISE_DB = [];
    pilatesDBCache = null;
    return PILATES_EXERCISE_DB;
  }

  PILATES_EXERCISE_DB = merged;
  pilatesDBCache = merged;
  window.PilatesDB = merged;
  registerPilatesExerciseDetails(merged);
  console.log(`✅ 필라테스 운동 DB 로드 완료 (CSV): ${merged.length} exercises`);
  return merged;
}

// ✅ 필라테스 운동 매칭 함수 (참고 코드 기반)
async function linkPilatesDB(postureResult) {
  const pilatesDB = window.PilatesDB || PILATES_EXERCISE_DB || (await loadPilatesDB());
  if (!pilatesDB || pilatesDB.length === 0) {
    console.warn('⚠️ 필라테스 DB가 로드되지 않았습니다.');
    return [];
  }

  const searchKeys = [];
  if (postureResult.posture_key) searchKeys.push(postureResult.posture_key.toLowerCase());
  if (postureResult.posture_ko) searchKeys.push(postureResult.posture_ko.toLowerCase());
  if (postureResult.name) searchKeys.push(postureResult.name.toLowerCase());
  if (postureResult.code) searchKeys.push(postureResult.code.toLowerCase());
  if (postureResult.abnormal) searchKeys.push(postureResult.abnormal.toLowerCase());

  // tight와 weak를 배열로 변환 (문자열인 경우 split)
  let tightArray = [];
  let weakArray = [];
  
  if (postureResult.tightMuscles) {
    tightArray = Array.isArray(postureResult.tightMuscles) 
      ? postureResult.tightMuscles 
      : splitMuscleList(postureResult.tightMuscles);
  } else if (postureResult.tight) {
    tightArray = Array.isArray(postureResult.tight)
      ? postureResult.tight
      : splitMuscleList(postureResult.tight);
  }
  
  if (postureResult.weakMuscles) {
    weakArray = Array.isArray(postureResult.weakMuscles)
      ? postureResult.weakMuscles
      : splitMuscleList(postureResult.weakMuscles);
  } else if (postureResult.weak) {
    weakArray = Array.isArray(postureResult.weak)
      ? postureResult.weak
      : splitMuscleList(postureResult.weak);
  }

  const tightSet = new Set(
    tightArray.map(normalizeMuscleName).filter(Boolean)
  );
  const weakSet = new Set(
    weakArray.map(normalizeMuscleName).filter(Boolean)
  );

  const matchedExercises = pilatesDB.filter((ex) => {
    const exKeys = [
      ex.posture_key,
      ex.posture_ko,
      ex.exercise_en,
      ex.exercise_ko,
      ex.name
    ]
      .filter(Boolean)
      .map((v) => v.toLowerCase());

    let matched =
      searchKeys.length > 0 &&
      searchKeys.some((key) =>
        exKeys.some((exKey) => exKey.includes(key) || key.includes(exKey))
      );

    // 근육 기반 매칭: stretch_targets와 strengthen_targets 확인
    if (!matched && tightSet.size > 0) {
      // 긴장 근육을 스트레칭하는 운동 찾기
      const stretchTargets = ex.stretch_targets || ex.stretchMuscles || 
        (ex.Main_Stretch_Muscles ? splitMuscleList(ex.Main_Stretch_Muscles) : []);
      matched = stretchTargets.some((target) => {
        const normalized = normalizeMuscleName(target);
        return tightSet.has(normalized) || 
          Array.from(tightSet).some(t => normalized.includes(t) || t.includes(normalized));
      });
    }

    if (!matched && weakSet.size > 0) {
      // 약화 근육을 강화하는 운동 찾기
      const strengthenTargets = ex.strengthen_targets || ex.strengthenMuscles ||
        (ex.Main_Strengthen_Muscles ? splitMuscleList(ex.Main_Strengthen_Muscles) : []);
      matched = strengthenTargets.some((target) => {
        const normalized = normalizeMuscleName(target);
        return weakSet.has(normalized) ||
          Array.from(weakSet).some(w => normalized.includes(w) || w.includes(normalized));
      });
    }

    return matched;
  });

  const recommended = matchedExercises.slice(0, 10);
  console.log('✅ 필라테스 운동 추천:', recommended.length, '개');
  if (recommended.length > 0) {
    console.log('  -', recommended.map(e => e.exercise_ko || e.exercise_en || e.name).join(', '));
  }
  window.PilatesRecommendations = recommended;
  return recommended;
}


/**********************
 * 정상 범위 파서
 * '≥50°', '0–10°', '≤2cm' 등 텍스트를 수치 범위로 변환
 **********************/
function parseNormalRange(str) {
  if (!str) return null;
  const s = String(str).replace(/\s/g,'');
  // 구간 'a–b' 또는 'a-b'
  let m = s.match(/^(-?\d+(?:\.\d+)?)\s*[–-]\s*(-?\d+(?:\.\d+)?)$/);
  if (m) return { type:'range', min: parseFloat(m[1]), max: parseFloat(m[2]) };
  // '≥a'
  m = s.match(/^≥\s*(-?\d+(?:\.\d+)?)/);
  if (m) return { type:'min', min: parseFloat(m[1]) };
  // '≤a'
  m = s.match(/^≤\s*(-?\d+(?:\.\d+)?)/);
  if (m) return { type:'max', max: parseFloat(m[1]) };
  return null;
}

const RANGE_LABEL_RULES = {
  CVA: { low: '낮음(거북목)', high: '높음(과신전)' },
  HPD: { low: '낮음', high: '높음' },
  TIA: { low: '낮음', high: '높음' },
  SAA: { low: '낮음', high: '높음(라운드숄더)' },
  KA: { low: '내반', high: '외반' },
  Tibial: { low: '내회전', high: '외회전' },
  Tibial_Angle: { low: '내회전', high: '외회전' },
  QAngle: { low: '과소', high: '과대' },
  Q_Angle: { low: '과소', high: '과대' },
  KneeDev: { low: '내측', high: '외측' },
  Knee_Deviation: { low: '내측', high: '외측' }
};

const DIRECTIONAL_LABEL_RULES = {
  GSB: { threshold: 0.5, positive: '전방 편위', negative: '후방 편위' },
  SPP: { threshold: 1, positive: '전방', negative: '후방' },
  HPA: { threshold: 5, positive: '좌회전', negative: '우회전' },
  PDS: { threshold: 3, positive: '골반 하강', negative: '골반 거상' },
  POA: { threshold: 2, positive: '우하강', negative: '좌하강' },
  POA_F: { threshold: 2, positive: '우하강', negative: '좌하강' },
  TD: { threshold: 5, positive: '후만증', negative: '전만증' },
  HTA: { threshold: 1, positive: '우측 기울기', negative: '좌측 기울기' },
  KAS: { threshold: 2, positive: '외회전', negative: '내회전' },
  LLAS: { threshold: 2, positive: '우측 이동', negative: '좌측 이동' },
  FBA: { threshold: 2, positive: '회내', negative: '회외' }
};

const ABSOLUTE_LABEL_RULES = {
  LLD: { threshold: 1, label: '불균형' },
  LLD_F: { threshold: 1, label: '불균형' }
};

const SPECIAL_CLASSIFIERS = {
  PTA: (value) => {
    if (value <= -1) return '후방경사';
    if (value >= 15) return '전방경사';
    return '정상';
  },
  CVA: (value) => {
    if (value < 50) return '낮음(거북목)';
    if (value >= 70) return '높음(과신전)';
    return '정상';
  }
};

/**********************
 * 이상유형 분류기 (측정값 → DB의 이상유형 label)
 * 각 지표별 텍스트 기준에 매핑
 **********************/
function classifyAbnormalType(metricCode, value, normalText) {
  if (value == null) return '정상';

  if (SPECIAL_CLASSIFIERS[metricCode]) {
    const specialLabel = SPECIAL_CLASSIFIERS[metricCode](value);
    if (specialLabel !== '정상') return specialLabel;
  }

  const directionalRule = DIRECTIONAL_LABEL_RULES[metricCode];
  if (directionalRule) {
    const threshold = directionalRule.threshold ?? 0;
    if (value > threshold) return directionalRule.positive || '높음';
    if (value < -threshold) return directionalRule.negative || '낮음';
    return '정상';
  }

  const absRule = ABSOLUTE_LABEL_RULES[metricCode];
  if (absRule) {
    if (Math.abs(value) > absRule.threshold) return absRule.label;
    return '정상';
  }

  const norm = parseNormalRange(normalText);
  if (!norm) return '정상';
  const labels = RANGE_LABEL_RULES[metricCode];

  switch (norm.type) {
    case 'range': {
      if (value < norm.min) return labels?.low || '낮음';
      if (value > norm.max) return labels?.high || '높음';
      return '정상';
    }
    case 'min': {
      if (value < norm.min) return labels?.low || '낮음';
      return labels?.high ? labels.high : '정상';
    }
    case 'max': {
      if (value > norm.max) return labels?.high || '높음';
      return '정상';
    }
    default:
      return '정상';
  }
}

/**********************
 * 지표별 정상 텍스트 (리포트에 이미 쓰던 표기 그대로)
 **********************/
const NORMAL_TEXT = {
  CVA: '≥50°',
  HPD: '-2–2cm',
  TIA: '0–10°',
  SAA: '0–10°',
  PTA: '0–15°',
  KA:  '175–185°',
  Tibial: '0–10°',
  Tibial_Angle: '0–10°',
  QAngle: '10–20°',
  Q_Angle: '10–20°',
  KneeDev: '-1–3°',
  Knee_Deviation: '-1–3°',
  GSB: '-0.5–0.5cm',
  HPA: '-10–10°',
  PDS: '-3–3°',
  // 정면 지표
  STA: '≤3°',
  STA_F: '≤3°',
  POA: '≤3°',
  POA_F: '≤3°',
  TD: '0–3°',
  HTA: '≤3°',
  SPP: '0–3°',
  LLD: '≤1cm',
  LLD_F: '≤1cm',
  KAS: '-2–2°',
  LLAS: '-2–2°',
  FBA: '-2–2°'
};

const DB_METRIC_RULES = {
  CVA: { min: 50, max: 80, lowCode: "CVA_LOW", highCode: "CVA_HIGH" },
  HPD: { min: -2, max: 2, lowCode: "HPD_LOW", highCode: "HPD_HIGH" },
  TIA: { min: -5, max: 10, lowCode: "TIA_LOW", highCode: "TIA_HIGH" },
  SAA: { min: -5, max: 10, lowCode: "SAA_LOW", highCode: "SAA_HIGH" },
  PTA: {
    positiveCode: "PTA_ANT",
    negativeCode: "PTA_POST",
    absThreshold: 1,
    labelPositive: "전방경사",
    labelNegative: "후방경사"
  },
  KA: { min: 175, max: 185, lowCode: "KA_VARUS", highCode: "KA_VALGUS" },
  Tibial: { min: -5, max: 10, lowCode: "TIB_INTERNAL", highCode: "TIB_EXTERNAL" },
  QAngle: { min: 10, max: 20, lowCode: "QANGLE_SMALL", highCode: "QANGLE_LARGE" },
  KneeDev: { min: -1, max: 3, lowCode: "KNEEDEV_MEDIAL", highCode: "KNEEDEV_LATERAL" },
  LLD: { absThreshold: 1, highCode: "LLD_IMBALANCE", labelHigh: "불균형" },
  GSB: {
    positiveCode: "GSB_FORWARD",
    negativeCode: "GSB_BACKWARD",
    absThreshold: 0.5,
    labelPositive: "전방 편위",
    labelNegative: "후방 편위"
  },
  HPA: {
    positiveCode: "HPA_LEFT",
    negativeCode: "HPA_RIGHT",
    absThreshold: 5,
    labelPositive: "좌회전",
    labelNegative: "우회전"
  },
  PDS: {
    positiveCode: "PDS_HIGH",
    negativeCode: "PDS_LOW",
    absThreshold: 3,
    labelPositive: "골반 하강",
    labelNegative: "골반 거상"
  },
  STA: {
    positiveCode: "STA_HIGH",
    negativeCode: "STA_LOW",
    absThreshold: 2,
    labelPositive: "전방 경사",
    labelNegative: "후방 경사"
  },
  POA: {
    positiveCode: "POA_RIGHT",
    negativeCode: "POA_LEFT",
    absThreshold: 2,
    labelPositive: "우하강",
    labelNegative: "좌하강"
  },
  TD: {
    positiveCode: "TD_KYPHOSIS",
    negativeCode: "TD_LORDOSIS",
    absThreshold: 5,
    labelPositive: "후만 증가",
    labelNegative: "편평 흉추"
  },
  HTA: {
    positiveCode: "HTA_RIGHT",
    negativeCode: "HTA_LEFT",
    absThreshold: 1,
    labelPositive: "우측 기울기",
    labelNegative: "좌측 기울기"
  },
  SPP: {
    positiveCode: "SPP_FORWARD",
    negativeCode: "SPP_BACKWARD",
    absThreshold: 1,
    labelPositive: "전방 편위",
    labelNegative: "후방 편위"
  },
  KAS: {
    positiveCode: "KAS_EXTERNAL",
    negativeCode: "KAS_INTERNAL",
    absThreshold: 2,
    labelPositive: "외회전",
    labelNegative: "내회전"
  },
  LLAS: {
    positiveCode: "LLAS_RIGHT",
    negativeCode: "LLAS_LEFT",
    absThreshold: 2,
    labelPositive: "우측 이동",
    labelNegative: "좌측 이동"
  },
  FBA: {
    positiveCode: "FBA_PRONATION",
    negativeCode: "FBA_SUPINATION",
    absThreshold: 2,
    labelPositive: "회내",
    labelNegative: "회외"
  }
};

function evaluateMetricDeviationForDB(key, value) {
  if (value == null || Number.isNaN(value)) return { status: "정상" };
  const rule = DB_METRIC_RULES[key];
  if (!rule) return { status: "정상" };

  if (rule.positiveCode || rule.negativeCode) {
    const threshold = rule.absThreshold ?? 0;
    if (value > threshold && rule.positiveCode) {
      return {
        status: rule.labelPositive || "→ 편위(+)",
        deviationKey: rule.positiveCode
      };
    }
    if (value < -threshold && rule.negativeCode) {
      return {
        status: rule.labelNegative || "→ 편위(-)",
        deviationKey: rule.negativeCode
      };
    }
  }

  if (rule.min !== undefined && value < rule.min && rule.lowCode) {
    return { status: "↓ 낮음", deviationKey: rule.lowCode };
  }
  if (rule.max !== undefined && value > rule.max && rule.highCode) {
    return { status: "↑ 높음", deviationKey: rule.highCode };
  }

  if (rule.highCode && rule.absThreshold !== undefined) {
    if (Math.abs(value) > rule.absThreshold) {
      return {
        status: rule.labelHigh || "↑ 편차",
        deviationKey: rule.highCode
      };
    }
  }

  return { status: "정상" };
}

const METRIC_KEY_ALIASES = {
  STA_F: 'STA',
  POA_F: 'POA',
  Q_Angle: 'QAngle',
  QAngle: 'QAngle',
  Tibial_Angle: 'Tibial',
  Knee_Deviation: 'KneeDev',
  LLD_F: 'LLD'
};

function extractMetricValue(entry) {
  if (entry == null) return null;
  if (typeof entry === 'number' && !Number.isNaN(entry)) return entry;
  if (typeof entry === 'object') {
    const candidates = ['value_signed', 'value_deg', 'value_cm', 'value'];
    for (const key of candidates) {
      if (typeof entry[key] === 'number' && !Number.isNaN(entry[key])) {
        return entry[key];
      }
    }
  }
  return null;
}

function flattenFullMetrics(fullMetrics) {
  const flat = {};
  if (!fullMetrics || typeof fullMetrics !== 'object') return flat;
  for (const [rawKey, metric] of Object.entries(fullMetrics)) {
    const value = extractMetricValue(metric);
    if (value == null) continue;
    const canonicalKey = METRIC_KEY_ALIASES[rawKey] || rawKey;
    flat[canonicalKey] = value;
  }
  return flat;
}

/**********************
 * DB 매칭 핵심 함수
 * metrics: {CVA:72.3, PTA:5.2, ...} (After 기준 권장)
 **********************/

async function analyzeWithDB(metrics = {}) {
  await loadPostureDB();
  await loadPilatesDB(); // ✅ 필라테스 DB 로드

  const findings = [];
  const matches = [];
  const tight = new Set();
  const weak = new Set();

  const weights = {
    CVA: 3,
    SAA: 2,
    PTA: 2,
    KA: 1.5,
    GSB: 1.5,
    HPA: 1.2,
    TIA: 1.2,
    STA: 1.2,
    STA_F: 1.2,
    POA: 1.2,
    POA_F: 1.2,
    TD: 1.2,
    HTA: 1.2,
    LLD: 1.5,
    LLD_F: 1.5,
    Tibial: 1.0,
    Tibial_Angle: 1.0,
    SPP: 1.2,
    QAngle: 1.2,
    Q_Angle: 1.2,
    KneeDev: 1.0,
    Knee_Deviation: 1.0
  };

  for (const [rawKey, rawValue] of Object.entries(metrics)) {
    const code = METRIC_KEY_ALIASES[rawKey] || rawKey;
    if (NORMAL_TEXT[code] == null) continue;
    const numericValue =
      typeof rawValue === "number" ? rawValue : Number(rawValue);
    if (Number.isNaN(numericValue)) continue;

    const deviation = evaluateMetricDeviationForDB(code, numericValue);
    findings.push({
      code,
      value: numericValue,
      normal: NORMAL_TEXT[code],
      abnormal: deviation.status
    });

    if (!deviation.deviationKey) continue;
    const record =
      POSTURE_DB_MAP[deviation.deviationKey] ||
      POSTURE_DB_MAP[deviation.deviationKey?.toUpperCase()];
    if (!record) continue;

    try {
      const recommendation = await createRecommendationFromRecord(record, {
        code,
        abnormal: deviation.status,
        weight: weights[code] ?? 1
      });
      matches.push(recommendation);
      recommendation.tightMuscles.forEach((m) => tight.add(m));
      recommendation.weakMuscles.forEach((m) => weak.add(m));
    } catch (err) {
      console.warn('⚠️ 추천 생성 실패:', err);
    }
  }

  matches.sort((a, b) => (b.weight || 1) - (a.weight || 1));

  const tightList = Array.from(tight).filter(Boolean);
  const weakList = Array.from(weak).filter(Boolean);

  return {
    findings,
    topRecommendations: matches.slice(0, 12),
    muscles: {
      tight: tightList,
      weak: weakList
    },
    tight: tightList,
    weak: weakList
  };
}

function getRecordMuscleList(record, type) {
  if (!record) return [];
  if (record.muscle_pattern) {
    const primary = record.muscle_pattern[type]?.primary || [];
    const secondary = record.muscle_pattern[type]?.secondary || [];
    return [...primary, ...secondary].map((m) => m.trim()).filter(Boolean);
  }
  const field =
    type === "tight"
      ? record.Tight_Muscle ||
        record.tight_muscle ||
        record['긴장근육(주요)'] ||
        ''
      : record.Weak_Muscle ||
        record.weak_muscle ||
        record['약화근육(주요)'] ||
        '';
  return splitMuscleList(field);
}

async function createRecommendationFromRecord(record, context) {
  const tightList = getRecordMuscleList(record, 'tight');
  const weakList = getRecordMuscleList(record, 'weak');

  const postureName =
    record.posture_ko ||
    record['지표명'] ||
    record.Metric_Name_KR ||
    record.metric_name_kr ||
    record.metric_name_en ||
    context.code;

  const postureKeyRaw =
    record.posture_key ||
    record.key ||
    record.Index_Code ||
    record.Metric_Code ||
    context.code;

  const postureResult = {
    code: context.code,
    name: postureName,
    abnormal: context.abnormal,
    posture_key: postureKeyRaw ? postureKeyRaw.toLowerCase() : context.code,
    posture_ko: postureName,
    tight: tightList,
    weak: weakList,
    tightMuscles: tightList,
    weakMuscles: weakList,
    region: record.region || record['부위'] || ''
  };

  const pilatesBundle = await buildPilatesExerciseBundle(postureResult, record);

  return {
    code: context.code,
    name: postureName,
    abnormal: context.abnormal,
    weight: context.weight || 1,
    tight: tightList.join(', '),
    weak: weakList.join(', '),
    manual:
      record.recommended_focus?.strengthen?.join(', ') ||
      record['교정운동(도수/자가)'] ||
      '',
    mat: pilatesBundle.names['매트'],
    reformer: pilatesBundle.names['리포머'],
    cadillac: pilatesBundle.names['캐딜락'],
    chair: pilatesBundle.names['체어'],
    barrel: pilatesBundle.names['바렐'],
    pilatesExercises: pilatesBundle.map,
    tightMuscles: tightList,
    weakMuscles: weakList,
    note:
      (record.clinical_significance &&
        Array.isArray(record.clinical_significance)
        ? record.clinical_significance.join(', ')
        : record.clinical_significance) ||
      record.Notes ||
      record.notes ||
      record.Recommended_Strategy ||
      record.strategy ||
      '',
    level: record.level || record['추천레벨(초급/중급/고급)'] || ''
  };
}

async function buildPilatesExerciseBundle(postureResult, record) {
  const equipmentKeys = ['매트', '리포머', '캐딜락', '체어', '바렐'];
  const bundle = {};
  equipmentKeys.forEach((key) => {
    bundle[key] = [];
  });

  try {
    const matchedPilates = await linkPilatesDB(postureResult);
    matchedPilates.forEach((p) => {
      const equipment = (p.equipment_ko || p.equipment_en || '')
        .toLowerCase()
        .trim();
      const exercise = {
        name: p.exercise_ko || p.exercise_en || p.name || '',
        en: p.exercise_en || '',
        ko: p.exercise_ko || '',
        purpose: p.purpose || '',
        how_to_do: p.how_to_do || '',
        sets_reps: p.sets_reps || '',
        key_cues: p.key_cues || '',
        precaution: p.precaution || ''
      };
      if (!exercise.name && !exercise.ko) return;
      if (equipment.includes('매트') || equipment.includes('mat')) {
        bundle['매트'].push(exercise);
      }
      if (equipment.includes('리포머') || equipment.includes('reformer')) {
        bundle['리포머'].push(exercise);
      }
      if (equipment.includes('캐딜락') || equipment.includes('cadillac')) {
        bundle['캐딜락'].push(exercise);
      }
      if (equipment.includes('체어') || equipment.includes('chair')) {
        bundle['체어'].push(exercise);
      }
      if (
        equipment.includes('바렐') ||
        equipment.includes('barrel') ||
        equipment.includes('spine corrector')
      ) {
        bundle['바렐'].push(exercise);
      }
    });
  } catch (err) {
    console.warn('⚠️ 필라테스 운동 매칭 실패:', err);
  }

  const fallbackMap = {
    '매트': record['필라테스운동(Mat)'] || record.mat || '',
    '리포머': record['필라테스운동(Reformer)'] || record.reformer || '',
    '캐딜락': record['필라테스운동(Cadillac)'] || record.cadillac || '',
    '체어': record['필라테스운동(Chair)'] || record.chair || '',
    '바렐': record['필라테스운동(Barrel)'] || record.barrel || ''
  };

  Object.entries(fallbackMap).forEach(([key, value]) => {
    if (value && bundle[key].length === 0) {
      bundle[key].push({ name: value, ko: value });
    }
  });

  const names = {};
  Object.entries(bundle).forEach(([key, list]) => {
    names[key] = list
      .map((ex) => ex.name || ex.ko)
      .filter(Boolean)
      .join(', ');
  });

  return { map: bundle, names };
}

/**********************
 * 내러티브 생성 (PDF에 바로 출력)
 **********************/
function buildAINarrative(analysis) {
  const bad = analysis.findings.filter(f => f.abnormal !== '정상');
  const good = analysis.findings.filter(f => f.abnormal === '정상');
  const lines = [];

  // ✅ 전체 체형 점수 계산
  const totalScore = computeScore(
    analysis.findings.find(f => f.code === 'CVA')?.value || null,
    analysis.findings.find(f => f.code === 'PTA')?.value || null,
    analysis.findings.find(f => f.code === 'KA')?.value || null
  );
  lines.push(`📊 전체 체형 종합 점수: ${totalScore.score}/100점`);
  if(totalScore.reasons && totalScore.reasons.length > 0) {
    lines.push(`감점 근거: ${totalScore.reasons.join(', ')}`);
  }

  // ✅ 측면 분석 결과 상세 표시
  lines.push('\n📐 측면 분석 결과');
  const sideMetrics = ['CVA', 'HPD', 'TIA', 'SAA', 'PTA', 'KA', 'Tibial_Angle', 'GSB', 'HPA'];
  sideMetrics.forEach(code => {
    const finding = analysis.findings.find(f => f.code === code);
    if(finding) {
      const unit = /cm$/.test(finding.normal) ? 'cm' : '°';
      const status = finding.abnormal === '정상' ? 'normal' : 
                     finding.abnormal.includes('높음') ? 'severe' :
                     finding.abnormal.includes('낮음') ? 'mild' : 'moderate';
      const statusText = status === 'normal' ? '정상' : 
                         status === 'severe' ? '심각' :
                         status === 'mild' ? '경미' : '중등도';
      lines.push(`${code}: ${finding.value.toFixed(2)}${unit} (${statusText})`);
    }
  });

  // ✅ PDS 종합점수 (있는 경우)
  const pdsFinding = analysis.findings.find(f => f.code === 'PDS');
  if(pdsFinding) {
    lines.push(`PDS: ${pdsFinding.value.toFixed(1)}° (${pdsFinding.abnormal === '정상' ? '정상' : '주의'})`);
    lines.push(`PDS 종합점수: ${pdsFinding.value.toFixed(1)} (${pdsFinding.abnormal === '정상' ? '정상' : '주의'})`);
  }

  // ✅ 핵심 이슈 상세 설명
  if (bad.length) {
    lines.push('\n⚠️ 주요 문제 패턴:');
    bad.forEach(b => {
      const dbItem = POSTURE_DB.find(r => {
        const dbCode = String(r['지표코드'] || '').toUpperCase();
        const dbAbnormal = String(r['이상유형'] || '');
        return dbCode === b.code.toUpperCase() && dbAbnormal.includes(b.abnormal);
      });
      
      if(dbItem) {
        lines.push(`\n📍 ${dbItem['지표명'] || b.code} (${b.abnormal})`);
        if(dbItem['원인']) lines.push(`  원인: ${dbItem['원인']}`);
        if(dbItem['증상']) lines.push(`  증상: ${dbItem['증상']}`);
        if(dbItem['임상적의미']) lines.push(`  임상적 의미: ${dbItem['임상적의미']}`);
        if(dbItem['긴장근육(주요)']) lines.push(`  긴장된 근육: ${dbItem['긴장근육(주요)']}`);
        if(dbItem['약화근육(주요)']) lines.push(`  약화된 근육: ${dbItem['약화근육(주요)']}`);
      } else {
        lines.push(`\n📍 ${b.code}: ${b.value}${/cm$/.test(b.normal) ? 'cm' : '°'} (${b.abnormal})`);
      }
    });
  } else {
    lines.push('\n✅ 모든 핵심 지표가 정상 범위입니다.');
  }

  if (good.length) {
    lines.push(`\n✓ 안정 항목: ${good.map(g => g.code).join(', ')}`);
  }

  // ✅ 근육 불균형 상세
  if (analysis.muscles.tight.length || analysis.muscles.weak.length) {
    lines.push('\n💪 근육 불균형 분석:');
    if(analysis.muscles.tight.length > 0) {
      lines.push(`긴장된 근육: ${analysis.muscles.tight.join(', ')}`);
      lines.push(`  → 이 근육들은 과도하게 수축되어 있어 스트레칭과 이완이 필요합니다.`);
    }
    if(analysis.muscles.weak.length > 0) {
      lines.push(`약화된 근육: ${analysis.muscles.weak.join(', ')}`);
      lines.push(`  → 이 근육들은 약화되어 있어 강화 운동이 필요합니다.`);
    }
  }

  // ✅ AI 실시간 분석
  lines.push('\n🤖 AI 실시간 분석');
  lines.push('데이터베이스 기반 분석 완료');

  return lines.join('\n');
}

/**********************
 * 통합 실행 함수
 * (측정값 metrics는 After 기준 혹은 종합값)
 **********************/
async function runDBDrivenAI(metrics) {
  const analysis = await analyzeWithDB(metrics);
  return analysis;
}

/**********************
 * Before-After 비교 AI 분석 함수
 * before: {CVA: 63.4, HPD: 0.9, ...}
 * after: {CVA: 72.3, HPD: 0.9, ...}
 **********************/
async function analyzePostureAI(before, after) {
  const db = await loadPostureDB();
  if (!db || db.length === 0) {
    console.warn('DB가 로드되지 않았습니다. 기존 분석을 사용합니다.');
    return { error: 'DB 로드 실패', results: [] };
  }

  const results = [];
  
  // DB 구조에 맞게 매칭 (지표코드 또는 metric 필드 확인)
  for (const [metric, beforeVal] of Object.entries(before)) {
    const afterVal = after[metric];
    if (afterVal == null) continue;
    
    // DB에서 해당 지표 찾기 (지표코드 또는 metric 필드로 매칭)
    const rule = db.find(item => {
      const dbCode = String(item['지표코드'] || item.metric || '').toUpperCase();
      return dbCode === metric.toUpperCase();
    });
    
    if (!rule) continue;

    const delta = afterVal - beforeVal;
    
    // 정상 범위 파싱
    const normalText = rule['정상범위'] || rule.normalRange || NORMAL_TEXT[metric];
    const norm = parseNormalRange(normalText);
    
    let status = '정상';
    if (norm) {
      if (norm.type === 'range') {
        if (afterVal < norm.min) status = '낮음';
        else if (afterVal > norm.max) status = '높음';
        else status = '정상';
      } else if (norm.type === 'min') {
        if (afterVal < norm.min) status = '낮음';
        else if (metric === 'CVA' && afterVal >= 70) status = '높음(과신전)';
        else status = '정상';
      } else if (norm.type === 'max') {
        if (afterVal > norm.max) status = '높음';
        else status = '정상';
      }
    }

    results.push({
      metric: metric,
      name: rule['지표명'] || rule.name || metric,
      before: beforeVal,
      after: afterVal,
      change: delta.toFixed(1),
      unit: rule['측정단위'] || rule.unit || '°',
      status,
      aiComment: rule['문제설명'] || rule.aiComment || '',
      musclePattern: {
        tight: rule['긴장근육(주요)'] || rule.musclePattern?.tight || '',
        weak: rule['약화근육(주요)'] || rule.musclePattern?.weak || ''
      },
      pilatesSession: {
        mat: rule['필라테스운동(Mat)'] || rule.pilatesSession?.mat || '',
        reformer: rule['필라테스운동(Reformer)'] || rule.pilatesSession?.reformer || '',
        cadillac: rule['필라테스운동(Cadillac)'] || rule.pilatesSession?.cadillac || '',
        chair: rule['필라테스운동(Chair)'] || rule.pilatesSession?.chair || '',
        barrel: rule['필라테스운동(Barrel)'] || rule.pilatesSession?.barrel || ''
      },
      guide: rule['교정운동(도수/자가)'] || rule.guide || rule.exerciseGuide || '',
      clinical: rule['임상적의미'] || rule.clinical || '',
      level: rule['추천레벨(초급/중급/고급)'] || rule.level || ''
    });
  }
  
  console.table(results);
  return { results, error: null };
}

/**********************
 * Before-After 비교 그래프 생성 (Chart.js)
 **********************/
function drawComparisonChart(before, after, containerId = null, options = {}) {
  const canvas = containerId ? document.getElementById(containerId) : document.createElement('canvas');
  if (!canvas) {
    console.error('Canvas element not found');
    return null;
  }
  
  if (!containerId) {
    canvas.width = 600;
    canvas.height = 300;
  }
  
  const ctx = canvas.getContext('2d');
  
  // 기존 Chart 인스턴스가 있으면 제거
  if (canvas.chart) {
    canvas.chart.destroy();
  }
  
  const labels = Object.keys(before);
  const beforeData = Object.values(before);
  const afterData = labels.map(key => after[key] || 0);
  
  // PDF용으로 사용할 때는 애니메이션 비활성화
  const disableAnimation = options.disableAnimation !== false; // 기본값 true
  
  canvas.chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'Before',
          data: beforeData,
          backgroundColor: 'rgba(255, 99, 132, 0.6)',
          borderColor: 'rgba(255, 99, 132, 1)',
          borderWidth: 1
        },
        {
          label: 'After',
          data: afterData,
          backgroundColor: 'rgba(54, 162, 235, 0.6)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 1
        }
      ]
    },
    options: {
      responsive: !containerId, // containerId가 있으면 false
      maintainAspectRatio: containerId ? false : true,
      animation: disableAnimation ? false : {
        duration: 0 // 애니메이션 비활성화
      },
      transitions: {
        active: {
          animation: {
            duration: 0
          }
        }
      },
      scales: { 
        y: { beginAtZero: true },
        x: {
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        }
      },
      plugins: {
        legend: { position: 'top' },
        title: { 
          display: true, 
          text: 'Before–After 비교 그래프',
          font: { size: 16, weight: 'bold' }
        }
      }
    }
  });
  
  return canvas;
}

/**********************
 * 모바일 감지 함수
 **********************/
function isMobileDevice() {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || 
         (window.innerWidth <= 768 && 'ontouchstart' in window);
}

/**********************
 * 모바일 호환 PDF 저장 기능
 **********************/
async function savePDFMobileCompatible(fileName, pdfInstance) {
  try {
    // 모바일에서는 간단한 방식 우선 사용 (메모리 절약)
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);
    
    // 모바일에서는 직접 save 메서드 우선 시도 (가장 안정적)
    if (isMobileDevice()) {
      try {
        // 작은 지연으로 UI 블로킹 방지
        await new Promise(resolve => setTimeout(resolve, 100));
        pdfInstance.save(fileName);
        console.log('✅ PDF 저장 성공 (직접 save)');
        return;
      } catch (saveErr) {
        console.warn('⚠️ 직접 save 실패:', saveErr);
        // 폴백으로 진행
      }
    }
    
    // Blob 생성 (데스크톱 또는 직접 save 실패 시)
    let blob;
    try {
      blob = pdfInstance.output('blob');
      if (!blob || blob.size === 0) {
        throw new Error('PDF Blob 생성 실패');
      }
    } catch (blobErr) {
      console.error('❌ Blob 생성 실패:', blobErr);
      // 최종 폴백: data URI 사용
      try {
        const dataUri = pdfInstance.output('datauristring');
        const link = document.createElement('a');
        link.href = dataUri;
        link.download = fileName;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
          if (document.body.contains(link)) {
            document.body.removeChild(link);
          }
        }, 1000);
        return;
      } catch (finalErr) {
        throw new Error('PDF 저장에 실패했습니다: ' + finalErr.message);
      }
    }
    
    // 모바일에서 Web Share API 사용 (선택적)
    if (isMobileDevice() && navigator.share && navigator.canShare && blob.size < 50 * 1024 * 1024) {
      try {
        const file = new File([blob], fileName, { type: 'application/pdf' });
        if (navigator.canShare({ files: [file] })) {
          await navigator.share({
            title: fileName.replace('.pdf', ''),
            files: [file]
          });
          console.log('✅ PDF 공유 성공 (Web Share API)');
          return;
        }
      } catch (shareErr) {
        if (shareErr.name === 'AbortError') {
          return; // 사용자 취소
        }
        console.warn('⚠️ Web Share API 실패:', shareErr);
      }
    }
    
    // 데스크톱 또는 안전한 다운로드 링크 사용
    const fileURL = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = fileURL;
    link.download = fileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    
    // 안전한 클릭
    requestAnimationFrame(() => {
      try {
        link.click();
      } catch (e) {
        console.warn('클릭 실패, 대체 방법 사용');
        const event = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: window
        });
        link.dispatchEvent(event);
      }
    });
    
    // 정리 (지연 시간 증가)
    setTimeout(() => {
      try {
        URL.revokeObjectURL(fileURL);
        if (document.body.contains(link)) {
          document.body.removeChild(link);
        }
      } catch (e) {
        console.warn('정리 중 오류:', e);
      }
    }, 3000);
    
  } catch (err) {
    console.error('❌ PDF 저장 실패:', err);
    alert('⚠️ PDF 저장 중 오류가 발생했습니다.\n페이지를 새로고침하고 다시 시도해주세요.');
  }
}

/**********************
 * 이미지 저장 함수 (캔버스나 그래프 등)
 **********************/
async function saveImageMobile(canvas, fileName = 'report_image.png') {
  try {
    // Canvas를 Blob으로 변환
    const blob = await new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('이미지 변환 실패'));
        }
      }, 'image/png', 1.0);
    });
    
    // iOS 감지
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);
    
    // 모바일에서 Web Share API 사용
    if (isMobileDevice() && navigator.share && navigator.canShare) {
      try {
        const file = new File([blob], fileName, { type: 'image/png' });
        
        if (navigator.canShare({ files: [file] })) {
          await navigator.share({
            title: fileName.replace('.png', ''),
            files: [file]
          });
          console.log('✅ 이미지 공유 성공 (Web Share API)');
          return;
        }
      } catch (shareErr) {
        if (shareErr.name !== 'AbortError') {
          console.warn('⚠️ Web Share API 실패, 폴백 사용:', shareErr);
        } else {
          return;
        }
      }
    }
    
    // iOS에서 새 창으로 열기
    if (isIOS) {
      try {
        const fileURL = URL.createObjectURL(blob);
        const newWindow = window.open(fileURL, '_blank');
        if (newWindow) {
          setTimeout(() => {
            URL.revokeObjectURL(fileURL);
            alert('🖼️ 이미지가 새 창에서 열렸습니다. 길게 눌러 저장하세요.');
          }, 100);
          return;
        }
      } catch (err) {
        console.warn('⚠️ iOS 새 창 열기 실패:', err);
      }
    }
    
    // Android 또는 데스크톱: 다운로드 링크 사용
    const fileURL = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = fileURL;
    link.download = fileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    
    // 강제 클릭
    try {
      link.click();
    } catch (e1) {
      try {
        const clickEvent = new MouseEvent('click', {
          view: window,
          bubbles: true,
          cancelable: true,
          buttons: 1
        });
        link.dispatchEvent(clickEvent);
      } catch (e2) {
        window.open(fileURL, '_blank');
      }
    }
    
    setTimeout(() => {
      URL.revokeObjectURL(fileURL);
      if (document.body.contains(link)) {
        document.body.removeChild(link);
      }
    }, 2000);
    
    if (isMobileDevice()) {
      setTimeout(() => {
        alert('🖼️ 이미지 저장을 시도했습니다. 다운로드 폴더나 파일 앱에서 확인하세요.');
      }, 500);
    }
  } catch (err) {
    console.error('❌ 이미지 저장 오류:', err);
    alert('⚠️ 이미지 저장 중 문제가 발생했습니다: ' + err.message);
  }
}

/**********************
 * Chart.js 렌더링 완료 대기 함수
 **********************/
function waitForChartRender(chart, timeout = 2000) {
  return new Promise((resolve, reject) => {
    if (!chart || !chart.canvas) {
      reject(new Error('Chart 인스턴스가 유효하지 않습니다.'));
      return;
    }
    
    try {
      // Chart.js의 update 메서드를 호출하여 강제로 렌더링
      if (typeof chart.update === 'function') {
        chart.update('none'); // 애니메이션 없이 즉시 업데이트
      }
      
      // 렌더링 완료를 보장하기 위해 여러 프레임 대기
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // 최종 확인: Canvas에 실제로 그려졌는지 확인
            try {
              const ctx = chart.canvas.getContext('2d');
              // 캔버스 크기 확인 (0이면 오류 발생)
              if (chart.canvas.width > 0 && chart.canvas.height > 0) {
                const sampleWidth = Math.min(chart.canvas.width, 10);
                const sampleHeight = Math.min(chart.canvas.height, 10);
                const imageData = ctx.getImageData(0, 0, sampleWidth, sampleHeight);
                const hasContent = imageData.data.some((val, idx) => idx % 4 !== 3 && val !== 0); // 알파 채널 제외하고 픽셀 데이터 확인
                
                if (hasContent || chart.canvas.width > 0) {
                  resolve(chart);
                } else {
                  // 내용이 없어도 타임아웃 후 진행
                  setTimeout(() => resolve(chart), 100);
                }
              } else {
                // 캔버스 크기가 0이면 타임아웃 후 진행
                setTimeout(() => resolve(chart), 100);
              }
            } catch (err) {
              // getImageData 오류 발생 시에도 진행
              console.warn('Chart 캔버스 확인 중 오류 (무시됨):', err);
              setTimeout(() => resolve(chart), 100);
            }
          });
        });
      });
      
      // 타임아웃 설정 (안전장치)
      setTimeout(() => {
        resolve(chart);
      }, timeout);
    } catch (err) {
      console.warn('Chart 렌더링 대기 중 오류:', err);
      // 오류가 발생해도 진행 (최소한의 렌더링은 되었을 것)
      setTimeout(() => resolve(chart), 100);
    }
  });
}

let chartJsReadyPromise = null;

function loadChartJsFromCdn() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error('Chart.js CDN 로드 실패'));
    document.head.appendChild(script);
  });
}

function ensureChartLibrary(timeout = 3000) {
  if (typeof Chart !== 'undefined') {
    return Promise.resolve();
  }
  if (chartJsReadyPromise) {
    return chartJsReadyPromise;
  }
  chartJsReadyPromise = new Promise((resolve, reject) => {
    const start = Date.now();
    const poll = () => {
      if (typeof Chart !== 'undefined') {
        resolve();
      } else if (Date.now() - start >= timeout) {
        loadChartJsFromCdn().then(resolve).catch(reject);
      } else {
        setTimeout(poll, 100);
      }
    };
    poll();
  });
  return chartJsReadyPromise;
}

/**********************
 * 간단한 PDF 생성 함수 (Before-After 비교 중심)
 * centerName, memberName: 센터명, 회원명
 * before, after: {CVA: 63.4, HPD: 0.9, ...} 형태의 metrics 객체
 **********************/
async function generatePosturePDF(centerName, memberName, before, after) {
  try {
    await exportAsPdf({ centerName, memberName });
    return;
  } catch (primaryErr) {
    console.warn('확장 PDF 생성 실패, 간단 버전을 시도합니다:', primaryErr);
  }

  try {
    const analysis = await analyzePostureAI(before, after);
    if (analysis?.error) {
      throw new Error(analysis.error);
    }

    const { jsPDF } = window.jspdf;
    if (!jsPDF) {
      throw new Error('jsPDF가 로드되지 않았습니다.');
    }

    const pdf = new jsPDF('p', 'mm', 'a4');
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(20);
    pdf.text('AI 자세 분석 리포트', 105, 20, { align: 'center' });
    pdf.setFontSize(12);
    pdf.text(`센터명: ${centerName || '미입력'}`, 20, 35);
    pdf.text(`회원명: ${memberName || '미입력'}`, 20, 42);
    pdf.text(`생성일: ${new Date().toLocaleDateString('ko-KR')}`, 20, 49);

    try {
      await ensureChartLibrary();
    } catch (chartErr) {
      console.warn('Chart.js 준비 실패:', chartErr);
    }
    const chartCanvas = typeof Chart !== 'undefined' ? drawComparisonChart(before, after, null, { disableAnimation: true }) : null;
    if (chartCanvas && chartCanvas.chart) {
      await waitForChartRender(chartCanvas.chart);
      const chartImg = chartCanvas.toDataURL('image/png', 1.0);
      if (chartImg && chartImg !== 'data:,') {
        pdf.addImage(chartImg, 'PNG', 10, 60, 180, 80);
        pdf.text('Before–After 변화 시각화', 20, 155);
      } else {
        pdf.text('⚠️ 그래프 생성 실패', 20, 60);
      }
    } else {
      pdf.text('⚠️ 그래프 데이터를 불러오지 못했습니다.', 20, 60);
    }

    let y = 170;
    const results = Array.isArray(analysis?.results) ? analysis.results : [];
    for (const item of results) {
      if (y > 260) {
        pdf.addPage();
        y = 20;
      }
      pdf.setFontSize(11);
      pdf.text(`${item.name || item.metric || '지표'}`, 20, y);
      pdf.setFontSize(10);
      pdf.text(`Before: ${item.before}${item.unit} | After: ${item.after}${item.unit}`, 20, y + 6);
      pdf.text(`변화: ${item.change >= 0 ? '+' : ''}${item.change}${item.unit} → 상태: ${item.status || '—'}`, 20, y + 12);
      let nextY = y + 18;
      if (item.aiComment) {
        const commentLines = pdf.splitTextToSize(`💬 ${item.aiComment}`, 170);
        pdf.text(commentLines, 20, nextY);
        nextY += commentLines.length * 5;
      }
      if (item.musclePattern && (item.musclePattern.tight || item.musclePattern.weak)) {
        const muscleText = `🦴 근육패턴: 긴장(${item.musclePattern.tight || '—'}) / 약화(${item.musclePattern.weak || '—'})`;
        const muscleLines = pdf.splitTextToSize(muscleText, 170);
        pdf.text(muscleLines, 20, nextY);
        nextY += muscleLines.length * 5;
      }
      if (item.pilatesSession) {
        const pilatesParts = [];
        if (item.pilatesSession.mat) pilatesParts.push(`Mat: ${item.pilatesSession.mat}`);
        if (item.pilatesSession.reformer) pilatesParts.push(`Reformer: ${item.pilatesSession.reformer}`);
        if (item.pilatesSession.cadillac) pilatesParts.push(`Cadillac: ${item.pilatesSession.cadillac}`);
        if (item.pilatesSession.chair) pilatesParts.push(`Chair: ${item.pilatesSession.chair}`);
        if (item.pilatesSession.barrel) pilatesParts.push(`Barrel: ${item.pilatesSession.barrel}`);
        if (pilatesParts.length > 0) {
          const pilatesText = `🧘 필라테스 세션: ${pilatesParts.join(' | ')}`;
          const pilatesLines = pdf.splitTextToSize(pilatesText, 170);
          pdf.text(pilatesLines, 20, nextY);
          nextY += pilatesLines.length * 5;
        }
      }
      if (item.guide) {
        const guideLines = pdf.splitTextToSize(`🏋 운동가이드: ${item.guide}`, 170);
        pdf.text(guideLines, 20, nextY);
        nextY += guideLines.length * 5;
      }
      y = nextY + 8;
    }

    const fileName = `${memberName || '회원'}_AI_Report_v2.pdf`;
    await savePDFMobileCompatible(fileName, pdf);
  } catch (err) {
    console.error('PDF 생성 오류:', err);
    alert('간단 PDF 생성 중 오류가 발생했습니다: ' + (err.message || '알 수 없는 오류'));
  }
}

// 측정 결과 기반 필라테스 추천 (올바른 metrics 구조 사용)
function recommendPilatesFromMetrics(beforeMetrics, afterMetrics) {
  const recommendations = [];
  
  // 헬퍼 함수: 메트릭 값 가져오기
  const getMetricValue = (metrics, key) => {
    if(!metrics) return null;
    const fullMetrics = metrics.fullMetrics || {};
    const metric = fullMetrics[key];
    if(!metric) return null;
    return metric.value !== undefined ? metric.value : 
           (metric.value_deg !== undefined ? metric.value_deg : 
           (metric.value_cm !== undefined ? metric.value_cm : null));
  };
  
  // CVA (거북목) 개선 - CVA가 증가하면 개선
  const cvaBefore = getMetricValue(beforeMetrics, 'CVA');
  const cvaAfter = getMetricValue(afterMetrics, 'CVA');
  if(cvaBefore != null && cvaAfter != null && cvaAfter > cvaBefore && cvaAfter < 50) {
    recommendations.push({
      issue: '거북목 개선',
      muscles: ['심부경부굴근', '상부승모근'],
      exercises: ['Chin Tuck', 'Swan', 'Pulling Straps'],
      pilates: {
        '매트': ['Chin Tuck', 'Swan'],
        '리포머': ['Pulling Straps', 'Neck Pull'],
        '캐딜락': ['Tower Prep']
      }
    });
  }
  
  // CVA가 50도 미만이면 거북목 문제
  if(cvaAfter != null && cvaAfter < 50) {
    recommendations.push({
      issue: '거북목 개선',
      muscles: ['심부경부굴근', '상부승모근'],
      exercises: ['Chin Tuck', 'Swan', 'Pulling Straps'],
      pilates: {
        '매트': ['Chin Tuck', 'Swan'],
        '리포머': ['Pulling Straps', 'Neck Pull'],
        '캐딜락': ['Tower Prep']
      }
    });
  }
  
  // PTA (골반 전방경사) 교정 - PTA가 15도 초과면 과전경사
  const ptaBefore = getMetricValue(beforeMetrics, 'PTA');
  const ptaAfter = getMetricValue(afterMetrics, 'PTA');
  if(ptaAfter != null && ptaAfter > 15) {
    recommendations.push({
      issue: '과전경사 골반',
      muscles: ['복부 코어', '둔근'],
      exercises: ['Pelvic Curl', 'Bridge', 'Hundred'],
      pilates: {
        '매트': ['Pelvic Curl', 'Bridge', 'Hundred'],
        '리포머': ['Bridge on Reformer', 'Footwork'],
        '캐딜락': ['Leg Springs']
      }
    });
  }
  
  // KA (무릎각) - X자 다리 (KA < 175도)
  const kaBefore = getMetricValue(beforeMetrics, 'KA');
  const kaAfter = getMetricValue(afterMetrics, 'KA');
  if(kaAfter != null && kaAfter < 175) {
    recommendations.push({
      issue: 'X자 다리 교정',
      muscles: ['중둔근', '대둔근'],
      exercises: ['Side-Lying Leg Lift', 'Clamshell'],
      pilates: {
        '매트': ['Side-Lying Leg Lift', 'Clamshell'],
        '리포머': ['Side Splits'],
        '캐딜락': ['Side Leg Springs']
      }
    });
  }
  
  // SAA (어깨 전방각) - 라운드 숄더 (SAA > 10도)
  const saaBefore = getMetricValue(beforeMetrics, 'SAA');
  const saaAfter = getMetricValue(afterMetrics, 'SAA');
  if(saaAfter != null && saaAfter > 10) {
    recommendations.push({
      issue: '라운드 숄더 안정화',
      muscles: ['흉근 이완', '견갑 안정화'],
      exercises: ['Prone Scapular Retraction', 'Arm Springs', 'Chest Expansion'],
      pilates: {
        '매트': ['Prone Scapular Retraction', 'Chest Expansion'],
        '리포머': ['Arm Springs', 'Pulling Straps'],
        '캐딜락': ['Chest Expansion on Cadillac']
      }
    });
  }
  
  // 중복 제거 (같은 issue가 있으면 하나만 유지)
  const uniqueRecommendations = [];
  const seenIssues = new Set();
  recommendations.forEach(rec => {
    if(!seenIssues.has(rec.issue)) {
      seenIssues.add(rec.issue);
      uniqueRecommendations.push(rec);
    }
  });
  
  console.log('필라테스 추천 생성:', uniqueRecommendations.length, '개');
  return uniqueRecommendations;
}

// ✅ PDF 내보내기 유틸 (헤더/푸터 포함)
function exportAsPdf(options = {}) {
  const {
    fileName = null, // null이면 자동 생성
    userName = localStorage.getItem('userName') || '사용자',
    centerName = localStorage.getItem('centerName') || null,
    memberName = localStorage.getItem('memberName') || null,
    appName = 'DIT 자세 분석 AI',
    logoUrl = null
  } = options;
  
  // 파일명 자동 생성 (센터명/회원명 우선)
  let finalFileName = fileName;
  if(!finalFileName) {
    if(centerName && memberName) {
      finalFileName = `${centerName}_${memberName}_자세분석리포트_${new Date().toISOString().split('T')[0]}.pdf`;
    } else {
      finalFileName = `DIT_자세_분석_리포트_${cur}_${new Date().toISOString().split('T')[0]}.pdf`;
    }
  }
  
  return new Promise(async (resolve, reject) => {
    try {
      // 라이브러리 확인
      if (!window.jspdf || !window.jspdf.jsPDF) {
        throw new Error("jsPDF 라이브러리가 로드되지 않았습니다.");
      }
      if (typeof html2canvas === 'undefined') {
        throw new Error("html2canvas 라이브러리가 로드되지 않았습니다.");
      }
      
      const { jsPDF } = window.jspdf;
      const {
        canvases,
        includeHeatmapPage,
        totalPages,
        pageIndexMap
      } = await captureReportCanvases({
        centerName,
        memberName,
        appName,
        logoUrl
      });
      
    // PDF 생성 (마진 24px = 약 0.6cm, 폰트 안전화)
    const pdf = new jsPDF({orientation:"portrait", unit:"px", format:"a4"});
    // 폰트 안전화: helvetica만 사용 (폰트 오류 방지)
    try {
      pdf.setFont('helvetica', 'normal');
    } catch(err) {
      console.warn('폰트 설정 실패, 기본 폰트 사용:', err);
    }
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();
    const margin = 24; // Dart 코드의 margin: EdgeInsets.all(24)와 동일
    const imgW = pageW - (margin * 2);
    
    // PDF 생성용 캔버스 크기 제한 (모바일/데스크톱 구분)
    // 4개 사진 처리 시 메모리 절약을 위해 더 낮춤
    const isMobileForPDF = isMobileDevice();
    const PDF_MAX_CANVAS_EDGE = isMobileForPDF ? 900 : 1200;
    
    const coverCanvas = canvases.cover;
    if (!coverCanvas) {
      throw new Error("표지 캔버스를 생성하지 못했습니다.");
    }
    const heatmapCanvas = canvases.heatmap;
    const metricsCanvas = canvases.metrics;
    const aiSummaryCanvas = canvases.aiSummary;
    const pilatesCanvas = canvases.pilates;
    const aiDeepCanvas = canvases.aiDeep;
    const conclusionCanvas = canvases.conclusion;
    
    // 첫 페이지: 제목과 이미지 (압축 적용)
    const compressCanvasForPDF = (canvas, maxSize = PDF_MAX_CANVAS_EDGE) => {
      if (!canvas || canvas.width === 0 || canvas.height === 0) return canvas;
      if (canvas.width > maxSize || canvas.height > maxSize) {
        const ratio = Math.min(maxSize / canvas.width, maxSize / canvas.height);
        const newCanvas = document.createElement('canvas');
        newCanvas.width = Math.floor(canvas.width * ratio);
        newCanvas.height = Math.floor(canvas.height * ratio);
        const ctx = newCanvas.getContext('2d');
        ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height);
        return newCanvas;
      }
      return canvas;
    };
    
    const compressedCover = compressCanvasForPDF(coverCanvas, PDF_MAX_CANVAS_EDGE);
    const coverTargetW = Math.min(imgW, compressedCover.width);
    const coverScale = coverTargetW / compressedCover.width;
    const img1H = compressedCover.height * coverScale;
    const maxImg1H = pageH - margin * 2;
    const coverX = margin + (imgW - coverTargetW) / 2;
    const coverH = Math.min(img1H, maxImg1H);
    
    try {
      // JPEG로 변환하여 크기 줄이기 (4개 사진 처리 시 품질 낮춤)
      const coverImageData = compressedCover.toDataURL("image/jpeg", 0.7);
      pdf.addImage(
        coverImageData,
        "JPEG",
        coverX,
        margin,
        coverTargetW,
        coverH
      );
    } catch (err) {
      console.warn('표지 이미지 추가 실패, PNG로 재시도:', err);
      try {
        const coverImageData = compressedCover.toDataURL("image/png");
        pdf.addImage(
          coverImageData,
          "PNG",
          coverX,
          margin,
          coverTargetW,
          coverH
        );
      } catch (err2) {
        console.error('표지 이미지 추가 완전 실패:', err2);
        throw new Error('표지 이미지를 PDF에 추가할 수 없습니다.');
      }
    }
    
    // 페이지 2-6 추가 (간단한 추가 함수)
    const addPageToPdf = (canvas) => {
      if (!canvas) return;
      const maxImgH = pageH - margin * 2;
      const targetWidth = Math.min(imgW, canvas.width);
      const scaleRatio = targetWidth / canvas.width;
      const pageHeightPx = Math.max(160, Math.floor(maxImgH / (scaleRatio || 1)));
      const overlapPx = Math.max(pageHeightPx * 0.45, 220);

      // 이미지 압축 함수 (크기 제한 및 품질 조정)
      const compressCanvas = (canvas, maxSize = PDF_MAX_CANVAS_EDGE) => {
        if (!canvas || canvas.width === 0 || canvas.height === 0) return canvas;
        
        // 이미지가 너무 크면 리사이즈
        if (canvas.width > maxSize || canvas.height > maxSize) {
          const ratio = Math.min(maxSize / canvas.width, maxSize / canvas.height);
          const newCanvas = document.createElement('canvas');
          newCanvas.width = Math.floor(canvas.width * ratio);
          newCanvas.height = Math.floor(canvas.height * ratio);
          const ctx = newCanvas.getContext('2d');
          ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height);
          return newCanvas;
        }
        return canvas;
      };

      const renderSlice = (sliceCanvas, sliceHeightPx) => {
        if (!sliceCanvas || sliceCanvas.width === 0 || sliceCanvas.height === 0) return;
        
        try {
          // 캔버스 압축 (너무 큰 이미지 방지) - PDF_MAX_CANVAS_EDGE 사용
          const compressedCanvas = compressCanvas(sliceCanvas, PDF_MAX_CANVAS_EDGE);
          
          const renderWidth = targetWidth;
          const renderHeight = Math.min(maxImgH, sliceHeightPx * scaleRatio);
          const pageX = margin + (imgW - renderWidth) / 2;
          
          // 이미지 데이터를 JPEG로 변환하여 크기 줄이기 (PNG보다 작음)
          // 4개 사진 처리 시 메모리 절약을 위해 품질을 더 낮춤
          let imageData;
          let imageFormat = "JPEG";
          let quality = 0.65; // 더 낮춤 (0.72 → 0.65)
          
          try {
            // JPEG로 변환 시도 (품질 낮춰 메모리 절약)
            imageData = compressedCanvas.toDataURL("image/jpeg", quality);
            imageFormat = "JPEG";
          } catch (e) {
            // JPEG 실패 시 PNG 시도
            try {
              imageData = compressedCanvas.toDataURL("image/png");
              imageFormat = "PNG";
            } catch (e2) {
              console.warn('이미지 변환 실패, 스킵:', e2);
              return;
            }
          }
          
          // 이미지 데이터가 너무 크면 추가 압축 (동기적으로 처리)
          // 4개 사진 처리 시 더 엄격한 제한 (1.5MB → 1MB)
          if (imageData.length > 1000000) { // 약 1MB 제한
            quality = 0.55; // 더 낮춤
            const scaleDown = 0.7; // 더 많이 축소 (0.75 → 0.7)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = Math.floor(compressedCanvas.width * scaleDown);
            tempCanvas.height = Math.floor(compressedCanvas.height * scaleDown);
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(compressedCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
            try {
              imageData = tempCanvas.toDataURL("image/jpeg", quality);
              imageFormat = "JPEG";
              // 임시 캔버스 메모리 해제
              tempCanvas.width = 0;
              tempCanvas.height = 0;
            } catch (e3) {
              // 추가 압축 실패 시 원본 사용
              console.warn('추가 압축 실패, 원본 사용:', e3);
            }
          }
          
          pdf.addPage();
          pdf.setFillColor(255, 255, 255);
          pdf.rect(0, 0, pageW, pageH, "F");
          pdf.addImage(
            imageData,
            imageFormat,
            pageX,
            margin,
            renderWidth,
            renderHeight
          );
        } catch (err) {
          console.warn('PDF 페이지 추가 중 오류 (스킵):', err);
        }
      };

      if (canvas.height <= pageHeightPx) {
        renderSlice(canvas, canvas.height);
        return;
      }

      let offsetY = 0;
      while (offsetY < canvas.height) {
        const remaining = canvas.height - offsetY;
        const currentHeight = Math.min(pageHeightPx, remaining);
        const sliceCanvas = document.createElement("canvas");
        sliceCanvas.width = canvas.width;
        sliceCanvas.height = currentHeight;
        const ctx = sliceCanvas.getContext("2d");
        ctx.drawImage(
          canvas,
          0,
          offsetY,
          canvas.width,
          currentHeight,
          0,
          0,
          canvas.width,
          currentHeight
        );
        renderSlice(sliceCanvas, currentHeight);

        if (offsetY + currentHeight >= canvas.height) {
          break;
        }
        const advance = Math.max(1, currentHeight - overlapPx);
        offsetY += advance;
      }
    };
    
    // 모든 페이지 추가
    if (includeHeatmapPage && heatmapCanvas) {
      addPageToPdf(heatmapCanvas);
    }
    if (metricsCanvas) addPageToPdf(metricsCanvas);
    if (aiSummaryCanvas) addPageToPdf(aiSummaryCanvas);
    if (pilatesCanvas) addPageToPdf(pilatesCanvas);
    if (aiDeepCanvas) addPageToPdf(aiDeepCanvas);
    if (conclusionCanvas) addPageToPdf(conclusionCanvas);
    
    // PDF 다운로드 (모바일 안정화)
    let pdfSaved = false;
    const isMobile = isMobileDevice();
    
    try {
      // 모바일에서는 직접 save 메서드 우선 사용 (가장 안정적)
      if (isMobile) {
        try {
          // 작은 지연으로 UI 블로킹 방지 및 메모리 정리
          await new Promise(resolve => setTimeout(resolve, 300));
          pdf.save(finalFileName);
          console.log('✅ PDF 저장 성공 (직접 save)');
          pdfSaved = true;
        } catch (saveErr) {
          console.warn('⚠️ 직접 save 실패:', saveErr);
          // 폴백으로 진행
        }
      }
      
      // Blob 방식 (데스크톱 또는 직접 save 실패 시)
      if (!pdfSaved) {
        let pdfBlob;
        try {
          // 모바일에서 메모리 절약을 위해 추가 지연
          if (isMobile) {
            await new Promise(resolve => setTimeout(resolve, 200));
          }
          
          pdfBlob = pdf.output('blob');
          if (!pdfBlob || pdfBlob.size === 0) {
            throw new Error('PDF Blob 생성 실패');
          }
          
          // 모바일에서 Blob 크기가 너무 크면 경고
          if (isMobile && pdfBlob.size > 50 * 1024 * 1024) { // 50MB
            console.warn('⚠️ PDF 크기가 큽니다:', (pdfBlob.size / 1024 / 1024).toFixed(2), 'MB');
          }
        } catch (blobErr) {
          console.error('❌ Blob 생성 실패:', blobErr);
          
          // 모바일에서는 data URI 방식 시도 (더 안정적)
          if (isMobile) {
            try {
              await new Promise(resolve => setTimeout(resolve, 200));
              const dataUri = pdf.output('datauristring');
              const link = document.createElement('a');
              link.href = dataUri;
              link.download = finalFileName;
              link.style.display = 'none';
              document.body.appendChild(link);
              
              // 모바일에서 더 긴 지연 후 클릭
              await new Promise(resolve => setTimeout(resolve, 300));
              requestAnimationFrame(() => {
                try {
                  link.click();
                } catch (e) {
                  const clickEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                  });
                  link.dispatchEvent(clickEvent);
                }
                setTimeout(() => {
                  if (document.body.contains(link)) {
                    document.body.removeChild(link);
                  }
                }, 2000);
              });
              pdfSaved = true;
            } catch (finalErr) {
              console.error('❌ Data URI 방식도 실패:', finalErr);
              throw new Error('PDF 저장에 실패했습니다: ' + (finalErr.message || '알 수 없는 오류'));
            }
          } else {
            // 데스크톱에서는 data URI 폴백
            try {
              const dataUri = pdf.output('datauristring');
              const link = document.createElement('a');
              link.href = dataUri;
              link.download = finalFileName;
              link.style.display = 'none';
              document.body.appendChild(link);
              requestAnimationFrame(() => {
                link.click();
                setTimeout(() => {
                  if (document.body.contains(link)) {
                    document.body.removeChild(link);
                  }
                }, 1000);
              });
              pdfSaved = true;
            } catch (finalErr) {
              throw new Error('PDF 저장에 실패했습니다: ' + finalErr.message);
            }
          }
        }
        
        if (!pdfSaved && pdfBlob) {
          // Blob 다운로드 링크 사용
          const url = URL.createObjectURL(pdfBlob);
          const link = document.createElement('a');
          link.href = url;
          link.download = finalFileName;
          link.style.display = 'none';
          document.body.appendChild(link);
          
          // 모바일에서 더 긴 지연
          const delay = isMobile ? 400 : 0;
          await new Promise(resolve => setTimeout(resolve, delay));
          
          requestAnimationFrame(() => {
            try {
              link.click();
            } catch (e) {
              const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
              });
              link.dispatchEvent(clickEvent);
            }
          });
          
          setTimeout(() => {
            try {
              URL.revokeObjectURL(url);
              if (document.body.contains(link)) {
                document.body.removeChild(link);
              }
            } catch (e) {
              console.warn('정리 중 오류:', e);
            }
          }, isMobile ? 5000 : 3000);
          pdfSaved = true;
        }
      }
    } catch (err) {
      console.error('❌ PDF 다운로드 오류:', err);
      const errorMsg = isMobile 
        ? 'PDF 저장에 실패했습니다. 파일 크기가 너무 클 수 있습니다. 페이지를 새로고침하고 다시 시도해주세요.'
        : 'PDF 저장에 실패했습니다: ' + (err.message || '알 수 없는 오류');
      alert(errorMsg);
      reject(err);
      return;
    }
    
    if (!pdfSaved) {
      const errorMsg = 'PDF 저장이 완료되지 않았습니다.';
      console.error('❌', errorMsg);
      alert(errorMsg);
      reject(new Error(errorMsg));
      return;
    }
    
    resolve();
  } catch(error) {
    console.error("PDF 생성 실패:", error);
    reject(error);
  }
  });
}

// PDF 저장 (모바일 최적화, 페이지 분리) - 개선 버전
function setupPDFButton() {
  const btnPDF = document.getElementById("btnPDF");
  if (!btnPDF) {
    console.error("❌ PDF 버튼(btnPDF)을 찾을 수 없습니다.");
    return;
  }
  
  // 기존 이벤트 리스너 제거 후 재등록 (중복 방지)
  const newBtn = btnPDF.cloneNode(true);
  btnPDF.parentNode.replaceChild(newBtn, btnPDF);
  
  newBtn.addEventListener('click', async () => {
    try {
      // 모바일에서 로딩 표시
      const btn = document.getElementById("btnPDF");
      const originalText = btn.textContent;
      btn.textContent = "⏳ PDF 생성 중...";
      btn.disabled = true;
      
      // 센터명/회원명 입력 (항상 입력받기)
      let centerName = prompt("센터 이름을 입력하세요 (예: 레드코어운동센터):", localStorage.getItem('centerName') || "") || null;
      if(centerName) {
        localStorage.setItem('centerName', centerName);
      }
      
      let memberName = prompt("회원 이름을 입력하세요 (예: 김강훈):", localStorage.getItem('memberName') || "") || null;
      if(memberName) {
        localStorage.setItem('memberName', memberName);
      }
      
      // 둘 다 입력되지 않으면 경고
      if(!centerName || !memberName) {
        const confirmContinue = confirm("센터 이름 또는 회원 이름이 입력되지 않았습니다. 계속하시겠습니까?");
        if(!confirmContinue) {
          btn.textContent = originalText;
          btn.disabled = false;
          return;
        }
      }
      
      // 라이브러리 로드 대기 (최대 3초)
      let retryCount = 0;
      while ((typeof html2canvas === 'undefined' || !window.jspdf) && retryCount < 30) {
        await new Promise(resolve => setTimeout(resolve, 100));
        retryCount++;
      }
      
      // 라이브러리 확인
      checkLibraries();
      
      // 세션 데이터 확인
      const S = sessions[cur];
      const hasSidePoints = S.sidePoints && (S.sidePoints.size > 0 || Object.keys(S.sidePoints).length > 0);
      const hasFrontPoints = S.frontPoints && (S.frontPoints.size > 0 || Object.keys(S.frontPoints).length > 0);
      if (!S || (!hasSidePoints && !hasFrontPoints)) {
        alert("먼저 이미지를 업로드하고 분석을 완료해주세요.");
        btn.textContent = originalText;
        btn.disabled = false;
        return;
      }
      
      // 기존 사용자명 (하위 호환성)
      let userName = localStorage.getItem('userName');
      if(!userName && !memberName) {
        userName = prompt("사용자명을 입력하세요 (나중에 변경 가능):", "사용자") || "사용자";
        localStorage.setItem('userName', userName);
      }
      
      await exportAsPdf({
        userName: userName,
        centerName: centerName,
        memberName: memberName,
        appName: 'DIT 자세 분석 AI'
      });
      
      btn.textContent = originalText;
      btn.disabled = false;
      
      // 모바일에서 성공 메시지
      if(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        alert("PDF가 저장되었습니다!");
      }
    } catch(error) {
      console.error("PDF 생성 실패:", error);
      alert("PDF 생성에 실패했습니다: " + error.message);
      const btn = document.getElementById("btnPDF");
      if (btn) {
        btn.textContent = "📄 PDF 저장";
        btn.disabled = false;
      }
    }
  });
}

// 그림으로 저장 (전체 내용 포함)
function setupImageButton() {
  const btnImage = document.getElementById("btnImage");
  if (!btnImage) {
    console.warn("이미지 버튼을 찾을 수 없습니다.");
    return;
  }
  
  btnImage.onclick = async () => {
    const btn = document.getElementById("btnImage");
    const originalText = btn.textContent;
    btn.textContent = "⏳ 이미지 생성 중...";
    btn.disabled = true;
    try {
      if (typeof html2canvas === 'undefined') {
        throw new Error("html2canvas 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.");
      }
      const memberNameDisplay = localStorage.getItem('memberName') || window.memberName || '회원';
      const centerNameDisplay = localStorage.getItem('centerName') || window.centerName || '';
      const pageData = await captureReportCanvases({
        centerName: centerNameDisplay,
        memberName: memberNameDisplay,
        appName: 'DIT 자세 분석 AI',
        logoUrl: null
      });
      const orderedCanvases = [
        pageData.canvases.cover,
        ...(pageData.includeHeatmapPage && pageData.canvases.heatmap ? [pageData.canvases.heatmap] : []),
        pageData.canvases.metrics,
        pageData.canvases.aiSummary,
        pageData.canvases.pilates,
        pageData.canvases.aiDeep,
        pageData.canvases.conclusion
      ].filter(Boolean);
      if (!orderedCanvases.length) {
        throw new Error("저장할 페이지가 없습니다.");
      }
      const combinedCanvas = combineCanvasesVertical(orderedCanvases);
      
      // PDF와 동일한 파일명 형식 사용
      let imageFileName;
      const centerNameForFile = centerNameDisplay || '';
      const memberNameForFile = memberNameDisplay || '회원';
      if(centerNameForFile && memberNameForFile) {
        imageFileName = `${centerNameForFile}_${memberNameForFile}_자세분석리포트_${new Date().toISOString().split('T')[0]}.png`;
      } else {
        imageFileName = `DIT_자세_분석_리포트_${cur}_${new Date().toISOString().split('T')[0]}.png`;
      }
      
      await downloadCanvasAsImage(combinedCanvas, imageFileName, btn, originalText);
    } catch (error) {
      console.error("전체 이미지 생성 실패:", error);
      alert("이미지 생성 중 오류가 발생했습니다: " + (error?.message || "알 수 없는 오류"));
      btn.textContent = originalText || "🖼️ 이미지 저장";
      btn.disabled = false;
    }
  };
}
// 공유하기 (Web Share API 사용)
document.getElementById("btnShare").onclick = async () => {
  try {
    const btn = document.getElementById("btnShare");
    const originalText = btn.textContent;
    btn.textContent = "⏳ 준비 중...";
    btn.disabled = true;
    
    const S = sessions[cur];
    const M = S.metrics || {};
    const scoreData = S.score || {};
    const analysis = S.analysis || {};
    
    // 공유할 이미지 생성 (간단한 버전)
    const cvImg = cv.toDataURL("image/png");
    
    // 공유할 텍스트 생성
    const shareText = `DIT 자세 분석 리포트 - ${cur}\n\n` +
      `📊 체형 종합 점수: ${scoreData.score != null ? scoreData.score : '—'}\n` +
      `📐 측정 각도:\n` +
      `  - CVA: ${M.cva != null ? M.cva.toFixed(1) + "°" : "—"} (정상: ≥50°)\n` +
      `  - TRUNK: ${M.pelvic != null ? M.pelvic.toFixed(1) + "°" : "—"} (정상: |0–5°|)\n` +
      `  - KNEE: ${M.knee != null ? M.knee.toFixed(1) + "°" : "—"} (정상: 175–185°)\n\n` +
      `${analysis.comments && Array.isArray(analysis.comments) && analysis.comments.length > 0 ? analysis.comments.join(" ") + "\n\n" : ""}` +
      `${analysis.tight && Array.isArray(analysis.tight) && analysis.tight.length > 0 ? "🔴 긴장된 근육: " + analysis.tight.join(", ") + "\n" : ""}` +
      `${analysis.weak && Array.isArray(analysis.weak) && analysis.weak.length > 0 ? "🔵 약화된 근육: " + analysis.weak.join(", ") + "\n" : ""}` +
      `\n※ 본 리포트는 교육용으로 제공됩니다.`;
    
    // Web Share API 지원 여부 확인
    if (navigator.share) {
      // 이미지 파일 생성
      const response = await fetch(cvImg);
      const blob = await response.blob();
      const file = new File([blob], `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`, { type: 'image/png' });
      
      // 공유 시도
      try {
        await navigator.share({
          title: `DIT 자세 분석 리포트 - ${cur}`,
          text: shareText,
          files: [file]
        });
        
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (shareError) {
        // 사용자가 공유를 취소했거나 에러 발생
        if (shareError.name !== 'AbortError') {
          console.error('공유 실패:', shareError);
          // 폴백: 이미지 다운로드
          const link = document.createElement('a');
          link.href = cvImg;
          link.download = `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`;
          link.style.position = 'fixed';
          link.style.top = '-9999px';
          link.style.left = '-9999px';
          document.body.appendChild(link);
          
          const clickEvent = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
          });
          link.dispatchEvent(clickEvent);
          
          setTimeout(() => {
            if (document.body.contains(link)) {
              document.body.removeChild(link);
            }
          }, 500);
        }
        btn.textContent = originalText;
        btn.disabled = false;
      }
    } else {
      // Web Share API를 지원하지 않는 경우: 클립보드에 복사
      try {
        // 텍스트를 클립보드에 복사
        await navigator.clipboard.writeText(shareText);
        
        // 이미지도 다운로드
        const link = document.createElement('a');
        link.href = cvImg;
        link.download = `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`;
        link.style.position = 'fixed';
        link.style.top = '-9999px';
        link.style.left = '-9999px';
        document.body.appendChild(link);
        
        const clickEvent = new MouseEvent('click', {
          view: window,
          bubbles: true,
          cancelable: true
        });
        link.dispatchEvent(clickEvent);
        
        setTimeout(() => {
          if (document.body.contains(link)) {
            document.body.removeChild(link);
          }
        }, 500);
        
        alert('분석 결과가 클립보드에 복사되었고 이미지가 다운로드되었습니다!\n\n다른 앱에 붙여넣어 공유하세요.');
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (clipboardError) {
        console.error('클립보드 복사 실패:', clipboardError);
        // 최종 폴백: 이미지 다운로드만
        const link = document.createElement('a');
        link.href = cvImg;
        link.download = `DIT_자세_분석_${cur}_${new Date().toISOString().split('T')[0]}.png`;
        link.style.position = 'fixed';
        link.style.top = '-9999px';
        link.style.left = '-9999px';
        document.body.appendChild(link);
        
        const clickEvent = new MouseEvent('click', {
          view: window,
          bubbles: true,
          cancelable: true
        });
        link.dispatchEvent(clickEvent);
        
        setTimeout(() => {
          if (document.body.contains(link)) {
            document.body.removeChild(link);
          }
        }, 500);
        alert('이미지가 다운로드되었습니다. 수동으로 공유해주세요.');
        btn.textContent = originalText;
        btn.disabled = false;
      }
    }
  } catch (error) {
    console.error("공유 실패:", error);
    alert("공유에 실패했습니다: " + error.message);
    const btn = document.getElementById("btnShare");
    btn.textContent = "📤 공유하기";
    btn.disabled = false;
  }
};

// 실시간 분석 리스너 등록 (UI 업데이트)
// 주석: updateLiveAnalysisUI 함수가 필요할 경우 여기에 구현
// liveAnalyzer.addListener((result) => {
//   // UI 업데이트 로직
//   console.log("실시간 분석 결과:", result);
// });

// 초기화
resizeCanvasFor(null);
draw();
computeMetricsOnly(); // 초기화 시에는 AI 분석 안 함
updateCompare();

// 초기 실시간 분석 실행
setTimeout(() => {
  if(typeof liveAnalyzer !== 'undefined') {
    liveAnalyzer.analyzeCurrentSession();
  }
}, 500);
</script>

<!-- ✅ Pose Detection Libraries -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>

<script>
// 포즈 감지 모델 관리
let detectors = { front: null, side: null };

// 초기 orientation 버튼 상태 설정 및 좌표 선택 드롭다운 초기화
// DOMContentLoaded 이벤트는 함수 정의 이후에 실행되도록 함
function initializeApp() {
  console.log("=== DOMContentLoaded 이벤트 발생 ===");
  
  // sessions가 정의되어 있는지 확인
  if(typeof sessions === 'undefined') {
    console.error("sessions가 정의되지 않았습니다. 스크립트 로드 순서를 확인하세요.");
    return;
  }
  
  // 파일 업로드 설정 (가장 먼저)
  if(typeof setupFileUploads === 'function') {
    setupFileUploads();
  } else {
    console.error("setupFileUploads 함수를 찾을 수 없습니다.");
  }
  
  // Reset 버튼 설정
  if(typeof setupResetButton === 'function') {
    setupResetButton();
  } else {
    console.error("setupResetButton 함수를 찾을 수 없습니다.");
  }
  
  // 캘리브레이션 버튼들 설정
  if(typeof setupCalibrateButton === 'function') {
    setupCalibrateButton();
  } else {
    console.error("setupCalibrateButton 함수를 찾을 수 없습니다.");
  }
  
  if(typeof setupCalibrationButtons === 'function') {
    setupCalibrationButtons();
  } else {
    console.error("setupCalibrationButtons 함수를 찾을 수 없습니다.");
  }
  
  // PDF 및 이미지 저장 버튼 초기화
  if(typeof setupPDFButton === 'function') {
    setupPDFButton();
  } else {
    console.error("setupPDFButton 함수를 찾을 수 없습니다.");
  }
  
  if(typeof setupImageButton === 'function') {
    setupImageButton();
  } else {
    console.error("setupImageButton 함수를 찾을 수 없습니다.");
  }
  
  // AI 분석 버튼 초기화
  const btnAIAnalysis = document.getElementById("btnAIAnalysis");
  if (btnAIAnalysis) {
    btnAIAnalysis.addEventListener('click', async () => {
      try {
        const originalText = btnAIAnalysis.textContent;
        btnAIAnalysis.textContent = "⏳ AI 분석 중...";
        btnAIAnalysis.disabled = true;
        
        // 현재 세션 데이터 확인
        const S = sessions[cur];
        if (!S || (!S.sidePoints || S.sidePoints.size === 0) && (!S.frontPoints || S.frontPoints.size === 0)) {
          alert("먼저 이미지를 업로드하고 좌표를 설정해주세요.");
          btnAIAnalysis.textContent = originalText;
          btnAIAnalysis.disabled = false;
          return;
        }
        
        // 전체 분석 실행
        await computeAll();
        
        // 분석 결과 표시 영역 업데이트
        const S2 = sessions[cur];
        if (S2.analysis && S2.score) {
          updateScoreAndAnalysis(S2.score.score, S2.metrics?.cva, S2.metrics?.pelvic, S2.metrics?.knee, S2.analysis);
        }
        
        btnAIAnalysis.textContent = "✅ 분석 완료";
        setTimeout(() => {
          btnAIAnalysis.textContent = originalText;
          btnAIAnalysis.disabled = false;
        }, 2000);
      } catch (error) {
        console.error("AI 분석 실패:", error);
        alert("AI 분석에 실패했습니다: " + (error.message || '알 수 없는 오류'));
        const btn = document.getElementById("btnAIAnalysis");
        if (btn) {
          btn.textContent = "🤖 AI 분석";
          btn.disabled = false;
        }
      }
    });
  }

  // 세션별 포즈 정보 저장 (기존 sessions 객체와 통합)
  // sessions 객체에 orientation과 landmarks 정보 추가
  if(!sessions || !sessions.Before || !sessions.After) {
    console.error("sessions 객체가 아직 초기화되지 않았습니다.");
    return;
  }
  
  if(!sessions.Before.poseData) {
    sessions.Before.poseData = { orientation: "side", landmarks: null, orientationMode: "auto" };
  }
  if(!sessions.After.poseData) {
    sessions.After.poseData = { orientation: "side", landmarks: null, orientationMode: "auto" };
  }

  // 버튼 이벤트 핸들러 초기화
  initSessionButtons();
  
  // orientation 버튼 상태 설정
  const orientation = sessions[cur].poseData?.orientation || "side";
  const btnSide = document.getElementById("btnOrientationSide");
  const btnFront = document.getElementById("btnOrientationFront");
  
  if(btnSide && btnFront) {
    btnSide.classList.toggle("active", orientation === "side");
    btnFront.classList.toggle("active", orientation === "front");
    console.log("Orientation 버튼 초기 상태 설정 완료:", orientation);
  }
  
  // 좌표 선택 드롭다운 초기화
  updateCoordSelectOptions();
  
  console.log("=== 초기화 완료 ===");
}

// ✅ 모델 로드 상태 추적
let modelsLoading = { front: false, side: false };
let modelsLoaded = { front: false, side: false };

// ✅ 모델 로드 (정면: MoveNet, 옆모습: BlazePose)
async function loadPoseModels() {
  try {
    // 정면 모델 로드
    if (!modelsLoading.front && !modelsLoaded.front) {
      modelsLoading.front = true;
    detectors.front = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
      modelsLoaded.front = true;
      modelsLoading.front = false;
      console.log("✅ 정면 모델 로드 완료");
    }
    
    // 옆모습 모델 로드
    if (!modelsLoading.side && !modelsLoaded.side) {
      modelsLoading.side = true;
    detectors.side = await poseDetection.createDetector(
      poseDetection.SupportedModels.BlazePose,
      { runtime: "tfjs", modelType: "full", enableSmoothing: true }
    );
      modelsLoaded.side = true;
      modelsLoading.side = false;
      console.log("✅ 옆모습 모델 로드 완료");
    }
    
    console.log("✅ 정면·옆모습 모델 로드 완료");
  } catch(error) {
    console.error("모델 로드 실패:", error);
    modelsLoading.front = false;
    modelsLoading.side = false;
  }
}

loadPoseModels();

// ✅ 분석 시 orientation에 맞는 모델 사용
async function detectPose(img, orientation) {
  // 모델이 로드 중이면 기다림
  let waitCount = 0;
  const maxWait = 50; // 최대 5초 대기 (100ms * 50)
  
  while (!modelsLoaded[orientation] && !detectors[orientation] && waitCount < maxWait) {
    if (!modelsLoading[orientation]) {
      // 모델 로드가 시작되지 않았으면 시작
      await loadPoseModels();
    }
    await new Promise(resolve => setTimeout(resolve, 100)); // 100ms 대기
    waitCount++;
  }
  
  const detector = detectors[orientation];
  if (!detector) {
    // 모델 로드 실패 시 재시도
    console.log(`${orientation} 모델 재시도 중...`);
    await loadPoseModels();
    
    if (!detectors[orientation]) {
      alert(`${orientation}용 모델 로드에 실패했습니다. 페이지를 새로고침해주세요.`);
    return null;
    }
  }
  
  try {
    const poses = await detector.estimatePoses(img);
    if (!poses.length) {
      alert(`${orientation} 방향에서 사람을 인식하지 못했습니다`);
      return null;
    }
    return poses[0];
  } catch(error) {
    console.error("포즈 감지 실패:", error);
    alert("포즈 감지 중 오류가 발생했습니다");
    return null;
  }
}

// ✅ 포즈 좌표를 기존 점 시스템에 매핑 (MediaPipe Pose 랜드마크 인덱스 기반)
function getKeypointConfidence(kp) {
  if (!kp) return 0;
  if (typeof kp.score === 'number' && !Number.isNaN(kp.score)) return kp.score;
  if (typeof kp.visibility === 'number' && !Number.isNaN(kp.visibility)) return kp.visibility;
  return 0;
}

function inferOrientationFromPose(pose) {
  if (!pose || !pose.keypoints) return "side";
  const keypoints = pose.keypoints;
  const pairs = [
    [11, 12], // shoulders
    [23, 24], // hips
    [25, 26], // knees
    [27, 28], // ankles
    [13, 14]  // elbows
  ];
  let frontScore = 0;
  let visiblePairs = 0;
  pairs.forEach(([l, r]) => {
    const L = keypoints[l];
    const R = keypoints[r];
    if (getKeypointConfidence(L) >= 0.3 && getKeypointConfidence(R) >= 0.3) {
      visiblePairs++;
      const diff = Math.abs(L.x - R.x);
      if (diff >= 0.03) {
        frontScore++;
      }
    }
  });
  if (frontScore >= 2 || (frontScore >= 1 && visiblePairs >= 3)) {
    return "front";
  }
  return "side";
}

function mapPoseToKeypoints(pose, orientation) {
  if(!pose || !pose.keypoints) return null;
  
  const keypointMap = {};
  const keypoints = pose.keypoints;
  
  // MediaPipe Pose는 33개 랜드마크 제공 (인덱스 기반)
  // 0: nose, 7: left_ear, 8: right_ear, 11: left_shoulder, 12: right_shoulder
  // 23: left_hip, 24: right_hip, 25: left_knee, 26: right_knee
  // 27: left_ankle, 28: right_ankle
  
  if(orientation === "side") {
    // 옆모습: 보이는 쪽의 랜드마크 사용 (confidence 높은 쪽 선택)
    const leftEar = keypoints[7];
    const rightEar = keypoints[8];
    const leftShoulder = keypoints[11];
    const rightShoulder = keypoints[12];
    const leftHip = keypoints[23];
    const rightHip = keypoints[24];
    const leftKnee = keypoints[25];
    const rightKnee = keypoints[26];
    const leftAnkle = keypoints[27];
    const rightAnkle = keypoints[28];
    const nose = keypoints[0];
    
    // 어느 쪽이 더 보이는지 판단 (x 좌표가 더 작거나 큰 쪽)
    let useLeft = true;
    if(leftShoulder && rightShoulder) {
      // 어깨의 x 차이로 판단 (옆모습에서는 한쪽이 더 앞에 나와 있음)
    const leftScore = getKeypointConfidence(leftShoulder) + getKeypointConfidence(leftHip) + getKeypointConfidence(leftKnee);
    const rightScore = getKeypointConfidence(rightShoulder) + getKeypointConfidence(rightHip) + getKeypointConfidence(rightKnee);
      useLeft = leftScore >= rightScore;
    } else if(leftShoulder) {
      useLeft = true;
    } else if(rightShoulder) {
      useLeft = false;
    }
    
    console.log('옆모습 감지:', useLeft ? '왼쪽 사용' : '오른쪽 사용');
    
    // visibility 임계값을 낮춰서 더 많은 랜드마크를 매핑 (0.3 -> 0.2)
    const minVisibility = 0.2;
    
    // tragus: ear (더 보이는 쪽) - Flutter 1:1 매칭
    const ear = useLeft ? leftEar : rightEar;
    if(ear && getKeypointConfidence(ear) >= minVisibility) {
      keypointMap['tragus'] = { x: ear.x, y: ear.y, score: getKeypointConfidence(ear) || 0.5 };
    } else if(nose && getKeypointConfidence(nose) >= minVisibility) {
      // ear가 안 보이면 nose 사용
      keypointMap['tragus'] = { x: nose.x, y: nose.y + 0.03, score: (getKeypointConfidence(nose) || 0.5) * 0.8 };
    }
    
    // acromion: 어깨 (더 보이는 쪽) - Flutter 1:1 매칭
    const shoulder = useLeft ? leftShoulder : rightShoulder;
    if(shoulder && getKeypointConfidence(shoulder) >= minVisibility) {
      const shoulderConf = getKeypointConfidence(shoulder) || 0.5;
      keypointMap['acromion'] = { x: shoulder.x, y: shoulder.y, score: shoulderConf };
      console.log(`✅ acromion 매핑: (${shoulder.x.toFixed(3)}, ${shoulder.y.toFixed(3)}), score: ${shoulderConf.toFixed(2)}`);
      
      // c7: 어깨보다 약간 위/뒤 - Flutter 1:1 매칭
      const c7Score = shoulderConf * 0.9;
      keypointMap['c7'] = { 
        x: shoulder.x - 0.02, // 어깨보다 약간 뒤
        y: shoulder.y - 0.03, // 어깨보다 약간 위
        score: c7Score
      };
      console.log(`✅ c7 매핑: (${keypointMap['c7'].x.toFixed(3)}, ${keypointMap['c7'].y.toFixed(3)}), score: ${c7Score.toFixed(2)}`);
    } else {
      console.warn(`⚠️ shoulder 감지 실패: useLeft=${useLeft}, leftConf=${getKeypointConfidence(leftShoulder).toFixed(2)}, rightConf=${getKeypointConfidence(rightShoulder).toFixed(2)}`);
    }
    
    // hip: 골반 (더 보이는 쪽) - Flutter 1:1 매칭
    const hip = useLeft ? leftHip : rightHip;
    if(hip && getKeypointConfidence(hip) >= minVisibility) {
      const hipConf = getKeypointConfidence(hip) || 0.5;
      keypointMap['hip'] = { x: hip.x, y: hip.y, score: hipConf };
      console.log(`✅ hip 매핑: (${hip.x.toFixed(3)}, ${hip.y.toFixed(3)}), score: ${hipConf.toFixed(2)}`);
      
      // asis: hip보다 약간 앞/위 - Flutter 1:1 매칭
      const asisScore = hipConf * 0.85;
      keypointMap['asis'] = { 
        x: hip.x + 0.03, // 앞쪽
        y: hip.y - 0.01, // 약간 위
        score: asisScore
      };
      console.log(`✅ asis 매핑: (${keypointMap['asis'].x.toFixed(3)}, ${keypointMap['asis'].y.toFixed(3)}), score: ${asisScore.toFixed(2)}`);
      
      // psis: hip보다 약간 뒤 - Flutter 1:1 매칭
      const psisScore = hipConf * 0.85;
      keypointMap['psis'] = { 
        x: hip.x - 0.03, // 뒤쪽
        y: hip.y - 0.01, // 약간 위
        score: psisScore
      };
      console.log(`✅ psis 매핑: (${keypointMap['psis'].x.toFixed(3)}, ${keypointMap['psis'].y.toFixed(3)}), score: ${psisScore.toFixed(2)}`);
    } else {
      console.warn(`⚠️ hip 감지 실패: useLeft=${useLeft}, leftHipConf=${getKeypointConfidence(leftHip).toFixed(2)}, rightHipConf=${getKeypointConfidence(rightHip).toFixed(2)}`);
    }
    
    // knee: 무릎 (더 보이는 쪽) - Flutter 1:1 매칭
    const knee = useLeft ? leftKnee : rightKnee;
    if(knee && getKeypointConfidence(knee) >= minVisibility) {
      keypointMap['knee'] = { x: knee.x, y: knee.y, score: getKeypointConfidence(knee) || 0.5 };
    }
    
    // ankle: 발목 (더 보이는 쪽) - Flutter 1:1 매칭
    const ankle = useLeft ? leftAnkle : rightAnkle;
    if(ankle && getKeypointConfidence(ankle) >= minVisibility) {
      keypointMap['ankle'] = { x: ankle.x, y: ankle.y, score: getKeypointConfidence(ankle) || 0.5 };
    }
    
    console.log('옆모습 랜드마크 매핑:', Object.keys(keypointMap));
  }
  
  if(orientation === "front") {
    // 정면: 양쪽 모두 표시 (환자 좌/우 인식)
    // 중요: MediaPipe keypoints는 화면 좌표 기준입니다
    // keypoints[11] = 화면 왼쪽 어깨 → 환자의 오른쪽 어깨 → R_acromion
    // keypoints[12] = 화면 오른쪽 어깨 → 환자의 왼쪽 어깨 → L_acromion
    const mpScreenLeft = keypoints[11];   // 화면 왼쪽 어깨 (환자 오른쪽)
    const mpScreenRight = keypoints[12]; // 화면 오른쪽 어깨 (환자 왼쪽)
    const mpScreenLeftHip = keypoints[23];   // 화면 왼쪽 골반 (환자 오른쪽)
    const mpScreenRightHip = keypoints[24]; // 화면 오른쪽 골반 (환자 왼쪽)
    const mpScreenLeftKnee = keypoints[25];   // 화면 왼쪽 무릎 (환자 오른쪽)
    const mpScreenRightKnee = keypoints[26]; // 화면 오른쪽 무릎 (환자 왼쪽)
    const mpScreenLeftAnkle = keypoints[27];   // 화면 왼쪽 발목 (환자 오른쪽)
    const mpScreenRightAnkle = keypoints[28]; // 화면 오른쪽 발목 (환자 왼쪽)
    
    // 좌표 변환 함수: 화면 좌표를 그대로 사용 (환자 기준으로 매핑만 반대로)
    // confidence 임계값을 낮춰서 더 많은 랜드마크를 매핑 (0.2 -> 0.15)
    const makePoint = (kp, label = '') => {
      if (!kp) {
        console.warn(`⚠️ ${label}: keypoint이 null입니다`);
        return null;
      }
      const confidence = getKeypointConfidence(kp);
      if (confidence < 0.15) {
        console.warn(`⚠️ ${label}: confidence가 너무 낮음 (${confidence.toFixed(2)})`);
        return null;
      }
      return { x: kp.x, y: kp.y, score: confidence || 0.5 };
    };
    
    // 환자 기준으로 올바르게 매핑: 화면 왼쪽 → 환자 오른쪽 → R_*, 화면 오른쪽 → 환자 왼쪽 → L_*
    // 화면 왼쪽 어깨 (keypoints[11]) → 환자 오른쪽 어깨 → R_acromion
    const rightShoulderPoint = makePoint(mpScreenLeft, 'R_acromion');
    if (rightShoulderPoint) {
      keypointMap['R_acromion'] = rightShoulderPoint;
      console.log(`✅ R_acromion 매핑 (화면 왼쪽 → 환자 오른쪽): (${rightShoulderPoint.x.toFixed(3)}, ${rightShoulderPoint.y.toFixed(3)}), score: ${rightShoulderPoint.score.toFixed(2)}`);
    } else {
      console.warn(`⚠️ R_acromion 매핑 실패: mpScreenLeft confidence=${getKeypointConfidence(mpScreenLeft).toFixed(2)}`);
    }
    
    // 화면 오른쪽 어깨 (keypoints[12]) → 환자 왼쪽 어깨 → L_acromion
    const leftShoulderPoint = makePoint(mpScreenRight, 'L_acromion');
    if (leftShoulderPoint) {
      keypointMap['L_acromion'] = leftShoulderPoint;
      console.log(`✅ L_acromion 매핑 (화면 오른쪽 → 환자 왼쪽): (${leftShoulderPoint.x.toFixed(3)}, ${leftShoulderPoint.y.toFixed(3)}), score: ${leftShoulderPoint.score.toFixed(2)}`);
    } else {
      console.warn(`⚠️ L_acromion 매핑 실패: mpScreenRight confidence=${getKeypointConfidence(mpScreenRight).toFixed(2)}`);
    }
    
    // c7: 양쪽 어깨 중간 (목 아래) - 항상 생성 시도
    if(keypointMap['R_acromion'] && keypointMap['L_acromion']) {
      keypointMap['c7'] = {
        x: (keypointMap['R_acromion'].x + keypointMap['L_acromion'].x) / 2,
        y: Math.min(keypointMap['R_acromion'].y, keypointMap['L_acromion'].y) - 0.04,
        score: Math.min(keypointMap['R_acromion'].score, keypointMap['L_acromion'].score)
      };
      console.log(`✅ c7 매핑 (양쪽 어깨 중간): (${keypointMap['c7'].x.toFixed(3)}, ${keypointMap['c7'].y.toFixed(3)}), score: ${keypointMap['c7'].score.toFixed(2)}`);
    } else if(keypointMap['R_acromion']) {
      keypointMap['c7'] = {
        x: keypointMap['R_acromion'].x,
        y: keypointMap['R_acromion'].y - 0.04,
        score: keypointMap['R_acromion'].score * 0.8
      };
      console.log(`✅ c7 매핑 (R_acromion 기준): (${keypointMap['c7'].x.toFixed(3)}, ${keypointMap['c7'].y.toFixed(3)}), score: ${keypointMap['c7'].score.toFixed(2)}`);
    } else if(keypointMap['L_acromion']) {
      keypointMap['c7'] = {
        x: keypointMap['L_acromion'].x,
        y: keypointMap['L_acromion'].y - 0.04,
        score: keypointMap['L_acromion'].score * 0.8
      };
      console.log(`✅ c7 매핑 (L_acromion 기준): (${keypointMap['c7'].x.toFixed(3)}, ${keypointMap['c7'].y.toFixed(3)}), score: ${keypointMap['c7'].score.toFixed(2)}`);
    } else {
      console.warn(`⚠️ c7 매핑 실패: 어깨 랜드마크가 없음`);
    }
    
    // 환자 기준으로 올바르게 매핑: 화면 왼쪽 → 환자 오른쪽 → R_*, 화면 오른쪽 → 환자 왼쪽 → L_*
    const rightHipPoint = makePoint(mpScreenLeftHip, 'R_asis');
    if (rightHipPoint) {
      keypointMap['R_asis'] = rightHipPoint;
      console.log(`✅ R_asis 매핑 (화면 왼쪽 → 환자 오른쪽): (${rightHipPoint.x.toFixed(3)}, ${rightHipPoint.y.toFixed(3)}), score: ${rightHipPoint.score.toFixed(2)}`);
    }
    
    const leftHipPoint = makePoint(mpScreenRightHip, 'L_asis');
    if (leftHipPoint) {
      keypointMap['L_asis'] = leftHipPoint;
      console.log(`✅ L_asis 매핑 (화면 오른쪽 → 환자 왼쪽): (${leftHipPoint.x.toFixed(3)}, ${leftHipPoint.y.toFixed(3)}), score: ${leftHipPoint.score.toFixed(2)}`);
    }
    
    const rightKneePoint = makePoint(mpScreenLeftKnee, 'R_knee');
    if (rightKneePoint) {
      keypointMap['R_knee'] = rightKneePoint;
      console.log(`✅ R_knee 매핑: (${rightKneePoint.x.toFixed(3)}, ${rightKneePoint.y.toFixed(3)}), score: ${rightKneePoint.score.toFixed(2)}`);
    }
    
    const leftKneePoint = makePoint(mpScreenRightKnee, 'L_knee');
    if (leftKneePoint) {
      keypointMap['L_knee'] = leftKneePoint;
      console.log(`✅ L_knee 매핑: (${leftKneePoint.x.toFixed(3)}, ${leftKneePoint.y.toFixed(3)}), score: ${leftKneePoint.score.toFixed(2)}`);
    }
    
    const rightAnklePoint = makePoint(mpScreenLeftAnkle, 'R_ankle');
    if (rightAnklePoint) {
      keypointMap['R_ankle'] = rightAnklePoint;
      console.log(`✅ R_ankle 매핑: (${rightAnklePoint.x.toFixed(3)}, ${rightAnklePoint.y.toFixed(3)}), score: ${rightAnklePoint.score.toFixed(2)}`);
    }
    
    const leftAnklePoint = makePoint(mpScreenRightAnkle, 'L_ankle');
    if (leftAnklePoint) {
      keypointMap['L_ankle'] = leftAnklePoint;
      console.log(`✅ L_ankle 매핑: (${leftAnklePoint.x.toFixed(3)}, ${leftAnklePoint.y.toFixed(3)}), score: ${leftAnklePoint.score.toFixed(2)}`);
    }

    console.log(`✅ 정면 랜드마크 매핑 완료 (환자 기준): ${Object.keys(keypointMap).length}개 - [${Object.keys(keypointMap).join(', ')}]`);
  }
  
  return keypointMap;
}

// ✅ 포즈 감지 후 기존 시스템에 통합
async function applyPoseDetection(img, sessionName) {
  const session = sessions[sessionName];
  if(!session) return null;
  
  // 세션의 orientation 사용 (기본값: side)
  if(!session.poseData) {
    session.poseData = { orientation: "side", landmarks: null, orientationMode: "auto" };
  }
  const orientation = session.poseData.orientation || "side";
  const isManualOrientation = session.poseData.orientationMode === "manual";
  
  console.log(`${sessionName} 세션: ${orientation === "side" ? "옆모습" : "정면"} 포즈 감지 시작`);
  
  let pose = await detectPose(img, orientation);
  if(!pose) return null;
  
  // 사용자가 명시적으로 선택한 orientation이 있으면 그것을 우선 사용 (AI 자동 감지 무시)
  const btnSide = document.getElementById("btnOrientationSide");
  const btnFront = document.getElementById("btnOrientationFront");
  const userSelectedOrientation = btnFront?.classList.contains("active") ? "front" 
    : (btnSide?.classList.contains("active") ? "side" : null);
  
  let activeOrientation = userSelectedOrientation || orientation;
  
  // 사용자가 명시적으로 선택하지 않은 경우에만 AI 자동 감지 사용
  if(!userSelectedOrientation) {
  const inferredOrientation = inferOrientationFromPose(pose);
  if (!isManualOrientation && inferredOrientation && inferredOrientation !== orientation) {
    const retryPose = await detectPose(img, inferredOrientation);
    if (retryPose) {
      pose = retryPose;
    }
    console.log(`자동 orientation 감지: ${orientation} → ${inferredOrientation}`);
    activeOrientation = inferredOrientation;
  }
  } else {
    console.log(`사용자가 선택한 orientation 사용: ${activeOrientation} (AI 자동 감지 무시)`);
  }
  
  // 포즈 정보 저장
  session.poseData.landmarks = pose.keypoints;
  session.poseData.detectedOrientation = activeOrientation;
  if(!isManualOrientation) {
    session.poseData.orientation = activeOrientation;
    session.poseData.orientationMode = "auto";
  }
  
  // 기존 점 시스템에 매핑 (선택적)
  const keypointMap = mapPoseToKeypoints(pose, activeOrientation);
  if(keypointMap) {
    // 매핑된 키포인트를 기존 점 시스템에 적용
    const map = activeOrientation === "front" ? session.frontPoints : session.sidePoints;
    if(map?.clear) {
      map.clear();
    }
    
    // 원본 크기 계산 (아직 없으면 계산)
    if(originalCanvasSize.width === 0) {
      const canvasWrap = cv.parentElement;
      const maxW = canvasWrap.clientWidth - 24;
      const maxH = canvasWrap.clientHeight - 24;
      const r = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight);
      originalCanvasSize.width = Math.round(img.naturalWidth * r);
      originalCanvasSize.height = Math.round(img.naturalHeight * r);
    }
    
    for(const [key, value] of Object.entries(keypointMap)) {
      if(!value || value.x === undefined || value.y === undefined) {
        continue;
      }
      
      // score 체크 (score가 없거나 낮아도 저장) - 임계값을 낮춤 (0.1 -> 0.05)
      const confidence = value.score || value.visibility || 0.5;
      if(confidence < 0.05) {
        console.warn(`⚠️ ${key} confidence가 너무 낮음: ${confidence.toFixed(2)}, 스킵`);
        continue;
      }
      
      // MediaPipe는 정규화된 좌표(0-1)를 제공하므로 픽셀 좌표로 변환
      // value.x가 이미 1보다 크면 이미 픽셀 좌표이므로 그대로 사용
      let imgX, imgY;
      if(value.x > 1 || value.y > 1) {
        // 이미 픽셀 좌표인 경우
        imgX = value.x;
        imgY = value.y;
      } else {
        // 정규화된 좌표(0-1)인 경우
        imgX = value.x * img.naturalWidth;
        imgY = value.y * img.naturalHeight;
      }
      
      // 캔버스 크기에 맞게 스케일링
      const scaleX = originalCanvasSize.width / img.naturalWidth;
      const scaleY = originalCanvasSize.height / img.naturalHeight;
      
      const finalX = imgX * scaleX;
      const finalY = imgY * scaleY;
      
      // 유효한 좌표인지 확인
      if(isNaN(finalX) || isNaN(finalY) || !isFinite(finalX) || !isFinite(finalY)) {
        console.warn(`⚠️ ${key} 좌표가 유효하지 않음: (${finalX}, ${finalY}), 스킵`);
        continue;
      }
      
      map.set(key, {
        x: finalX,
        y: finalY
      });
      
      console.log(`✅ ${key} 매핑: 원본(${value.x.toFixed(3)}, ${value.y.toFixed(3)}) → 이미지픽셀(${imgX.toFixed(1)}, ${imgY.toFixed(1)}) → 캔버스(${finalX.toFixed(1)}, ${finalY.toFixed(1)}) [confidence: ${confidence.toFixed(2)}]`);
    }
    
    // 저장된 랜드마크 개수 확인
    const savedCount = map.size;
    console.log(`✅ ${sessionName} 랜드마크 저장 완료: ${savedCount}개 (${activeOrientation === "side" ? "옆모습" : "정면"})`);
    
    // 저장 후 즉시 다시 그리기
    if(savedCount > 0) {
      draw();
    }
    
    console.log(`✅ ${sessionName} 포즈 감지 및 좌표 적용 완료 (${activeOrientation === "side" ? "옆모습" : "정면"})`);
  }
  
  return { orientation: activeOrientation, pose };
}

// ✅ 포즈 감지는 위의 업로드 핸들러에서 자동으로 호출됨
// applyPoseDetection 함수가 이미 위에서 정의되어 있음

/**********************
 * 전역 함수 노출 (AIReportManager 모듈에서 사용)
 **********************/
if (typeof window !== 'undefined') {
  // analyzePostureAI가 정의되어 있는지 확인 후 노출
  if(typeof analyzePostureAI === 'function') {
    window.analyzePostureAI = analyzePostureAI;
  } else {
    console.warn("analyzePostureAI 함수가 정의되지 않았습니다.");
  }
  if(typeof generatePosturePDF === 'function') {
    window.generatePosturePDF = generatePosturePDF;
  }
  if(typeof drawComparisonChart === 'function') {
    window.drawComparisonChart = drawComparisonChart;
  }
  if(typeof savePDFMobileCompatible === 'function') {
    window.savePDFMobileCompatible = savePDFMobileCompatible;
  }
  if(typeof saveImageMobile === 'function') {
    window.saveImageMobile = saveImageMobile;
  }
  if(typeof waitForChartRender === 'function') {
    window.waitForChartRender = waitForChartRender;
  }
  if(typeof loadPostureDB === 'function') {
    window.loadPostureDB = loadPostureDB; // DB 로더도 노출
  }
  
  // 모든 함수가 정의된 후 initializeApp 호출
  if(document.readyState === 'loading') {
    document.addEventListener("DOMContentLoaded", initializeApp);
  } else {
    // 이미 로드 완료된 경우 약간의 지연 후 실행 (함수들이 모두 정의되도록)
    setTimeout(initializeApp, 0);
  }
}

/**********************
 * (선택 기능) 외부 AI 모듈 로드 비활성화
 * 네트워크 404와 중복 분석 문제를 막기 위해 현재는 실행하지 않습니다.
 **********************/


// -------------------- 골반 분석 자동 연동 --------------------

// 1️⃣ PTA 계산
function calcPTA(asis, psis) {
  // asis, psis: {x, y}
  // 이미지 좌표계: y축 아래로 증가
  // ASIS.y < PSIS.y → ASIS가 위쪽(높음) → 후방경사(음수)
  // ASIS.y > PSIS.y → ASIS가 밑쪽(낮음) → 전방경사(양수)
  
  // 수평선 기준 각도 계산 (PSIS에서 ASIS로의 각도)
  const pta_theta = angleFromHorizontalDeg(psis, asis);
  const pta_abs = Math.abs(normalizeToAcuteDeg(pta_theta));
  
  let pta;
  if (asis.y < psis.y) {
    // 후방경사: ASIS가 PSIS보다 위쪽 → 음수, 최소 -1도
    pta = -Math.max(1, pta_abs || 1);
  } else if (asis.y > psis.y) {
    // 전방경사: ASIS가 PSIS보다 밑쪽 → 양수, 최소 1도
    pta = Math.max(1, pta_abs || 1);
  } else {
    // 같은 높이: 0도
    pta = 0;
  }
  
  return pta; // 부호 포함 값 (양수=전방경사, 음수=후방경사)
}

// 2️⃣ 설명 생성
function getPelvicTiltDescription(PTA) {
  let description = "";

  if (PTA > 15) {
    description = `
📍 골반 전방 경사 (Anterior Pelvic Tilt) - 심각
현재 상태: PTA ${PTA.toFixed(1)}° (정상: 0–15°)

주요 원인: 장시간 앉아있는 생활, 하이힐 착용, 복부 근력 약화, 임신 후 회복 부족

발생 증상:
• 요추 과전만(Hyperlordosis)으로 인한 만성 요통  
• 하복부 돌출 (pseudo-pregnancy appearance)  
• 엉덩이가 뒤로 튀어나온 자세  
• 고관절 굴곡근 단축으로 인한 보행 장애

근육 불균형:
• 긴장·단축된 근육: 장요근(Iliopsoas), 대퇴직근(Rectus femoris), 척추기립근(Erector spinae)  
• 약화·신장된 근육: 복직근(Rectus abdominis), 대둔근(Gluteus maximus), 햄스트링(Hamstrings)

교정 방향:
① 고관절 굴곡근 스트레칭 (런지 자세)  
② 코어 강화 (플랭크, 데드버그)  
③ 대둔근 활성화 (브릿지, 힙 쓰러스트, 클램쉘)  
④ 골반 후방경사 연습 (벽에 등대고 중립자세)

복합 증후군: Lower Cross Syndrome(하부 교차 증후군)의 핵심 특징입니다.
`;
  } else if (PTA < 0) {
    description = `
📍 골반 후방 경사 (Posterior Pelvic Tilt)
현재 상태: PTA ${PTA.toFixed(1)}° (정상: 0–15°, ASIS가 PSIS보다 위쪽)

주요 원인: 장시간 앉은 자세, 햄스트링 단축, 복부 근육 과활성, 둔근 과긴장

발생 증상:
• 요추 평평(Flat Back)으로 인한 허리 움직임 제한  
• 엉덩이가 납작해 보이는 자세  
• 디스크 압박 및 허리 통증  
• 둔근 긴장으로 인한 고관절 가동성 저하

근육 불균형:
• 긴장·단축된 근육: 복직근(Rectus abdominis), 햄스트링(Hamstrings), 대둔근(Gluteus maximus)  
• 약화·신장된 근육: 장요근(Iliopsoas), 척추기립근(Erector spinae)

교정 방향:
① 햄스트링 스트레칭 (벽 짚고 서서 다리 펴기)  
② 척추기립근 강화 (백 익스텐션, 버드독)  
③ 장요근 활성화 (Standing Hip Flexor Activation)  
④ 골반 전방경사 유도 (Pelvic Tilt Drill)

복합 증후군: Flat Back Syndrome, Upper Cross Syndrome과 연관 가능성 있음.
`;
  } else {
    description = `
📍 골반 중립 (Neutral Pelvic Alignment)
현재 상태: PTA ${PTA.toFixed(1)}° (정상: 0–15°)

골반이 안정된 중립 정렬 상태로, 허리 부담이 최소화되어 있습니다.  
현재 상태를 유지하기 위해 복부 코어 강화와 정기적인 스트레칭을 권장합니다.
`;
  }

  const pelvicDescEl = document.getElementById("pelvicDesc");
  if (pelvicDescEl) {
    pelvicDescEl.innerText = description.trim();
    pelvicDescEl.style.display = "block";
  }
}

// 3️⃣ AI 분석 자동 연결 (computeAll 함수에서 호출)
function analyzePelvicTiltAuto() {
  try {
    const S = sessions[cur];
    if (!S || !S.sidePoints) return;

    // ASIS와 PSIS 좌표 가져오기
    const asis = S.sidePoints.get('asis');
    const psis = S.sidePoints.get('psis');

    if (!asis || !psis || asis.x == null || asis.y == null || psis.x == null || psis.y == null) {
      // 좌표가 없으면 표시 영역 숨기기
      const pelvicDescEl = document.getElementById("pelvicDesc");
      if (pelvicDescEl) {
        pelvicDescEl.style.display = "none";
      }
      return;
    }

    // PTA 계산
    const PTA = calcPTA(asis, psis);
    
    // 설명 생성 및 표시
    getPelvicTiltDescription(PTA);

    console.log(`[AI-Posture] PTA=${PTA.toFixed(2)}° → 자동 분석 완료`);
  } catch (err) {
    console.warn('⚠️ 골반 분석 실패:', err);
  }
}
</script>
  </body>
</html>
